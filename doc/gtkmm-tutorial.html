<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html xmlns:set="http://exslt.org/sets" xmlns:str="http://exslt.org/strings">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Programming with gtkmm 4</title>
<style type="text/css">

html { height: 100%; }
body {
  margin: 0px; padding: 12px;
  background-color: #f9f9f6;
  min-height: 100%;
  direction: ltr;
}
div, p, pre, blockquote { margin: 0; padding: 0; }
p img { vertical-align: middle; }
sub { font-size: 0.83em; }
sub sub { font-size: 1em; }
sup { font-size: 0.83em; }
sup sup { font-size: 1em; }
table { border-collapse: collapse; }
table.table-pgwide { width: 100%; }
td { vertical-align: top; }
td { padding: 0.2em 0.83em 0.2em 0.83em; }
th { padding: 0 0.83em 0 0.83em; }
tr.tr-shade {
  background-color: #f9f9f6;
}
td.td-colsep { border-right: solid 1px; }
td.td-rowsep { border-bottom: solid 1px; }
thead { border-top: solid 2px; border-bottom: solid 2px; }
tfoot { border-top: solid 2px; border-bottom: solid 2px; }
div.body {
  padding: 1em;
  max-width: 60em;
  background-color: #ffffff;
  border: solid 1px #e0e0df;
}
div.body-sidebar {
  margin-right: 13em;
}
div.division div.division { margin-top: 1.72em; }
div.division div.division div.division { margin-top: 1.44em; }
div.header {
  margin: 0;
  color: #3f3f3f;
  border-bottom: solid 1px #e0e0df;
}
h1, h2, h3, h4, h5, h6, h7 {
  margin: 0; padding: 0;
  color: #3f3f3f;
}
h1.title { font-size: 1.72em; }
h2.title { font-size: 1.44em; }
h3.title { font-size: 1.2em; }
h4.title, h5.title, h6.title, h7.title { font-size: 1em; }
.block { margin-top: 1em; }
.block .block-first { margin-top: 0; }
.block-indent {
  margin-left left: 1.72em;
  margin-: 1em;
}
.block-indent .block-indent { margin-left: 0em; margin-right: 0em; }
td .block-indent  { margin-left: 0em; margin-right: 0em; }
dd .block-indent  { margin-left: 0em; margin-right: 0em; }
.block-verbatim { white-space: pre; }
div.title {
  margin-bottom: 0.2em;
  font-weight: bold;
  color: #3f3f3f;
}
div.title-formal { padding-left: 0.2em; padding-right: 0.2em; }
div.title-formal .label { font-weight: normal; }
a {
  color: #1f609f;
  text-decoration: none;
}
a:hover { text-decoration: underline; }
a:visited { color: #9f1f6f; }
ul, ol, dl { margin: 0; padding: 0; }
li {
  margin-top: 1em;
  margin-left: 2.4em;
  padding: 0;
}
li.li-first { margin-top: 0; }
dt { margin: 1em 0 0 0; }
dt.dt-first { margin: 0; }
dd {
  margin-left: 1.72em;
  margin-top: 0.5em;
}
dl.dl-compact dt { margin-top: 0; }
dl.dl-compact dd { margin-top: 0; margin-bottom: 0; }


ul.linktrail {
  display: block;
  margin: 0.2em 0 0 0;
  text-align: right;
}
li.linktrail { display: inline; margin: 0; padding: 0; }

li.linktrail::before {
  content: '  /  ';
  color: #3f3f3f;
}

li.linktrail-first::before, li.linktrail-only::before { content: ''; }


div.navbar {
  padding: 0.5em 1em 0.5em 1em;
  max-width: 60em;
  background-color: #ffffff;
  border: solid 1px #e0e0df;
}
div.navbar-top { margin-bottom: 1em; }
div.navbar-bottom { margin-top: 1em; clear: both; }
div.navbar img { border: 0; vertical-align: -0.4em; }
table.navbar { width: 100%; margin: 0; border: none; }
table.navbar td { padding: 0; border: none; }
td.navbar-next {
  text-align: right;
}
a.navbar-prev::before {
  
  content: '◀  ';
  color: #3f3f3f;
}
a.navbar-next::after {
  
  content: '  ▶';
  color: #3f3f3f;
}


div.sidebar {
  float: right;
  padding: 0; margin: 0; width: 12em;
}
div.sidenav {
  padding: 0.5em 1em 0 1em;
  background-color: #ffffff;
  border: solid 1px #e0e0df;
}
div.sidenav div.autotoc {
  background-color: #ffffff;
  border: none; padding: 0; margin: 0;
}
div.sidenav div.autotoc div.autotoc { margin-top: 0.5em; }
div.sidenav div.autotoc li { margin-bottom: 0.5em; }
div.sidenav div.autotoc div.autotoc div.autotoc {
  margin-left: 1em;
  margin-top: 0;
}
div.sidenav div.autotoc div.autotoc div.autotoc li { margin-bottom: 0; }


div.autotoc {
  
  display: table;
  margin-top: 1em;
  margin-left: 1.72em;
  padding: 0.5em 1em 0.5em 1em;
  background-color: #f0f9ff;
  border: solid 1px #c0c9ff;
}
div.autotoc ul { margin: 0; padding: 0; }
div.autotoc li { list-style-type: none; margin: 0; }
div.autotoc div.autotoc-title { margin-bottom: 0.5em; }
div.autotoc div.autotoc { border: none; padding: 0; margin-top: 0; margin-bottom: 0.5em; }
div.autotoc div.autotoc div.autotoc { margin-bottom: 0; }


span.bibliolabel {
  color: #3f3f3f;
}


div.admonition {
  padding: 0.5em 6px 0.5em 6px;
  border: solid 1px #e0e0df;
  background-color: #fffff0;
}
div.caution-inner, div.important-inner, div.note-inner, div.tip-inner, div.warning-inner {
  padding-left: 60px;
  background-position: left top;
  background-repeat: no-repeat;
  min-height: 48px;
}
div.caution-inner { background-image: url("/skin/admon-caution.png"); }
div.important-inner { background-image: url("/skin/admon-important.png"); }
div.note-inner { background-image: url("/skin/admon-note.png"); }
div.note-bug div.note-inner { background-image: url("/skin/admon-bug.png"); }
div.tip-inner { background-image: url("/skin/admon-tip.png"); }
div.warning-inner { background-image: url("/skin/admon-warning.png"); }
div.blockquote {
  
  background-image: url('watermark-blockquote-201C.png');
  background-repeat: no-repeat;
  background-position: top left;
  padding: 0.5em;
  padding-left: 4em;
}
div.attribution {
  margin-top: 0.5em;
  color: #3f3f3f;
}
div.attribution::before {
  
  content: '― ';
}
div.epigraph {
  text-align: right;
  margin-left: 20%;
  margin-right: 0;
  color: #3f3f3f;
}
div.figure, div.informalfigure {
  
  display: table;
  padding: 0.5em;
  background-color: #f9f9f6;
  border: solid 1px #e0e0df;
}
div.figure-inner, div.informalfigure-inner {
  padding: 0.5em;
  background-color: #ffffff;
  border: solid 1px #e0e0df;
}
div.caption { margin-top: 0.5em; }
div.programlisting {
  padding: 0.5em;
  
  background-color: #f9f9f6;
  border: solid 1px #e0e0df;
}
div.screen {
  padding: 0.5em;
  
  background-color: #f9f9f6;
  border: solid 1px #e0e0df;
}
div.screen .prompt {
  color: #3f3f3f;
}
div.screen .userinput {
  font-weight: bold;
  color: #3f3f3f;
}
div.programlisting .userinput {
  font-weight: bold;
  color: #3f3f3f;
}
pre.linenumbering {
  color: #3f3f3f;
  margin: 0;
  padding-right: 1em;
  float: left;
  text-align: right;
}



dl.index dt { margin-top: 0; }
dl.index dd { margin-top: 0; margin-bottom: 0; }
dl.indexdiv dt { margin-top: 0; }
dl.indexdiv dd { margin-top: 0; margin-bottom: 0; }
dl.setindex dt { margin-top: 0; }
dl.setindex dd { margin-top: 0; margin-bottom: 0; }
div.list div.title-formal span.title {
  border-bottom: solid 1px #e0e0df;
}
div.simplelist {
  margin-left: 1.72em;
}
div.simplelist table { margin-left: 0; border: none; }
div.simplelist td {
  padding: 0.5em;
  border-left: solid 1px #e0e0df;
}
div.simplelist td.td-first {
  padding-left: 0;
  border-left: 0;
}
div.synopsis {
  padding: 0.5em;
  
  background-color: #f9f9f6;
  border-top: solid 2px #c0c9ff;
  border-bottom: solid 2px #c0c9ff;
}
div.synopsis div.synopsis {
  padding: 0;
  border: none;
}
div.synopsis div.block { margin-top: 0.2em; }
div.synopsis div.block-first { margin-top: 0; }
div.cmdsynopsis { font-family: monospace; }

span.accel { text-decoration: underline; }
span.acronym { font-family: sans-serif; }
span.application { font-style: italic; }
span.classname, span.exceptionname, span.interfacename { font-family: monospace; }
span.code {
  font-family: monospace;
  border: solid 1px #e0e0df;
  padding-left: 0.2em;
  padding-right: 0.2em;
}
pre span.code { border: none; padding: 0; }
span.command {
  font-family: monospace;
  border: solid 1px #e0e0df;
  padding-left: 0.2em;
  padding-right: 0.2em;
}
pre span.command { border: none; padding: 0; }
span.computeroutput { font-family: monospace; }

span.constant { font-family: monospace; }
span.database { font-family: monospace; }
span.email { font-family: monospace; }
span.emphasis { font-style: italic; }
span.emphasis-bold { font-style: normal; font-weight: bold; }
span.envar { font-family: monospace; }

span.filename { font-family: monospace; }
span.firstterm { font-style: italic; }
span.foreignphrase { font-style: italic; }
span.function { font-family: monospace; }

dt.glossterm span.glossterm { font-style: normal; }


span.glossterm { font-style: italic; }

span.guibutton, span.guilabel, span.guimenu, span.guimenuitem, span.guisubmenu, span.interface {
  font-weight: bold;
  color: #3f3f3f;
}
span.keycap {
  font-weight: bold;
  color: #3f3f3f;
}
span.lineannotation { font-style: italic; }
span.literal { font-family: monospace; }
span.markup  { font-family: monospace; }
span.medialabel { font-style: italic; }
span.methodname { font-family: monospace; }
span.ooclass, span.ooexception, span.oointerface { font-family: monospace; }
span.option { font-family: monospace; }
span.package { font-family: monospace; }
span.parameter { font-family: monospace; }
span.paramdef span.parameter { font-style: italic; }
span.prompt { font-family: monospace; }
span.property { font-family: monospace; }
span.replaceable  { font-style: italic; }
span.returnvalue { font-family: monospace; }
span.sgmltag { font-family: monospace; }
span.structfield, span.structname { font-family: monospace; }
span.symbol { font-family: monospace; }
span.systemitem { font-family: monospace; }
span.token { font-family: monospace; }
span.type { font-family: monospace; }
span.uri { font-family: monospace; }
span.userinput { font-family: monospace; }
span.varname { font-family: monospace; }
span.wordasword { font-style: italic; }



div.footnotes { font-style: italic; font-size: 0.8em; }
div.footnote { margin-top: 1.44em; }
span.footnote-number { display: inline; padding-right: 0.83em; }
span.footnote-number + p { display: inline; }
a.footnote { text-decoration: none; font-size: 0.8em; }
a.footnote-ref { text-decoration: none; }

span.co {
  margin-left: 0.2em; margin-right: 0.2em;
  padding-left: 0.4em; padding-right: 0.4em;
  border: solid 1px #000000;
  -moz-border-radius: 8px;
  background-color: #000000;
  color: #FFFFFF;
  font-size: 8px;
}
span.co:hover {
  border-color: #333333;
  background-color: #333333;
  color: #FFFFFF;
}
span.co a { text-decoration: none; }
span.co a:hover { text-decoration: none; }

dt.question { margin-left: 0em; }
dt.question div.label { float: left; }
dd + dt.question { margin-top: 1em; }
dd.answer {
  margin-top: 1em;
  margin-left: 2em;
  margin-right: 1em;
}
dd.answer div.label { float: left; }
</style>
<link rel="stylesheet" type="text/css" media="all" href="https://static.gnome.org/css/grass-theme-style.css">
<link rel="stylesheet" type="text/css" media="all" href="/skin/lgo2010.css">
<link rel="icon" type="image/png" href="/skin/gnome-16.png">
<link rel="SHORTCUT ICON" type="image/png" href="/skin/gnome-16.png">
<link rel="search" type="application/opensearchdescription+xml" href="/gnome-library-search.xml" title="GNOME Library Search">
<link rel="stylesheet" type="text/css" href="/skin/jquery.autocomplete.css">
<script type="text/javascript" src="/js/jquery.js"></script><script type="text/javascript" src="/js/jquery.autocomplete.js"></script><script type="text/javascript" src="/js/jquery.js"></script>
</head>
<body>
<div id="accessibility_access"><ul>
<li><a href="#container">Go to page content</a></li>
<li><a href="#top_bar">Go to main menu</a></li>
<li><a href="#s" onclick="$('#s').focus(); return false;">Go to the search field</a></li>
</ul></div>
<div id="global_domain_bar"><div class="maxwidth"><div class="tab"><a class="root" href="https://www.gnome.org/">GNOME.org</a></div></div></div>
<div id="header" class="container_12">
<div id="logo" class="grid_3"><a title="Go to home page" href="/"><img alt="GNOME: The Free Software Desktop Project" src="/skin/gnome-logo-devcenter.png"></a></div>
<div id="top_bar" class="grid_9">
<div class="left"><div class="menu-globalnav-container"><ul id="menu-globalnav" class="menu">
<li class="menu-item menu-item-type-post_type menu-item-6"><a href="/about/">About</a></li>
<li class="menu-item menu-item-type-post_type menu-item-23"><a href="https://help.gnome.org/users/">Users</a></li>
<li class="menu-item menu-item-type-post_type menu-item-40"><a href="https://help.gnome.org/admin/">Administrators</a></li>
<li class="current-menu-item"><a href="https://developer.gnome.org/">Developers</a></li>
</ul></div></div>
<div class="right">
<form role="search" method="get" id="searchform" action="/symbols/"><div>
<label class="hidden" for="q">Search:
                        </label><input type="text" value="" name="q" id="s" placeholder="Search">
</div></form>
<script type="text/javascript">
$('#s').autocomplete('/symbols/lookup/',
        { minChars:3, matchSubset:1, matchContains:1, cacheLength:10,
          selectOnly:1, rowsLimit:25 });
              </script>
</div>
</div>
</div>
<div class="clearfix"></div>
<div id="container" class="two_columns">
<div class="content">
<div class="division book" dir="ltr">
<a name="index"><!--index--></a><div class="header"><h1 class="book title"><span class="title">Programming with <span class="application">gtkmm</span> 4</span></h1></div>
<div class="autotoc"><ul>
<li>
<span class="label">1. </span><a class="xref" href="#chapter-introduction" title="Introduction">Introduction</a><div class="autotoc"><ul>
<li>
<span class="label">1.1. </span><a class="xref" href="#sec-this-book" title="This book">This book</a>
</li>
<li>
<span class="label">1.2. </span><a class="xref" href="#sec-gtkmm" title="gtkmm">gtkmm</a>
</li>
</ul></div>
</li>
<li>
<span class="label">2. </span><a class="xref" href="#chapter-installation" title="Installation">Installation</a><div class="autotoc"><ul>
<li>
<span class="label">2.1. </span><a class="xref" href="#sec-installation-dependencies" title="Dependencies">Dependencies</a>
</li>
<li>
<span class="label">2.2. </span><a class="xref" href="#sec-install-unix-and-linux" title="Unix and Linux">Unix and Linux</a>
</li>
<li>
<span class="label">2.3. </span><a class="xref" href="#sec-packages-windows" title="Microsoft Windows">Microsoft Windows</a>
</li>
</ul></div>
</li>
<li>
<span class="label">3. </span><a class="xref" href="#chapter-basics" title="Basics">Basics</a><div class="autotoc"><ul>
<li>
<span class="label">3.1. </span><a class="xref" href="#sec-basics-simple-example" title="Simple Example">Simple Example</a>
</li>
<li>
<span class="label">3.2. </span><a class="xref" href="#sec-headers-and-linking" title="Headers and Linking">Headers and Linking</a>
</li>
<li>
<span class="label">3.3. </span><a class="xref" href="#sec-widgets-overview" title="Widgets">Widgets</a>
</li>
<li>
<span class="label">3.4. </span><a class="xref" href="#sec-signals-overview" title="Signals">Signals</a>
</li>
<li>
<span class="label">3.5. </span><a class="xref" href="#sec-basics-ustring" title="Glib::ustring">Glib::ustring</a>
</li>
<li>
<span class="label">3.6. </span><a class="xref" href="#sec-basics-gobj-and-wrap" title="Mixing C and C++ APIs">Mixing C and C++ APIs</a>
</li>
<li>
<span class="label">3.7. </span><a class="xref" href="#sec-helloworld" title="Hello World in gtkmm">Hello World in <span class="application">gtkmm</span></a>
</li>
</ul></div>
</li>
<li>
<span class="label">4. </span><a class="xref" href="#changes-gtkmm3" title="Changes in gtkmm 3">Changes in <span class="application">gtkmm</span> 3</a><div class="autotoc"><ul></ul></div>
</li>
<li>
<span class="label">5. </span><a class="xref" href="#changes-gtkmm4" title="Changes in gtkmm-4.0 and glibmm-2.68">Changes in <span class="application">gtkmm</span>-4.0 and <span class="application">glibmm-2.68</span></a><div class="autotoc"><ul></ul></div>
</li>
<li>
<span class="label">6. </span><a class="xref" href="#chapter-button-widget" title="Buttons">Buttons</a><div class="autotoc"><ul>
<li>
<span class="label">6.1. </span><a class="xref" href="#sec-pushbuttons" title="Button">Button</a>
</li>
<li>
<span class="label">6.2. </span><a class="xref" href="#sec-toggle-buttons" title="ToggleButton">ToggleButton</a>
</li>
<li>
<span class="label">6.3. </span><a class="xref" href="#sec-checkbuttons" title="CheckButton">CheckButton</a>
</li>
<li>
<span class="label">6.4. </span><a class="xref" href="#sec-radio-buttons" title="Radio Button">Radio Button</a>
</li>
</ul></div>
</li>
<li>
<span class="label">7. </span><a class="xref" href="#chapter-range-widgets" title="Range Widgets">Range Widgets</a><div class="autotoc"><ul>
<li>
<span class="label">7.1. </span><a class="xref" href="#sec-scrollbar-widgets" title="Scrollbar Widgets">Scrollbar Widgets</a>
</li>
<li>
<span class="label">7.2. </span><a class="xref" href="#sec-scale-widgets" title="Scale Widgets">Scale Widgets</a>
</li>
<li>
<span class="label">7.3. </span><a class="xref" href="#sec-range-example" title="Example">Example</a>
</li>
</ul></div>
</li>
<li>
<span class="label">8. </span><a class="xref" href="#chapter-misc-widgets" title="Miscellaneous Widgets">Miscellaneous Widgets</a><div class="autotoc"><ul>
<li>
<span class="label">8.1. </span><a class="xref" href="#sec-labels" title="Label">Label</a>
</li>
<li>
<span class="label">8.2. </span><a class="xref" href="#sec-text-entry" title="Entry">Entry</a>
</li>
<li>
<span class="label">8.3. </span><a class="xref" href="#sec-spinbutton" title="SpinButton">SpinButton</a>
</li>
<li>
<span class="label">8.4. </span><a class="xref" href="#sec-progressbar" title="ProgressBar">ProgressBar</a>
</li>
<li>
<span class="label">8.5. </span><a class="xref" href="#sec-infobar" title="InfoBar">InfoBar</a>
</li>
<li>
<span class="label">8.6. </span><a class="xref" href="#sec-tooltips" title="Tooltips">Tooltips</a>
</li>
</ul></div>
</li>
<li>
<span class="label">9. </span><a class="xref" href="#chapter-container-widgets" title="Container Widgets">Container Widgets</a><div class="autotoc"><ul>
<li>
<span class="label">9.1. </span><a class="xref" href="#sec-single-item-containers" title="Single-item Containers">Single-item Containers</a>
</li>
<li>
<span class="label">9.2. </span><a class="xref" href="#sec-multi-item-containers" title="Multiple-item Containers ">Multiple-item Containers </a>
</li>
</ul></div>
</li>
<li>
<span class="label">10. </span><a class="xref" href="#chapter-treeview" title="The TreeView widget">The TreeView widget</a><div class="autotoc"><ul>
<li>
<span class="label">10.1. </span><a class="xref" href="#sec-treeview-model" title="The Model">The Model</a>
</li>
<li>
<span class="label">10.2. </span><a class="xref" href="#sec-treeview" title="The View">The View</a>
</li>
<li>
<span class="label">10.3. </span><a class="xref" href="#sec-iterating-over-model-rows" title="Iterating over Model Rows">Iterating over Model Rows</a>
</li>
<li>
<span class="label">10.4. </span><a class="xref" href="#sec-treeview-selection" title="The Selection">The Selection</a>
</li>
<li>
<span class="label">10.5. </span><a class="xref" href="#sec-treeview-sort" title="Sorting">Sorting</a>
</li>
<li>
<span class="label">10.6. </span><a class="xref" href="#sec-treeview-draganddrop" title="Drag and Drop">Drag and Drop</a>
</li>
<li>
<span class="label">10.7. </span><a class="xref" href="#sec-treeview-contextmenu" title="Popup Context Menu">Popup Context Menu</a>
</li>
<li>
<span class="label">10.8. </span><a class="xref" href="#sec-treeview-examples" title="Examples">Examples</a>
</li>
</ul></div>
</li>
<li>
<span class="label">11. </span><a class="xref" href="#chapter-combobox" title="Combo Boxes">Combo Boxes</a><div class="autotoc"><ul>
<li>
<span class="label">11.1. </span><a class="xref" href="#sec-combobox-model" title="The model">The model</a>
</li>
<li>
<span class="label">11.2. </span><a class="xref" href="#sec-combobox-get" title="The chosen item">The chosen item</a>
</li>
<li>
<span class="label">11.3. </span><a class="xref" href="#sec-combobox-changes" title="Responding to changes">Responding to changes</a>
</li>
<li>
<span class="label">11.4. </span><a class="xref" href="#combobox-example-full" title="Full Example">Full Example</a>
</li>
<li>
<span class="label">11.5. </span><a class="xref" href="#combobox-example-simple" title="Simple Text Example">Simple Text Example</a>
</li>
<li>
<span class="label">11.6. </span><a class="xref" href="#sec-comboboxentry" title="ComboBox with an Entry">ComboBox with an Entry</a>
</li>
</ul></div>
</li>
<li>
<span class="label">12. </span><a class="xref" href="#chapter-textview" title="TextView">TextView</a><div class="autotoc"><ul>
<li>
<span class="label">12.1. </span><a class="xref" href="#sec-textview-buffer" title="The Buffer">The Buffer</a>
</li>
<li>
<span class="label">12.2. </span><a class="xref" href="#sec-widgets-and-childanchors" title="Widgets and ChildAnchors">Widgets and ChildAnchors</a>
</li>
<li>
<span class="label">12.3. </span><a class="xref" href="#sec-textview-examples" title="Examples">Examples</a>
</li>
</ul></div>
</li>
<li>
<span class="label">13. </span><a class="xref" href="#chapter-menus-and-toolbars" title="Menus and Toolbars">Menus and Toolbars</a><div class="autotoc"><ul>
<li>
<span class="label">13.1. </span><a class="xref" href="#sec-actions" title="Actions">Actions</a>
</li>
<li>
<span class="label">13.2. </span><a class="xref" href="#sec-menubar-and-toolbar" title="Menubar and Toolbar">Menubar and Toolbar</a>
</li>
<li>
<span class="label">13.3. </span><a class="xref" href="#sec-menus-popup" title="Popup Menus">Popup Menus</a>
</li>
<li>
<span class="label">13.4. </span><a class="xref" href="#sec-gio-resource" title="Gio::Resource and glib-compile-resources">Gio::Resource and glib-compile-resources</a>
</li>
<li>
<span class="label">13.5. </span><a class="xref" href="#sec-menus-examples" title="Examples">Examples</a>
</li>
</ul></div>
</li>
<li>
<span class="label">14. </span><a class="xref" href="#chapter-adjustment" title="Adjustments">Adjustments</a><div class="autotoc"><ul>
<li>
<span class="label">14.1. </span><a class="xref" href="#sec-creating-adjustment" title="Creating an Adjustment">Creating an Adjustment</a>
</li>
<li>
<span class="label">14.2. </span><a class="xref" href="#sec-adjustments-easy" title="Using Adjustments the Easy Way">Using Adjustments the Easy Way</a>
</li>
<li>
<span class="label">14.3. </span><a class="xref" href="#sec-adjustment-internals" title="Adjustment Internals">Adjustment Internals</a>
</li>
</ul></div>
</li>
<li>
<span class="label">15. </span><a class="xref" href="#chapter-dialogs" title="Dialogs">Dialogs</a><div class="autotoc"><ul>
<li>
<span class="label">15.1. </span><a class="xref" href="#sec-dialogs-messagedialog" title="MessageDialog">MessageDialog</a>
</li>
<li>
<span class="label">15.2. </span><a class="xref" href="#sec-dialogs-filechooserdialog" title="FileChooserDialog">FileChooserDialog</a>
</li>
<li>
<span class="label">15.3. </span><a class="xref" href="#sec-color-selection-dialog" title="ColorChooserDialog">ColorChooserDialog</a>
</li>
<li>
<span class="label">15.4. </span><a class="xref" href="#sec-font-chooser-dialog" title="FontChooserDialog">FontChooserDialog</a>
</li>
<li>
<span class="label">15.5. </span><a class="xref" href="#sec-about-dialog" title="Non-modal AboutDialog">Non-modal AboutDialog</a>
</li>
</ul></div>
</li>
<li>
<span class="label">16. </span><a class="xref" href="#chapter-drawingarea" title="The DrawingArea Widget">The DrawingArea Widget</a><div class="autotoc"><ul>
<li>
<span class="label">16.1. </span><a class="xref" href="#sec-cairo-drawing-model" title="The Cairo Drawing Model">The Cairo Drawing Model</a>
</li>
<li>
<span class="label">16.2. </span><a class="xref" href="#sec-cairo-drawing-lines" title="Drawing Straight Lines">Drawing Straight Lines</a>
</li>
<li>
<span class="label">16.3. </span><a class="xref" href="#sec-cairo-curved-lines" title="Drawing Curved Lines">Drawing Curved Lines</a>
</li>
<li>
<span class="label">16.4. </span><a class="xref" href="#sec-cairo-drawing-arcs" title="Drawing Arcs and Circles">Drawing Arcs and Circles</a>
</li>
<li>
<span class="label">16.5. </span><a class="xref" href="#sec-drawing-text" title="Drawing Text">Drawing Text</a>
</li>
<li>
<span class="label">16.6. </span><a class="xref" href="#sec-draw-images" title="Drawing Images">Drawing Images</a>
</li>
<li>
<span class="label">16.7. </span><a class="xref" href="#sec-drawing-clock-example" title="Example Application: Creating a Clock with Cairo">Example Application: Creating a Clock with Cairo</a>
</li>
</ul></div>
</li>
<li>
<span class="label">17. </span><a class="xref" href="#chapter-draganddrop" title="Drag and Drop">Drag and Drop</a><div class="autotoc"><ul>
<li>
<span class="label">17.1. </span><a class="xref" href="#sec-dnd-sources-destinations" title="Sources and Destinations">Sources and Destinations</a>
</li>
<li>
<span class="label">17.2. </span><a class="xref" href="#sec-dnd-methods" title="Methods">Methods</a>
</li>
<li>
<span class="label">17.3. </span><a class="xref" href="#sec-dnd-signals" title="Signals">Signals</a>
</li>
<li>
<span class="label">17.4. </span><a class="xref" href="#sec-dnd-example" title="Example">Example</a>
</li>
</ul></div>
</li>
<li>
<span class="label">18. </span><a class="xref" href="#chapter-clipboard" title="The Clipboard">The Clipboard</a><div class="autotoc"><ul>
<li>
<span class="label">18.1. </span><a class="xref" href="#sec-clipboard-formats" title="Formats">Formats</a>
</li>
<li>
<span class="label">18.2. </span><a class="xref" href="#sec-clipboard-copy" title="Copy">Copy</a>
</li>
<li>
<span class="label">18.3. </span><a class="xref" href="#sec-clipboard-paste" title="Paste">Paste</a>
</li>
<li>
<span class="label">18.4. </span><a class="xref" href="#sec-clipboard-examples" title="Examples">Examples</a>
</li>
</ul></div>
</li>
<li>
<span class="label">19. </span><a class="xref" href="#chapter-printing" title="Printing">Printing</a><div class="autotoc"><ul>
<li>
<span class="label">19.1. </span><a class="xref" href="#sec-printoperation" title="PrintOperation">PrintOperation</a>
</li>
<li>
<span class="label">19.2. </span><a class="xref" href="#sec-page-setup" title="Page setup">Page setup</a>
</li>
<li>
<span class="label">19.3. </span><a class="xref" href="#sec-printing-rendering-text" title="Rendering text">Rendering text</a>
</li>
<li>
<span class="label">19.4. </span><a class="xref" href="#sec-async-printing-ops" title="Asynchronous operations">Asynchronous operations</a>
</li>
<li>
<span class="label">19.5. </span><a class="xref" href="#sec-printing-export-to-pdf" title="Export to PDF">Export to PDF</a>
</li>
<li>
<span class="label">19.6. </span><a class="xref" href="#sec-extending-print-dialog" title="Extending the print dialog">Extending the print dialog</a>
</li>
<li>
<span class="label">19.7. </span><a class="xref" href="#sec-printing-preview" title="Preview">Preview</a>
</li>
<li>
<span class="label">19.8. </span><a class="xref" href="#sec-printing-example" title="Example">Example</a>
</li>
</ul></div>
</li>
<li>
<span class="label">20. </span><a class="xref" href="#chapter-recent-documents" title="Recently Used Documents">Recently Used Documents</a><div class="autotoc"><ul>
<li>
<span class="label">20.1. </span><a class="xref" href="#sec-recentmanager" title="RecentManager">RecentManager</a>
</li>
<li>
<span class="label">20.2. </span><a class="xref" href="#sec-filechooser" title="FileChooser">FileChooser</a>
</li>
</ul></div>
</li>
<li>
<span class="label">21. </span><a class="xref" href="#chapter-keyboardevents" title="Keyboard Events">Keyboard Events</a><div class="autotoc"><ul>
<li>
<span class="label">21.1. </span><a class="xref" href="#sec-keyboardevents-overview" title="Overview">Overview</a>
</li>
<li>
<span class="label">21.2. </span><a class="xref" href="#sec-keyboardevents-propagation" title="Event Propagation">Event Propagation</a>
</li>
</ul></div>
</li>
<li>
<span class="label">22. </span><a class="xref" href="#chapter-chapter-timeouts" title="Timeouts, I/O and Idle Functions ">Timeouts, I/O and Idle Functions </a><div class="autotoc"><ul>
<li>
<span class="label">22.1. </span><a class="xref" href="#sec-timeouts" title="Timeouts">Timeouts</a>
</li>
<li>
<span class="label">22.2. </span><a class="xref" href="#sec-monitoring-io" title="Monitoring I/O">Monitoring I/O</a>
</li>
<li>
<span class="label">22.3. </span><a class="xref" href="#sec-idle-functions" title="Idle Functions">Idle Functions</a>
</li>
</ul></div>
</li>
<li>
<span class="label">23. </span><a class="xref" href="#chapter-memory" title="Memory management">Memory management</a><div class="autotoc"><ul>
<li>
<span class="label">23.1. </span><a class="xref" href="#sec-memory-widgets" title="Widgets">Widgets</a>
</li>
<li>
<span class="label">23.2. </span><a class="xref" href="#sec-memory-shared-resources" title="Shared resources">Shared resources</a>
</li>
</ul></div>
</li>
<li>
<span class="label">24. </span><a class="xref" href="#chapter-builder" title="Glade and Gtk::Builder">Glade and Gtk::Builder</a><div class="autotoc"><ul>
<li>
<span class="label">24.1. </span><a class="xref" href="#sec-builder-loading-glade-file" title="Loading the .glade file">Loading the .glade file</a>
</li>
<li>
<span class="label">24.2. </span><a class="xref" href="#sec-builder-accessing-widgets" title="Accessing widgets">Accessing widgets</a>
</li>
<li>
<span class="label">24.3. </span><a class="xref" href="#sec-builder-using-derived-widgets" title="Using derived widgets">Using derived widgets</a>
</li>
</ul></div>
</li>
<li>
<span class="label">25. </span><a class="xref" href="#chapter-internationalization" title="Internationalization and Localization">Internationalization and Localization</a><div class="autotoc"><ul>
<li>
<span class="label">25.1. </span><a class="xref" href="#sec-internationalization-intro" title="Preparing your project">Preparing your project</a>
</li>
<li>
<span class="label">25.2. </span><a class="xref" href="#sec-i18n-marking-strings" title="Marking strings for translation">Marking strings for translation</a>
</li>
<li>
<span class="label">25.3. </span><a class="xref" href="#sec-i18n-expecting-utf8" title="Expecting UTF8">Expecting UTF8</a>
</li>
<li>
<span class="label">25.4. </span><a class="xref" href="#sec-i18n-pitfalls" title="Pitfalls">Pitfalls</a>
</li>
<li>
<span class="label">25.5. </span><a class="xref" href="#sec-i18n-getting-help-with-translations" title="Getting help with translations">Getting help with translations</a>
</li>
</ul></div>
</li>
<li>
<span class="label">26. </span><a class="xref" href="#chapter-customwidgets" title="Custom Widgets">Custom Widgets</a><div class="autotoc"><ul>
<li>
<span class="label">26.1. </span><a class="xref" href="#sec-custom-containers" title="Custom Containers">Custom Containers</a>
</li>
<li>
<span class="label">26.2. </span><a class="xref" href="#sec-custom-widgets" title="Custom Widgets">Custom Widgets</a>
</li>
</ul></div>
</li>
<li>
<span class="label">27. </span><a class="xref" href="#chapter-multi-threaded-programs" title="Multi-threaded programs">Multi-threaded programs</a><div class="autotoc"><ul>
<li>
<span class="label">27.1. </span><a class="xref" href="#sec-the-constraints" title="The constraints">The constraints</a>
</li>
<li>
<span class="label">27.2. </span><a class="xref" href="#sec-using-glib-dispatcher" title="Using Glib::Dispatcher">Using Glib::Dispatcher</a>
</li>
<li>
<span class="label">27.3. </span><a class="xref" href="#sec-multithread-example" title="Example">Example</a>
</li>
</ul></div>
</li>
<li>
<span class="label">28. </span><a class="xref" href="#chapter-recommended-techniques" title="Recommended Techniques">Recommended Techniques</a><div class="autotoc"><ul>
<li>
<span class="label">28.1. </span><a class="xref" href="#sec-application-lifetime" title="Application Lifetime">Application Lifetime</a>
</li>
<li>
<span class="label">28.2. </span><a class="xref" href="#sec-using-a-gtkmm-widget" title="Using a gtkmm widget">Using a <span class="application">gtkmm</span> widget</a>
</li>
</ul></div>
</li>
<li>
<span class="label">29. </span><a class="xref" href="#chapter-building-applications" title="Building applications">Building applications</a><div class="autotoc"><ul>
<li>
<span class="label">29.1. </span><a class="xref" href="#sec-buildapp-trivial-app" title="A trivial application">A trivial application</a>
</li>
<li>
<span class="label">29.2. </span><a class="xref" href="#sec-buildapp-populating-window" title="Populating the window">Populating the window</a>
</li>
<li>
<span class="label">29.3. </span><a class="xref" href="#sec-buildapp-opening-files" title="Opening files">Opening files</a>
</li>
<li>
<span class="label">29.4. </span><a class="xref" href="#sec-buildapp-menu" title="A menu">A menu</a>
</li>
<li>
<span class="label">29.5. </span><a class="xref" href="#sec-buildapp-pref-dialog" title="A preference dialog">A preference dialog</a>
</li>
<li>
<span class="label">29.6. </span><a class="xref" href="#sec-buildapp-search-bar" title="Adding a search bar">Adding a search bar</a>
</li>
<li>
<span class="label">29.7. </span><a class="xref" href="#sec-buildapp-side-bar" title="Adding a side bar">Adding a side bar</a>
</li>
<li>
<span class="label">29.8. </span><a class="xref" href="#sec-buildapp-properties" title="Properties">Properties</a>
</li>
<li>
<span class="label">29.9. </span><a class="xref" href="#sec-buildapp-header-bar" title="Header bar">Header bar</a>
</li>
</ul></div>
</li>
<li>
<span class="label">30. </span><a class="xref" href="#chapter-contributing" title="Contributing">Contributing</a><div class="autotoc"><ul></ul></div>
</li>
<li>
<span class="label">A. </span><a class="xref" href="#chapter-refptr" title="The RefPtr smartpointer">The RefPtr smartpointer</a><div class="autotoc"><ul>
<li>
<span class="label">A.1. </span><a class="xref" href="#sec-refptr-copying" title="Copying">Copying</a>
</li>
<li>
<span class="label">A.2. </span><a class="xref" href="#sec-refptr-dereferencing" title="Dereferencing">Dereferencing</a>
</li>
<li>
<span class="label">A.3. </span><a class="xref" href="#sec-refptr-casting" title="Casting">Casting</a>
</li>
<li>
<span class="label">A.4. </span><a class="xref" href="#sec-refptr-checking-for-null" title="Checking for nullptr">Checking for nullptr</a>
</li>
<li>
<span class="label">A.5. </span><a class="xref" href="#sec-refptr-constness" title="Constness">Constness</a>
</li>
</ul></div>
</li>
<li>
<span class="label">B. </span><a class="xref" href="#chapter-signals" title="Signals">Signals</a><div class="autotoc"><ul>
<li>
<span class="label">B.1. </span><a class="xref" href="#sec-connecting-signal-handlers" title="Connecting signal handlers">Connecting signal handlers</a>
</li>
<li>
<span class="label">B.2. </span><a class="xref" href="#sec-writing-signal-handlers" title="Writing signal handlers">Writing signal handlers</a>
</li>
<li>
<span class="label">B.3. </span><a class="xref" href="#sec-disconnecting-signal-handlers" title="Disconnecting signal handlers">Disconnecting signal handlers</a>
</li>
<li>
<span class="label">B.4. </span><a class="xref" href="#sec-overriding-default-signal-handlers" title="Overriding default signal handlers">Overriding default signal handlers</a>
</li>
<li>
<span class="label">B.5. </span><a class="xref" href="#sec-binding-extra-arguments" title="Binding extra arguments">Binding extra arguments</a>
</li>
<li>
<span class="label">B.6. </span><a class="xref" href="#sec-xeventsignals" title="X Event signals">X Event signals</a>
</li>
<li>
<span class="label">B.7. </span><a class="xref" href="#sec-exceptions-in-signal-handlers" title="Exceptions in signal handlers">Exceptions in signal handlers</a>
</li>
</ul></div>
</li>
<li>
<span class="label">C. </span><a class="xref" href="#chapter-custom-signals" title="Creating your own signals">Creating your own signals</a><div class="autotoc"><ul><li>
<span class="label">C.1. </span><a class="xref" href="#chapter-custom-signals-example" title="Example">Example</a>
</li></ul></div>
</li>
<li>
<span class="label">D. </span><a class="xref" href="#sec-signals-comparison" title="Comparison with other signalling systems">Comparison with other signalling systems</a><div class="autotoc"><ul></ul></div>
</li>
<li>
<span class="label">E. </span><a class="xref" href="#sec-windows-installation" title="gtkmm and Win32"><span class="application">gtkmm</span> and Win32</a><div class="autotoc"><ul></ul></div>
</li>
<li>
<span class="label">F. </span><a class="xref" href="#chapter-working-with-source" title="Working with gtkmm's Source Code">Working with gtkmm's Source Code</a><div class="autotoc"><ul>
<li>
<span class="label">F.1. </span><a class="xref" href="#sec-setting-up-jhbuild" title="Setting up jhbuild">Setting up jhbuild</a>
</li>
<li>
<span class="label">F.2. </span><a class="xref" href="#sec-installing-jhbuild" title="Installing and Using the git version of gtkmm">Installing and Using the git version of <span class="application">gtkmm</span></a>
</li>
</ul></div>
</li>
<li>
<span class="label">G. </span><a class="xref" href="#chapter-wrapping-c-libraries" title="Wrapping C Libraries with gmmproc">Wrapping C Libraries with gmmproc</a><div class="autotoc"><ul>
<li>
<span class="label">G.1. </span><a class="xref" href="#sec-wrapping-build-structure" title="The build structure">The build structure</a>
</li>
<li>
<span class="label">G.2. </span><a class="xref" href="#sec-wrapping-defs-files" title="Generating the .defs files.">Generating the .defs files.</a>
</li>
<li>
<span class="label">G.3. </span><a class="xref" href="#sec-wrapping-hg-files" title="The .hg and .ccg files">The .hg and .ccg files</a>
</li>
<li>
<span class="label">G.4. </span><a class="xref" href="#sec-wrapping-hand-coded-files" title="Hand-coded source files">Hand-coded source files</a>
</li>
<li>
<span class="label">G.5. </span><a class="xref" href="#sec-wrapping-initialization" title="Initialization">Initialization</a>
</li>
<li>
<span class="label">G.6. </span><a class="xref" href="#sec-wrapping-problems" title="Problems in the C API.">Problems in the C API.</a>
</li>
<li>
<span class="label">G.7. </span><a class="xref" href="#sec-wrapping-documentation" title="Documentation">Documentation</a>
</li>
</ul></div>
</li>
</ul></div>
<div class="division chapter">
<a name="chapter-introduction"><!--chapter-introduction--></a><div class="header"><h2 class="chapter title"><span class="title"><span class="label">1. </span>Introduction</span></h2></div>
<div class="autotoc"><ul>
<li>
<span class="label">1.1. </span><a class="xref" href="#sec-this-book" title="This book">This book</a>
</li>
<li>
<span class="label">1.2. </span><a class="xref" href="#sec-gtkmm" title="gtkmm">gtkmm</a>
</li>
</ul></div>
<div class="division sect1">
<a name="sec-this-book"><!--sec-this-book--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">1.1. </span>This book</span></h3></div>
<p class="para block block-first">This book explains key concepts of the <span class="application">gtkmm</span> C++ API for creating user interfaces. It also introduces the main user interface elements ("widgets"). Although it mentions classes, constructors, and methods, it does not go into great detail. Therefore, for full API information you should follow the links into the reference documentation.</p>
<p class="para block">This book assumes a good understanding of C++, and how to create C++ programs.</p>
<p class="para block">
We would very much like to hear of any problems you have learning <span class="application">gtkmm</span>
with this document, and would appreciate input regarding improvements. Please see the <a class="link" href="#chapter-contributing" title="Contributing">Contributing</a> section for further information.
</p>
<div class="admonition block note block-indent"><div class="note-inner">
<p class="para block block-first">
This book describes <span class="application">gtkmm</span> 4, but some sections have not been fully updated.
There are paragraphs that describe <span class="application">gtkmm</span> 3 rather than <span class="application">gtkmm</span> 4.
All shown example programs are compatible with <span class="application">gtkmm</span> 4, though.
</p>
</div></div>
</div>
<div class="division sect1">
<a name="sec-gtkmm"><!--sec-gtkmm--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">1.2. </span>gtkmm</span></h3></div>
<p class="para block block-first">
<span class="application">gtkmm</span> is a C++ wrapper for
<a class="ulink" href="http://www.gtk.org/" title="http://www.gtk.org/">GTK</a>,
a library used to create graphical user
interfaces. It is licensed using the LGPL license, so you can develop
open software, free software, or even commercial non-free software
using <span class="application">gtkmm</span> without purchasing licenses.
</p>
<p class="para block"><span class="application">gtkmm</span> was originally named gtk-- because GTK was originally named GTK+
and had a + in the name. However, as -- is not easily indexed by search engines,
the package generally went by the name <span class="application">gtkmm</span>, and that's what we stuck with.</p>
<div class="autotoc"><ul>
<li>
<span class="label">1.2.1. </span><a class="xref" href="#why-use-gtkmm" title="Why use gtkmm instead of GTK?">Why use <span class="application">gtkmm</span> instead of GTK?</a>
</li>
<li>
<span class="label">1.2.2. </span><a class="xref" href="#gtkmm-vs-qt" title="gtkmm compared to Qt"><span class="application">gtkmm</span> compared to Qt</a>
</li>
<li>
<span class="label">1.2.3. </span><a class="xref" href="#gtkmm-is-a-wrapper" title="gtkmm is a wrapper"><span class="application">gtkmm</span> is a wrapper</a>
</li>
</ul></div>
<div class="division sect2">
<a name="why-use-gtkmm"><!--why-use-gtkmm--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">1.2.1. </span>Why use <span class="application">gtkmm</span> instead of GTK?</span></h4></div>
<p class="para block block-first"><span class="application">gtkmm</span> allows you to write code using normal C++ techniques such as encapsulation, derivation, and polymorphism. As a C++ programmer you probably already realise that this leads to clearer and better organized code.</p>
<p class="para block"><span class="application">gtkmm</span> is more type-safe, so the compiler can detect errors that would only be detected at run time when using C. This use of specific types also makes the API clearer because you can see what types should be used just by looking at a method's declaration.</p>
<p class="para block">Inheritance can be used to derive new widgets. The derivation of new widgets in GTK C code is so complicated and error prone that almost no C coders do it. As a C++ developer you know that derivation is an essential Object Orientated technique.</p>
<p class="para block">Member instances can be used, simplifying memory management. All GTK C widgets are dealt with by use of pointers. As a C++ coder you know that pointers should be avoided where possible.</p>
<p class="para block"><span class="application">gtkmm</span> involves less code compared to GTK, which uses prefixed function names and lots of cast macros.</p>
</div>
<div class="division sect2">
<a name="gtkmm-vs-qt"><!--gtkmm-vs-qt--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">1.2.2. </span><span class="application">gtkmm</span> compared to Qt</span></h4></div>
<p class="para block block-first">Trolltech's Qt is the closest competition to <span class="application">gtkmm</span>, so it deserves discussion.</p>
<p class="para block"><span class="application">gtkmm</span> developers tend to prefer <span class="application">gtkmm</span> to Qt because <span class="application">gtkmm</span> does things in a more C++ way. Qt originates from a time when C++ and the standard library were not standardised or well supported by compilers. It therefore duplicates a lot of stuff that is now in the standard library, such as containers and type information. Most significantly, Trolltech modified the C++ language to provide signals, so that Qt classes cannot be used easily with non-Qt classes. <span class="application">gtkmm</span> was able to use standard C++ to provide signals without changing the C++ language.
See the <a class="ulink" href="https://wiki.gnome.org/Projects/gtkmm/FAQ" title="https://wiki.gnome.org/Projects/gtkmm/FAQ">FAQ</a> for more detailed differences.</p>
</div>
<div class="division sect2">
<a name="gtkmm-is-a-wrapper"><!--gtkmm-is-a-wrapper--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">1.2.3. </span><span class="application">gtkmm</span> is a wrapper</span></h4></div>
<p class="para block block-first">
<span class="application">gtkmm</span> is not a native C++ toolkit, but a C++ wrapper of a C toolkit. This separation of interface and implementation has advantages. The <span class="application">gtkmm</span> developers spend most of their time talking about how <span class="application">gtkmm</span> can present the clearest API, without awkward compromises due to obscure technical details. We contribute a little to the underlying GTK code base, but so do the C coders, and the Perl coders and the Python coders, etc. Therefore GTK benefits from a broader user base than language-specific toolkits - there are more implementers, more developers, more testers, and more users.</p>
</div>
</div>
</div>
<div class="division chapter">
<a name="chapter-installation"><!--chapter-installation--></a><div class="header"><h2 class="chapter title"><span class="title"><span class="label">2. </span>Installation</span></h2></div>
<div class="autotoc"><ul>
<li>
<span class="label">2.1. </span><a class="xref" href="#sec-installation-dependencies" title="Dependencies">Dependencies</a>
</li>
<li>
<span class="label">2.2. </span><a class="xref" href="#sec-install-unix-and-linux" title="Unix and Linux">Unix and Linux</a>
</li>
<li>
<span class="label">2.3. </span><a class="xref" href="#sec-packages-windows" title="Microsoft Windows">Microsoft Windows</a>
</li>
</ul></div>
<div class="division sect1">
<a name="sec-installation-dependencies"><!--sec-installation-dependencies--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">2.1. </span>Dependencies</span></h3></div>
<p class="para block block-first">
  Before attempting to install <span class="application">gtkmm</span><span class="application">-4.0</span>,
  you might first need to install these other packages.
</p>
<div class="block list itemizedlist"><ul class="itemizedlist">
<li class="li-first"><span class="para"><span class="application">sigc++-3.0</span></span></li>
<li><span class="para"><span class="application">gtk4</span></span></li>
<li><span class="para"><span class="application">glibmm-2.68</span></span></li>
<li><span class="para"><span class="application">cairomm-1.16</span></span></li>
<li><span class="para"><span class="application">pangomm-2.48</span></span></li>
</ul></div>
<p class="para block">
These dependencies have their own dependencies, including the following
applications and libraries:
</p>
<div class="block list itemizedlist"><ul class="itemizedlist">
<li class="li-first"><span class="para"><span class="application">pkg-config</span></span></li>
<li><span class="para"><span class="application">glib-2.0</span></span></li>
<li><span class="para"><span class="application">pango</span></span></li>
<li><span class="para"><span class="application">cairo</span></span></li>
<li><span class="para"><span class="application">gdk-pixbuf-2.0</span></span></li>
<li><span class="para"><span class="application">graphene-1.0</span></span></li>
</ul></div>
</div>
<div class="division sect1">
<a name="sec-install-unix-and-linux"><!--sec-install-unix-and-linux--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">2.2. </span>Unix and Linux</span></h3></div>
<div class="autotoc"><ul>
<li>
<span class="label">2.2.1. </span><a class="xref" href="#sec-linux-install-from-packages" title="Prebuilt Packages">Prebuilt Packages</a>
</li>
<li>
<span class="label">2.2.2. </span><a class="xref" href="#sec-install-from-source" title="Installing From Source">Installing From Source</a>
</li>
</ul></div>
<div class="division sect2">
<a name="sec-linux-install-from-packages"><!--sec-linux-install-from-packages--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">2.2.1. </span>Prebuilt Packages</span></h4></div>
<p class="para block block-first">
    Recent versions of <span class="application">gtkmm</span> are packaged by nearly every major Linux
    distribution these days. So, if you use Linux, you can probably get
    started with <span class="application">gtkmm</span> by installing the package from the official repository
    for your distribution. Distributions that include <span class="application">gtkmm</span> in their
    repositories include Debian, Ubuntu, Red Hat, Fedora, Mandriva, Suse, and
    many others.
</p>
<p class="para block">
    The names of the <span class="application">gtkmm</span> packages vary from distribution to distribution
    (e.g. <span class="application">libgtkmm-4.0-dev</span> on Debian and Ubuntu or
    <span class="application">gtkmm40-devel</span> on Red Hat Fedora), so check with
    your distribution's package management program for the correct package name
    and install it like you would any other package.
</p>
<div class="admonition block note block-indent"><div class="note-inner">
<p class="para block block-first">
The package names will not change when new API/ABI-compatible versions of <span class="application">gtkmm</span>
are released. Otherwise they would not be API/ABI-compatible. So don't be
surprised, for instance, to find <span class="application">gtkmm</span> 4.8 supplied by Debian's
<span class="application">libgtkmm-4.0-dev</span> package.
</p>
</div></div>
</div>
<div class="division sect2">
<a name="sec-install-from-source"><!--sec-install-from-source--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">2.2.2. </span>Installing From Source</span></h4></div>
<p class="para block block-first">
If your distribution does not provide a pre-built <span class="application">gtkmm</span> package, or if you
want to install a different version than the one provided by your distribution,
you can also install <span class="application">gtkmm</span> from source. The source code for <span class="application">gtkmm</span> can
be downloaded from <a class="ulink" href="https://download.gnome.org/sources/gtkmm/" title="https://download.gnome.org/sources/gtkmm/">https://download.gnome.org/sources/gtkmm/</a>.
</p>
<p class="para block">
  After you've installed all of the dependencies, download the <span class="application">gtkmm</span> source
  code, unpack it, and change to the newly created directory. <span class="application">gtkmm</span> can be
  built with Meson. See the <span class="filename" dir="ltr">README</span> file in the <span class="application">gtkmm</span> version
  you've downloaded.
</p>
<div class="admonition block note block-indent"><div class="note-inner">
<p class="para block block-first">
  Remember that on a Unix or Linux operating system, you will probably need to
  be <span class="literal" dir="ltr">root</span> to install software. The <span class="command" dir="ltr">su</span> or <span class="command" dir="ltr">sudo</span>
  command will allow you to enter the <span class="literal" dir="ltr">root</span> password and have
  <span class="literal" dir="ltr">root</span> status temporarily.
</p>
</div></div>
<p class="para block">
    The <span class="filename" dir="ltr">configure</span> script or <span class="command" dir="ltr">meson</span> will check
    to make sure all of the required dependencies are already installed. If you are
    missing any dependencies, it will exit and display an error.
</p>
<p class="para block">
    By default, <span class="application">gtkmm</span> if built with Autotools, will be installed under the
    <span class="filename" dir="ltr">/usr/local</span> directory. On some systems you may need to
    install to a different location. For instance, on Red Hat Linux systems
    you might use the <span class="literal" dir="ltr">--prefix</span> option with configure, like
    so:
<div dir="ltr" class=" block screen block-indent"><pre class="screen"># ./configure --prefix=/usr
</pre></div>
</p>
<div class="admonition block warning block-indent"><div class="warning-inner">
    <p class="para block block-first">
        You should be very careful when installing to standard system prefixes
        such as <span class="filename" dir="ltr">/usr</span>. Linux distributions install software
        packages to <span class="filename" dir="ltr">/usr</span>, so installing a source package
        to this prefix could corrupt or conflict with software installed using
        your distribution's package-management system. Ideally, you should use
        a separate prefix for all software you install from source.
    </p>
</div></div>
<p class="para block">
  If you want to help develop <span class="application">gtkmm</span> or experiment with new features, you can
  also install <span class="application">gtkmm</span> from git. Most users will never need to do this, but if
  you're interested in helping with <span class="application">gtkmm</span> development, see the <a class="link" href="#chapter-working-with-source" title="Working with gtkmm's Source Code">Working with gtkmm's Source Code</a> appendix.
</p>
</div>
</div>
<div class="division sect1">
<a name="sec-packages-windows"><!--sec-packages-windows--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">2.3. </span>Microsoft Windows</span></h3></div>
<p class="para block block-first">GTK and <span class="application">gtkmm</span> were designed to work well with Microsoft Windows, and the
developers encourage its use on the win32 platform. However, Windows has no standard
installation system for development libraries. Please see the
<a class="ulink" href="https://wiki.gnome.org/Projects/gtkmm/MSWindows" title="https://wiki.gnome.org/Projects/gtkmm/MSWindows">Windows Installation</a>
page or the <a class="link" href="#sec-windows-installation" title="gtkmm and Win32"><span class="application">gtkmm</span> and Win32</a> appendix
for Windows-specific installation instructions and notes.</p>
</div>
</div>
<div class="division chapter">
<a name="chapter-basics"><!--chapter-basics--></a><div class="header"><h2 class="chapter title"><span class="title"><span class="label">3. </span>Basics</span></h2></div>
<p class="para block block-first">
This chapter will introduce some of the most important aspects of <span class="application">gtkmm</span> coding. These will be demonstrated with simple working example code. However, this is just a taster, so you need to look at the other chapters for more substantial information.
</p>
<p class="para block">
Your existing knowledge of C++ will help you with <span class="application">gtkmm</span> as it would with any library. Unless we state otherwise, you can expect <span class="application">gtkmm</span> classes to behave like any other C++ class, and you can expect to use your existing C++ techniques with <span class="application">gtkmm</span> classes.
</p>
<div class="autotoc"><ul>
<li>
<span class="label">3.1. </span><a class="xref" href="#sec-basics-simple-example" title="Simple Example">Simple Example</a>
</li>
<li>
<span class="label">3.2. </span><a class="xref" href="#sec-headers-and-linking" title="Headers and Linking">Headers and Linking</a>
</li>
<li>
<span class="label">3.3. </span><a class="xref" href="#sec-widgets-overview" title="Widgets">Widgets</a>
</li>
<li>
<span class="label">3.4. </span><a class="xref" href="#sec-signals-overview" title="Signals">Signals</a>
</li>
<li>
<span class="label">3.5. </span><a class="xref" href="#sec-basics-ustring" title="Glib::ustring">Glib::ustring</a>
</li>
<li>
<span class="label">3.6. </span><a class="xref" href="#sec-basics-gobj-and-wrap" title="Mixing C and C++ APIs">Mixing C and C++ APIs</a>
</li>
<li>
<span class="label">3.7. </span><a class="xref" href="#sec-helloworld" title="Hello World in gtkmm">Hello World in <span class="application">gtkmm</span></a>
</li>
</ul></div>
<div class="division sect1">
<a name="sec-basics-simple-example"><!--sec-basics-simple-example--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">3.1. </span>Simple Example</span></h3></div>
<p class="para block block-first">
To begin our introduction to <span class="application">gtkmm</span>, we'll start with the simplest
program possible. This program will create an empty 200 x 200 pixel window.
</p>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/base" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/base">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">base.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include &lt;gtkmm.h&gt;

class MyWindow : public Gtk::Window
{
public:
  MyWindow();
};

MyWindow::MyWindow()
{
  set_title("Basic application");
  set_default_size(200, 200);
}

int main(int argc, char* argv[])
{
  auto app = Gtk::Application::create("org.gtkmm.examples.base");

  return app-&gt;make_window_and_run&lt;MyWindow&gt;(argc, argv);
}
</pre></div>
<p class="para block">We will now explain each line of the example</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include &lt;gtkmm.h&gt;</pre></div>
<p class="para block">
All <span class="application">gtkmm</span> programs must include certain <span class="application">gtkmm</span> headers; <span class="literal" dir="ltr">gtkmm.h</span>
includes the entire <span class="application">gtkmm</span> kit. This is usually not a good idea, because
it includes a megabyte or so of headers, but for simple programs, it
suffices.
</p>
<p class="para block">
The next statement:

<div dir="ltr" class=" block programlisting block-indent block-first"><pre class="programlisting">auto app = Gtk::Application::create("org.gtkmm.examples.base");</pre></div>

creates a <span class="classname" dir="ltr">Gtk::Application</span> object, stored in a <span class="classname" dir="ltr">Glib::RefPtr</span> smartpointer. This is needed in all <span class="application">gtkmm</span>
applications. The <span class="methodname" dir="ltr">create()</span> method for this object initializes <span class="application">gtkmm</span>.
</p>
<p class="para block">
The next two lines of code create a window and set its default (initial) size:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">Gtk::Window window;
window.set_default_size(200, 200);</pre></div>
<p class="para block">
The last line shows the window and enters the <span class="application">gtkmm</span> main processing loop, which will finish when the window is closed.
Your <span class="function">main()</span> function will then return with an appropriate success or error code.
The <span class="parameter" dir="ltr">argc</span> and <span class="parameter" dir="ltr">argv</span> arguments, passed to your application on the command line,
can be checked when <span class="methodname" dir="ltr">run()</span> is called, but this simple application does not use those arguments.
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">return app-&gt;run(window, argc, argv);</pre></div>
<p class="para block">
After putting the source code in <span class="literal" dir="ltr">simple.cc</span> you can compile
the above program with <span class="application">gcc</span> using:
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">g++ simple.cc -o simple `pkg-config gtkmm-4.0 --cflags --libs`</pre></div>
Note that you must surround the <span class="literal" dir="ltr">pkg-config</span> invocation with backquotes.
Backquotes cause the shell to execute the command inside them, and to use
the command's output as part of the command line.
Note also that <span class="literal" dir="ltr">simple.cc</span> must come before the <span class="literal" dir="ltr">pkg-config</span>
invocation on the command line.
</p>
</div>
<div class="division sect1">
<a name="sec-headers-and-linking"><!--sec-headers-and-linking--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">3.2. </span>Headers and Linking</span></h3></div>
<p class="para block block-first">
Although we have shown the compilation command for the simple example, you really should use the automake and autoconf tools, as described in "Autoconf, Automake, Libtool", by G. V. Vaughan et al. The examples used in this book are included in the <span class="application">gtkmm-documentation</span> package, with appropriate build files, so we won't show the build commands in future. You'll just need to find the appropriate directory and type <span class="literal" dir="ltr">make</span>.
</p>
<p class="para block">
To simplify compilation, we use <span class="literal" dir="ltr">pkg-config</span>, which
is present in all (properly installed) <span class="application">gtkmm</span> installations. This
program 'knows' what compiler switches are needed to compile programs
that use <span class="application">gtkmm</span>. The <span class="literal" dir="ltr">--cflags</span> option causes
<span class="literal" dir="ltr">pkg-config</span> to output a list of include directories for the
compiler to look in; the <span class="literal" dir="ltr">--libs</span> option requests the
list of libraries for the compiler to link with and the directories to
find them in. Try running it from your shell-prompt to see the results on your system.
</p>
<p class="para block">
However, this is even simpler when using the <span class="function">PKG_CHECK_MODULES()</span> macro in a standard configure.ac file with autoconf and automake.
For instance:
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">PKG_CHECK_MODULES([MYAPP], [gtkmm-4.0 &gt;= 4.8.0])</pre></div>
This checks for the presence of gtkmm and defines MYAPP_LIBS and MYAPP_CFLAGS for use in your Makefile.am files.
</p>
<p class="para block">gtkmm-4.0 is the name of the current stable API. There are older APIs called gtkmm-2.4
and gtkmm-3.0 which install in parallel when they are available. There are several
versions of gtkmm-2.4, such as gtkmm 2.10 and there are several versions of the gtkmm-3.0 API.
Note that the API name does not change for every version because that would be an incompatible
API and ABI break. There might be a future gtkmm-5.0 API which would install in parallel
with gtkmm-4.0 without affecting existing applications.
</p>
<p class="para block">Note that if you mention extra modules in addition to gtkmm-4.0, they should be separated by spaces, not commas.
</p>
<p class="para block">The GNU site has more information about <a class="ulink" href="https://www.gnu.org/software/autoconf/" title="https://www.gnu.org/software/autoconf/">autoconf</a>
and <a class="ulink" href="https://www.gnu.org/software/automake/" title="https://www.gnu.org/software/automake/">automake</a>.
</p>
<p class="para block">If you start by experimenting with a small application that you plan to use just for yourself,
it's easier to start with a Makefile similar to the <span class="filename" dir="ltr">Makefile.example</span> files
in the <a class="link" href="#chapter-building-applications" title="Building applications">Building applications</a> chapter.
</p>
</div>
<div class="division sect1">
<a name="sec-widgets-overview"><!--sec-widgets-overview--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">3.3. </span>Widgets</span></h3></div>
<p class="para block block-first"><span class="application">gtkmm</span> applications consist of windows containing widgets, such as buttons and text boxes. In some other systems, widgets are called "controls". For each widget in your application's windows, there is a C++ object in your application's code. So you just need to call a method of the widget's class to affect the visible widget.</p>
<p class="para block">Widgets are arranged inside container widgets such as frames and notebooks, in a hierarchy of widgets within widgets. Some of these container widgets, such as <span class="classname" dir="ltr">Gtk::Grid</span>, are not visible - they exist only to arrange other widgets. Here is some example code that adds 2 <span class="classname" dir="ltr">Gtk::Button</span> widgets to a <span class="classname" dir="ltr">Gtk::Box</span> container widget:
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">m_box.append(m_Button1);
m_box.append(m_Button2);</pre></div>
and here is how to add the <span class="classname" dir="ltr">Gtk::Box</span>, containing those buttons, to a <span class="classname" dir="ltr">Gtk::Frame</span>, which has a visible frame and title:
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">m_frame.set_child(m_box);</pre></div>
</p>
<p class="para block">
Most of the chapters in this book deal with specific widgets. See the <a class="link" href="#chapter-container-widgets" title="Container Widgets">Container Widgets</a> section for more details about adding widgets to container widgets.
</p>
<p class="para block">Although you can specify the layout and appearance of windows and widgets with C++ code, you will probably find it more convenient to design your user interfaces with <span class="literal" dir="ltr">Glade</span> and load them at runtime with <span class="literal" dir="ltr">Gtk::Builder</span>. See the <a class="link" href="#chapter-builder" title="Glade and Gtk::Builder">Glade and Gtk::Builder</a> chapter.
</p>
<p class="para block">Although <span class="application">gtkmm</span> widget instances have lifetimes and scopes just like
those of other C++ classes, <span class="application">gtkmm</span> has an optional time-saving feature that you
will see in some of the examples. The <span class="function">Gtk::make_managed()</span>
allows you to create a new widget and state that it will become owned by the
container into which you place it. This allows you to create the widget, add it
to the container and not be concerned about deleting it, since that will occur
when the parent container (which may itself be managed) is deleted. You can
learn more about <span class="application">gtkmm</span> memory management techniques in the
<a class="link" href="#chapter-memory" title="Memory management">Memory Management chapter</a>.
</p>
</div>
<div class="division sect1">
<a name="sec-signals-overview"><!--sec-signals-overview--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">3.4. </span>Signals</span></h3></div>
<p class="para block block-first">
<span class="application">gtkmm</span>, like most GUI toolkits, is <span class="emphasis">event-driven</span>. When an event occurs, such as the press of a mouse
button, the appropriate signal will be <span class="emphasis">emitted</span> by the Widget
that was pressed. Each Widget has a different set of signals that it can emit. To make a
button click result in an action, we set up a
<span class="emphasis">signal handler</span> to catch the button's "clicked" signal.
</p>
<p class="para block"><span class="application">gtkmm</span> uses the libsigc++ library to implement signals. Here is an example line of code that connects a Gtk::Button's "clicked" signal with a signal handler called "on_button_clicked":
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">m_button1.signal_clicked().connect( sigc::mem_fun(*this,
  &amp;HelloWorld::on_button_clicked) );</pre></div>
<p class="para block">For more detailed information about signals, see the <a class="link" href="#chapter-signals" title="Signals">appendix</a>.</p>
<p class="para block">For information about implementing your own signals rather than
just connecting to the existing <span class="application">gtkmm</span> signals, see the <a class="link" href="#chapter-custom-signals" title="Creating your own signals">appendix</a>.</p>
</div>
<div class="division sect1">
<a name="sec-basics-ustring"><!--sec-basics-ustring--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">3.5. </span>Glib::ustring</span></h3></div>
<p class="para block block-first">You might be surprised to learn that <span class="application">gtkmm</span> doesn't use <span class="classname" dir="ltr">std::string</span> in its interfaces. Instead it uses <span class="classname" dir="ltr">Glib::ustring</span>, which is so similar and unobtrusive that you could actually pretend that each <span class="classname" dir="ltr">Glib::ustring</span> is a <span class="classname" dir="ltr">std::string</span> and ignore the rest of this section. But read on if you want to use languages other than English in your application.</p>
<p class="para block">std::string uses 8 bits per character, but 8 bits aren't enough to encode languages such as Arabic, Chinese, and Japanese.
Although the encodings for these languages have been specified by the <a class="ulink" href="http://www.unicode.org/" title="http://www.unicode.org/">Unicode Consortium</a>,
the C and C++ languages do not yet provide any standardised Unicode support for UTF-8 encoding.
GTK and GNOME chose to implement Unicode using UTF-8, and that's what is wrapped by Glib::ustring.
It provides almost exactly the same interface as std::string, along with automatic conversions to and from std::string.</p>
<p class="para block">One of the benefits of UTF-8 is that you don't need to use it unless you want to, so you don't need to retrofit all of your code at once. <span class="classname" dir="ltr">std::string</span> will still work for 7-bit ASCII strings. But when you try to localize your application for languages like Chinese, for instance, you will start to see strange errors, and possible crashes. Then all you need to do is start using <span class="classname" dir="ltr">Glib::ustring</span> instead.</p>
<p class="para block">Note that UTF-8 isn't compatible with 8-bit encodings like ISO-8859-1. For instance, German umlauts are not in the ASCII range and need more than 1 byte in the UTF-8 encoding. If your code contains 8-bit string literals, you have to convert them to UTF-8 (e.g. the Bavarian greeting "Grüß Gott" would be "Gr\xC3\xBC\xC3\x9F Gott").</p>
<p class="para block">You should avoid C-style pointer arithmetic, and functions such as strlen(). In UTF-8, each character might need anywhere from 1 to 6 bytes, so it's not possible to assume that the next byte is another character. <span class="classname" dir="ltr">Glib::ustring</span> worries about the details of this for you so you can use methods such as Glib::ustring::substr() while still thinking in terms of characters instead of bytes.</p>
<p class="para block">Unlike the Windows UCS-2 Unicode solution, this does not require any special compiler options to process string literals, and it does not result in Unicode executables and libraries which are incompatible with ASCII ones.</p>
<p class="para block"><a class="ulink" href="http://developer.gnome.org/glibmm/unstable/classGlib_1_1ustring.html" title="http://developer.gnome.org/glibmm/unstable/classGlib_1_1ustring.html">Reference</a></p>
<p class="para block">See the <a class="link" href="#chapter-internationalization" title="Internationalization and Localization">Internationalization</a> section for information about providing the UTF-8 string literals.</p>
</div>
<div class="division sect1">
<a name="sec-basics-gobj-and-wrap"><!--sec-basics-gobj-and-wrap--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">3.6. </span>Mixing C and C++ APIs</span></h3></div>
<p class="para block block-first">You can use C APIs which do not yet have convenient C++ interfaces.
It is generally not a problem to use C APIs from C++, and <span class="application">gtkmm</span> helps by
providing access to the underlying C object, and providing an easy way to create
a C++ wrapper object from a C object, provided that the C API is also based on
the <span class="classname" dir="ltr">GObject</span> system.</p>
<p class="para block">
To use a <span class="application">gtkmm</span> instance with a C function that requires a C
<span class="classname" dir="ltr">GObject</span> instance, use the C++ instance’s
<span class="function">gobj()</span> function to obtain a pointer to the underlying C
instance. For example:</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">Gtk::Button button("example");
gtk_button_do_something_that_gtkmm_cannot(button.gobj());
</pre></div>
<p class="para block">
To obtain a <span class="application">gtkmm</span> instance from a C <span class="classname" dir="ltr">GObject</span> instance,
use one of the many overloaded <span class="function">Glib::wrap()</span> functions.
The C instance’s reference count is not incremented, unless you set the optional
<span class="parameter" dir="ltr">take_copy</span> argument to <span class="literal" dir="ltr">true</span>. For
example:
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">GtkButton* cbutton = get_a_button();
Gtk::Button* button = Glib::wrap(cbutton);
button-&gt;set_label("Now I speak C++ too!");
</pre></div>
The C++ wrapper shall be explicitly deleted if
<div class="block list itemizedlist"><ul class="itemizedlist">
<li class="li-first"><span class="para">it's a widget or other class that inherits from <span class="classname" dir="ltr">Gtk::Object</span>, and</span></li>
<li><span class="para">the C instance has a floating reference when the wrapper is created, and</span></li>
<li><span class="para"><span class="function">Gtk::manage()</span> has not been called on it (which includes if it was created with <span class="function">Gtk::make_managed()</span>), or</span></li>
<li><span class="para"><span class="function">Gtk::manage()</span> was called on it, but it was never added to, or was later removed from, its parent.</span></li>
</ul></div>
<span class="function">Glib::wrap()</span> binds the C and C++ instances to each other.
Don't delete the C++ instance before you want the C instance to die.
</p>
<p class="para block">In all other cases the C++ instance is automatically deleted when the last reference
to the C instance is dropped. This includes all <span class="function">Glib::wrap()</span>
overloads that return a <span class="classname" dir="ltr">Glib::RefPtr</span>.</p>
</div>
<div class="division sect1">
<a name="sec-helloworld"><!--sec-helloworld--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">3.7. </span>Hello World in <span class="application">gtkmm</span></span></h3></div>
<p class="para block block-first">
We've now learned enough to look at a real example. In accordance with an ancient
tradition of computer science, we now introduce Hello World, a la <span class="application">gtkmm</span>:
</p>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/helloworld" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/helloworld">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">helloworld.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLE_HELLOWORLD_H
#define GTKMM_EXAMPLE_HELLOWORLD_H

#include &lt;gtkmm/button.h&gt;
#include &lt;gtkmm/window.h&gt;

class HelloWorld : public Gtk::Window
{

public:
  HelloWorld();
  ~HelloWorld() override;

protected:
  //Signal handlers:
  void on_button_clicked();

  //Member widgets:
  Gtk::Button m_button;
};

#endif // GTKMM_EXAMPLE_HELLOWORLD_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "helloworld.h"
#include &lt;gtkmm/application.h&gt;

int main(int argc, char* argv[])
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  //Shows the window and returns when it is closed.
  return app-&gt;make_window_and_run&lt;HelloWorld&gt;(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">helloworld.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "helloworld.h"
#include &lt;iostream&gt;

HelloWorld::HelloWorld()
: m_button("Hello World")   // creates a new button with label "Hello World".
{
  // Sets the margin around the button.
  m_button.set_margin(10);

  // When the button receives the "clicked" signal, it will call the
  // on_button_clicked() method defined below.
  m_button.signal_clicked().connect(sigc::mem_fun(*this,
              &amp;HelloWorld::on_button_clicked));

  // This packs the button into the Window (a container).
  set_child(m_button);
}

HelloWorld::~HelloWorld()
{
}

void HelloWorld::on_button_clicked()
{
  std::cout &lt;&lt; "Hello World" &lt;&lt; std::endl;
}
</pre></div>
<p class="para block">
Try to compile and run it before going on. You should see something like this:
</p>
<div class=" block figure block-indent">
<a name="figure-helloworld"><!--figure-helloworld--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 3-1</span> </span>Hello World</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/helloworld.png.en"></div>
  </div>
</div>
</div>
<p class="para block">
Pretty thrilling, eh?  Let's examine the code. First, the
<span class="classname" dir="ltr">HelloWorld</span> class:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">class HelloWorld : public Gtk::Window
{
public:
  HelloWorld();
  ~HelloWorld() override;

protected:
  //Signal handlers:
  void on_button_clicked();

  //Member widgets:
  Gtk::Button m_button;
};</pre></div>
<p class="para block">
This class implements the "Hello World" window. It's derived from
<span class="classname" dir="ltr">Gtk::Window</span>, and has a single <span class="classname" dir="ltr">Gtk::Button</span> as a member.
We've chosen to use the
constructor to do all of the initialisation work for the window,
including setting up the signals. Here it is, with the comments
omitted:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">HelloWorld::HelloWorld()
: m_button("Hello World")
{
  m_button.set_margin(10);
  m_button.signal_clicked().connect(sigc::mem_fun(*this,
    &amp;HelloWorld::on_button_clicked));
  set_child(m_button);
}</pre></div>
<p class="para block">
Notice that we've used an initialiser statement to give the <span class="literal" dir="ltr">m_button</span>
object the label "Hello World".
</p>
<p class="para block">
Next we call the Button's <span class="methodname" dir="ltr">set_margin()</span> method. This sets
the amount of space around the button.
</p>
<p class="para block">
We then hook up a signal handler to <span class="literal" dir="ltr">m_button</span>'s <span class="literal" dir="ltr">clicked</span> signal.
This prints our friendly greeting to <span class="literal" dir="ltr">stdout</span>.
</p>
<p class="para block">
Next, we use the Window's <span class="methodname" dir="ltr">set_child()</span> method to put
<span class="literal" dir="ltr">m_button</span> in the Window. The <span class="methodname" dir="ltr">set_child()</span>
method places the Widget in the Window.
</p>
<p class="para block">
Now let's look at our program's <span class="function">main()</span> function. Here it is,
without comments:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">int main(int argc, char* argv[])
{
  auto app = Gtk::Application::create("org.gtkmm.example");
  HelloWorld helloworld;
  return app-&gt;run(helloworld, argc, argv);
}</pre></div>
<p class="para block">
First we instantiate an object stored in a <span class="classname" dir="ltr">RefPtr</span> smartpointer called <span class="literal" dir="ltr">app</span>. This is of type
<span class="classname" dir="ltr">Gtk::Application</span>. Every <span class="application">gtkmm</span> program must have one of these.
</p>
<p class="para block">
Next we make an object of our <span class="classname" dir="ltr">HelloWorld</span> class, whose constructor
takes no arguments, but it isn't visible yet. When we call <span class="methodname" dir="ltr">Gtk::Application::run()</span>,
giving it the helloworld Window and the command-line arguments, it shows the Window and starts the <span class="application">gtkmm</span> <span class="emphasis">event loop</span>.
During the event loop <span class="application">gtkmm</span> idles, waiting for actions from the user, and responding appropriately.
When the user closes the Window, <span class="methodname" dir="ltr">run()</span> will return,
causing the final line of our <span class="function">main()</span> function be to executed. The application will then finish.
</p>
<p class="para block">
Like the simple example we showed earlier, this Hello World program does not use
the command-line parameters. It's not necessary to pass them to <span class="methodname" dir="ltr">run()</span>.
</p>
</div>
</div>
<div class="division chapter">
<a name="changes-gtkmm3"><!--changes-gtkmm3--></a><div class="header"><h2 class="chapter title"><span class="title"><span class="label">4. </span>Changes in <span class="application">gtkmm</span> 3</span></h2></div>
<p class="para block block-first"><span class="application">gtkmm</span>-3.0 is an old version of the <span class="application">gtkmm</span> API that installs in parallel with the still older <span class="application">gtkmm</span>-2.4 API and the new <span class="application">gtkmm</span>-4.0 API. The last version of the <span class="application">gtkmm</span>-2.4 API was <span class="application">gtkmm</span> 2.24. <span class="application">gtkmm</span> 3 has no major fundamental differences to <span class="application">gtkmm</span> 2 but does make several small changes that were not possible while maintaining binary compatibility. If you never used the <span class="application">gtkmm</span>-2.4 API then you can safely ignore this chapter.</p>
<p class="para block"><span class="application">gtkmm</span> 3's library is called <span class="literal" dir="ltr">libgtkmm-3.0</span> rather than <span class="literal" dir="ltr">libgtkmm-2.4</span> and installs its headers in a similarly-versioned directory, so your pkg-config check should ask for <span class="literal" dir="ltr">gtkmm-3.0</span>  rather than <span class="literal" dir="ltr">gtkmm-2.4</span>.</p>
<p class="para block"><span class="application">gtkmm</span> 3 added some new classes:</p>
<div class="block list orderedlist"><ol class="orderedlist">
<li class="li-first"><p class="simpara block block-first"><span class="classname" dir="ltr">Gtk::AppChooser</span>, <span class="classname" dir="ltr">Gtk::AppChooserButton</span>, <span class="classname" dir="ltr">Gtk::AppChooserDialog</span> allow the user to select an installed application to open a particular type of content.</p></li>
<li><p class="simpara block block-first"><span class="classname" dir="ltr">Gtk::Grid</span> is a new container widget that will eventually replace <span class="classname" dir="ltr">Gtk::Box</span> and <span class="classname" dir="ltr">Gtk::Table</span>. It arranges its children according to properties of those children rather than its own layout details.</p></li>
<li><p class="simpara block block-first"><span class="classname" dir="ltr">Gtk::Switch</span> displays On/Off states more explictly than <span class="classname" dir="ltr">Gtk::CheckButton</span>. It may be useful, for instance, when allowing users to activate hardware.</p></li>
</ol></div>
<p class="para block"><span class="application">gtkmm</span> 3 also made several small changes to the API, which you will probably encounter when porting code that used <span class="application">gtkmm</span>-2.4. Here is a short list:</p>
<p class="para block">
<div class="block list orderedlist"><ol class="orderedlist">
<li class="li-first"><p class="simpara block block-first"><span class="classname" dir="ltr">Gtk::CellLayout</span>, used by <span class="classname" dir="ltr">Gtk::IconView</span>, <span class="classname" dir="ltr">Gtk::TreeView::Column</span> and <span class="classname" dir="ltr">Gtk::ComboBox</span>, now has a <span class="classname" dir="ltr">Gtk::CellArea</span> which can be used to specify more details of how the <span class="classname" dir="ltr">CellRenderer</span>s are arranged and aligned.</p></li>
<li><p class="simpara block block-first">Gtk::ComboBox now derives from CellLayout, allowing easier layout and alignment of its <span class="classname" dir="ltr">Gtk::CellRenderer</span>s.</p></li>
<li><p class="simpara block block-first"><span class="classname" dir="ltr">Gtk::Adjustment</span> and <span class="classname" dir="ltr">IconSet</span> and <span class="classname" dir="ltr">Gdk::Cursor</span> are now used via <span class="classname" dir="ltr">Glib::RefPtr</span>.</p></li>
<li><p class="simpara block block-first"><span class="classname" dir="ltr">Gtk::Box</span>, <span class="classname" dir="ltr">Gtk::ButtonBox</span>, <span class="classname" dir="ltr">Gtk::IconView</span>, <span class="classname" dir="ltr">Gtk::Paned</span>, <span class="classname" dir="ltr">Gtk::ProgressBar</span>, <span class="classname" dir="ltr">Gtk::ScaleButton</span>, <span class="classname" dir="ltr">Gtk::Scrollbar</span> and <span class="classname" dir="ltr">Gtk::Separator</span> now derive from <span class="classname" dir="ltr">Gtk::Orientable</span>, allowing their
orientation (vertical or horizontal) to be specified without requiring the use of a derived class such as <span class="classname" dir="ltr">Gtk::HBox</span>.</p></li>
<li><p class="simpara block block-first"><span class="classname" dir="ltr">Gtk::IconView</span>, <span class="classname" dir="ltr">Gtk::TextView</span>, <span class="classname" dir="ltr">Gtk::TreeView</span> and other widgets derive from Scrollable instead of having their own methods such as <span class="methodname" dir="ltr">get_vadjustment()</span> and instead of having their own set_scroll_adjustments signal.</p></li>
<li><p class="simpara block block-first"><span class="classname" dir="ltr">Gtk::Style</span> and <span class="classname" dir="ltr">Gtk::Rc</span> were removed, replaced by <span class="classname" dir="ltr">Gtk::StyleContext</span>, and <span class="classname" dir="ltr">Gtk::StyleProvider</span>s, such as <span class="classname" dir="ltr">Gtk::CssProvider</span>.</p></li>
<li><p class="simpara block block-first">Widget::on_expose_event() was replaced by Widget::on_draw(), which assumes that cairomm is used for drawing, via the provided <span class="classname" dir="ltr">Cairo::Context</span> and does not require you to call <span class="methodname" dir="ltr">Cairo::Context::clip()</span>.</p></li>
<li><p class="simpara block block-first"><span class="classname" dir="ltr">Gdk::RGBA</span> replaces <span class="classname" dir="ltr">Color</span>, adding an alpha component for opacity. <span class="classname" dir="ltr">Colormap</span> was removed, along with its awkward use to allocate colors.</p></li>
<li><p class="simpara block block-first"><span class="classname" dir="ltr">Gdk::Pixmap</span> and <span class="classname" dir="ltr">Gdk::Bitmap</span> were removed in favour of <span class="classname" dir="ltr">Gdk::Pixbuf</span>.</p></li>
<li><p class="simpara block block-first"><span class="classname" dir="ltr">Gdk::Drawable</span> was removed, with its methods moving into <span class="classname" dir="ltr">Gdk::Window</span>.</p></li>
<li><p class="simpara block block-first">We now use std::vector in several methods instead of the intermediate *Handle types to make the API clearer.</p></li>
</ol></div>
</p>
<p class="para block">All deprecated API was removed in <span class="application">gtkmm</span> 3.0, though there have been new deprecations in later <span class="application">gtkmm</span> 3.x versions.</p>
<p class="para block">As a first step to porting your source code to <span class="application">gtkmm</span>-3.0 you should probably ensure that your application builds with the deprecated <span class="application">gtkmm</span>-2.4 API disabled, by defining macro such as GTKMM_DISABLE_DEPRECATED. There are some autotools macros that can help with this by defining them optionally at build time. See the <a class="ulink" href="https://wiki.gnome.org/Projects/gtkmm/PortingToGtkmm3" title="https://wiki.gnome.org/Projects/gtkmm/PortingToGtkmm3">gtkmm 3 porting wiki page</a> for more details.</p>
</div>
<div class="division chapter">
<a name="changes-gtkmm4"><!--changes-gtkmm4--></a><div class="header"><h2 class="chapter title"><span class="title"><span class="label">5. </span>Changes in <span class="application">gtkmm</span>-4.0 and <span class="application">glibmm-2.68</span></span></h2></div>
<p class="para block block-first"><span class="application">gtkmm</span>-4.0 is a new version of the <span class="application">gtkmm</span> API that installs in parallel with the
older <span class="application">gtkmm</span>-2.4 and <span class="application">gtkmm</span>-3.0 APIs. The last version of the <span class="application">gtkmm</span>-3.0 API
is <span class="application">gtkmm</span> 3.24. <span class="application">gtkmm</span> 4 has no major fundamental differences to <span class="application">gtkmm</span> 3 but
does make several changes (both small and large ones) that were not possible while
maintaining binary compatibility. If you never used the <span class="application">gtkmm</span>-3.0 API then you
can safely ignore this chapter.
</p>
<p class="para block"><span class="application">gtkmm</span> 4's library is called <span class="literal" dir="ltr">libgtkmm-4.0</span> rather than
<span class="literal" dir="ltr">libgtkmm-3.0</span> and installs its headers in a similarly-versioned
directory, so your <span class="application">pkg-config</span> check should ask for
<span class="literal" dir="ltr">gtkmm-4.0</span> rather than <span class="literal" dir="ltr">gtkmm-3.0</span>.
</p>
<p class="para block"><span class="application">gtkmm</span>-4.0 is used in combination with <span class="application">glibmm-2.68</span>,
which sets the global locale for your program. The older <span class="application">glibmm-2.4</span>
does not do that, and <span class="application">gtkmm</span>-3.0 does it only to some extent. What this means is
briefly that if your <span class="application">gtkmm</span>-3.0 program contains a call to
<span class="function">std::locale::global(std::locale(""))</span>, you can probably remove it.
If you don't want <span class="application">glibmm</span> or <span class="application">gtkmm</span>
to set the global locale for you, you should add a call to
<span class="function">Glib::set_init_to_users_preferred_locale(false)</span> before any call to
<span class="function">Glib::init()</span> or <span class="methodname" dir="ltr">Gtk::Application::create()</span>.
</p>
<p class="para block"><a class="ulink" href="http://developer.gnome.org/glibmm/unstable/namespaceGlib.html" title="http://developer.gnome.org/glibmm/unstable/namespaceGlib.html">Reference</a></p>
<p class="para block">There are lots and lots of differences between <span class="application">gtkmm</span>-3.0 and <span class="application">gtkmm</span>-4.0.
The following lists are not complete.</p>
<p class="para block">Some new classes were added in <span class="application">gtkmm</span> 4 and <span class="application">glibmm</span> 2.68:</p>
<div class="block list orderedlist"><ol class="orderedlist">
<li class="li-first"><p class="simpara block block-first"><span class="classname" dir="ltr">Glib::ExtraClassInit</span> and <span class="classname" dir="ltr">Gtk::Snapshot</span>:
  These classes are needed only for writing custom widgets. See the
  <a class="link" href="#sec-custom-widgets" title="Custom Widgets">Custom Widgets</a> section.</p></li>
<li><p class="simpara block block-first"><span class="classname" dir="ltr">Gtk::EventControllerKey</span>,
  <span class="classname" dir="ltr">Gtk::EventControllerMotion</span>, <span class="classname" dir="ltr">Gtk::EventControllerScroll</span>
  and <span class="classname" dir="ltr">Gtk::GestureStylus</span></p></li>
<li><p class="simpara block block-first"><span class="classname" dir="ltr">Gdk::Paintable</span>, <span class="classname" dir="ltr">Gdk::Texture</span>,
  <span class="classname" dir="ltr">Gtk::Picture</span> and <span class="classname" dir="ltr">Gtk::WidgetPaintable</span>
  </p></li>
<li><p class="simpara block block-first"><span class="classname" dir="ltr">Gdk::Window</span> has been renamed to <span class="classname" dir="ltr">Gdk::Surface</span>.
  (<span class="classname" dir="ltr">Gtk::Window</span> keeps its name.)</p></li>
<li><p class="simpara block block-first"><span class="classname" dir="ltr">Gdk::DrawContext</span> and <span class="classname" dir="ltr">Gdk::CairoContext</span>
  are new. <span class="classname" dir="ltr">Gdk::DrawingContext</span> has been removed.</p></li>
<li><p class="simpara block block-first"><span class="classname" dir="ltr">Gtk::Clipboard</span> has been replaced by the new
  <span class="classname" dir="ltr">Gdk::Clipboard</span>.</p></li>
<li><p class="simpara block block-first"><span class="classname" dir="ltr">Gdk::DragContext</span> has been split into
  <span class="classname" dir="ltr">Gdk::Drag</span> and <span class="classname" dir="ltr">Gdk::Drop</span>.</p></li>
</ol></div>
<p class="para block">There have also been several changes to the API, which you will probably encounter
when porting code that used <span class="application">gtkmm</span>-3.0 and <span class="application">glibmm</span>-2.4. Here is a short list:</p>
<p class="para block">
<div class="block list orderedlist"><ol class="orderedlist">
<li class="li-first"><p class="simpara block block-first">A C++17 compiler is required.</p></li>
<li><p class="simpara block block-first"><span class="classname" dir="ltr">Gtk::Button</span>, <span class="classname" dir="ltr">Gtk::ToolButton</span>,
  <span class="classname" dir="ltr">Gtk::MenuItem</span> and <span class="classname" dir="ltr">Gtk::Switch</span>
  implement the <span class="classname" dir="ltr">Gtk::Actionable</span> interface instead of the removed
  <span class="classname" dir="ltr">Gtk::Activatable</span> interface.</p></li>
<li><p class="simpara block block-first"><span class="classname" dir="ltr">Gtk::FontButton</span> implements the <span class="classname" dir="ltr">Gtk::FontChooser</span> interface.</p></li>
<li><p class="simpara block block-first"><span class="classname" dir="ltr">Gtk::Widget</span>: The <span class="methodname" dir="ltr">get_preferred_*_vfunc()</span>s
  have been replaced by <span class="methodname" dir="ltr">measure_vfunc()</span>. This change only affects
  custom widgets.</p></li>
<li><p class="simpara block block-first"><span class="classname" dir="ltr">sigc::slot</span>s use the <span class="classname" dir="ltr">sigc::slot&lt;R(Args...)&gt;</span> syntax.
  Example: <span class="classname" dir="ltr">sigc::slot&lt;void(int, int)&gt;</span> instead of <span class="classname" dir="ltr">sigc::slot&lt;void, int, int&gt;</span>.</p></li>
<li><p class="simpara block block-first"><span class="classname" dir="ltr">Gtk::DrawingArea</span> uses a draw function instead of the draw signal.</p></li>
<li><p class="simpara block block-first"><span class="classname" dir="ltr">Glib::ArrayHandle</span>, <span class="classname" dir="ltr">Glib::StringArrayHandle</span>,
  <span class="classname" dir="ltr">Glib::ListHandle</span> and <span class="classname" dir="ltr">Glib::SListHandle</span> have been removed.
  They were used in <span class="application">glibmm</span>-2.4, but not used in <span class="application">gtkmm</span>-3.0.
  If you've ever used these classes, replace them with a standard C++ container, such as <span class="classname" dir="ltr">std::vector</span>.</p></li>
<li><p class="simpara block block-first"><span class="classname" dir="ltr">Gtk::Container</span> has been removed.</p></li>
<li><p class="simpara block block-first"><span class="methodname" dir="ltr">Gtk::Widget::show_all()</span> has been removed. The default value
  of <span class="methodname" dir="ltr">Gtk::Widget::property_visible()</span>has been changed from
  <span class="literal" dir="ltr">false</span> to <span class="literal" dir="ltr">true</span>.</p></li>
<li><p class="simpara block block-first">All event signals have been removed from <span class="classname" dir="ltr">Gtk::Widget</span>.
  In most cases you can use one of the subclasses of <span class="classname" dir="ltr">Gtk::EventController</span>
  as a replacement. For instance, use <span class="classname" dir="ltr">Gtk::GestureMultiPress</span>
  instead of <span class="methodname" dir="ltr">signal_button_press_event()</span> and
  <span class="methodname" dir="ltr">signal_button_release_event()</span>, and <span class="classname" dir="ltr">Gtk::EventControllerKey</span>
  instead of <span class="methodname" dir="ltr">signal_key_press_event()</span> and
  <span class="methodname" dir="ltr">signal_key_release_event()</span>.</p></li>
<li><p class="simpara block block-first"><span class="classname" dir="ltr">Glib::RefPtr</span> is an alias for <span class="classname" dir="ltr">std::shared_ptr</span>.
  If you make your own <span class="classname" dir="ltr">Glib::ObjectBase</span>-derived classes with
  <span class="methodname" dir="ltr">create()</span> methods that return a <span class="classname" dir="ltr">Glib::RefPtr</span>,
  you must use <span class="methodname" dir="ltr">Glib::make_refptr_for_instance()</span> in your
  <span class="methodname" dir="ltr">create()</span> methods.</p></li>
<li><p class="simpara block block-first"><span class="methodname" dir="ltr">Gtk::Box::pack_start()</span> and <span class="methodname" dir="ltr">Gtk::Box::pack_end()</span>
  have been removed. Use the new <span class="classname" dir="ltr">Gtk::Box</span> methods
  <span class="methodname" dir="ltr">append()</span>, <span class="methodname" dir="ltr">prepend()</span>,
  <span class="methodname" dir="ltr">insert_child_after()</span> and <span class="methodname" dir="ltr">insert_child_at_start()</span>.
  </p></li>
<li><p class="simpara block block-first"><span class="classname" dir="ltr">Gtk::ButtonBox</span> has been removed.</p></li>
<li><p class="simpara block block-first"><span class="classname" dir="ltr">Gtk::RadioButton</span> and <span class="classname" dir="ltr">Gtk::RadioButtonGroup</span>
  have been removed. Use <span class="classname" dir="ltr">Gtk::CheckButton</span> or <span class="classname" dir="ltr">Gtk::ToggleButton</span>
  with <span class="methodname" dir="ltr">set_group()</span>.</p></li>
</ol></div>
</p>
<p class="para block">All deprecated API was removed in <span class="application">gtkmm</span> 4.0 and <span class="application">glibmm</span> 2.68,
  though there will be new deprecations in future versions.</p>
<p class="para block">As a first step to porting your source code to <span class="application">gtkmm</span>-4.0 you should probably ensure
that your application builds with the deprecated <span class="application">gtkmm</span>-3.0 and <span class="application">glibmm-2.4</span>
API disabled, by defining the macros GTKMM_DISABLE_DEPRECATED, GDKMM_DISABLE_DEPRECATED,
GLIBMM_DISABLE_DEPRECATED and GIOMM_DISABLE_DEPRECATED. There are some autotools macros
that can help with this by defining them optionally at build time. See the
<a class="ulink" href="https://wiki.gnome.org/Projects/gtkmm/PortingToGtkmm3" title="https://wiki.gnome.org/Projects/gtkmm/PortingToGtkmm3">Porting from
gtkmm-2.4 to gtkmm-3.0</a> wiki page for more details.</p>
<p class="para block">See also <a class="ulink" href="https://developer.gnome.org/gtk4/unstable/gtk-migrating-3-to-4.html" title="https://developer.gnome.org/gtk4/unstable/gtk-migrating-3-to-4.html">
Migrating from GTK 3.x to GTK 4</a>.</p>
</div>
<div class="division chapter">
<a name="chapter-button-widget"><!--chapter-button-widget--></a><div class="header"><h2 class="chapter title"><span class="title"><span class="label">6. </span>Buttons</span></h2></div>
<p class="para block block-first">
<span class="application">gtkmm</span> provides four basic types of buttons:
</p>
<div class="block list variablelist"><dl class="variablelist">
<dt class="term dt-first">Push buttons</dt>
<dd>
<p class="para block block-first">
<a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Button.html" title="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Button.html"><span class="classname" dir="ltr">Gtk::Button</span></a>. Standard buttons, usually
marked with a label or picture. Pushing one triggers an action. See the <a class="link" href="#sec-pushbuttons" title="Button">Button</a> section.
</p>
</dd>
<dt class="term">Toggle buttons</dt>
<dd>
<p class="para block block-first">
<a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1ToggleButton.html" title="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1ToggleButton.html"><span class="classname" dir="ltr">Gtk::ToggleButton</span></a>.
Unlike a normal Button, which springs back up, a ToggleButton stays down until you
press it again. It might be useful as an on/off switch. See the <a class="link" href="#sec-toggle-buttons" title="ToggleButton">ToggleButton</a> section.
</p>
</dd>
<dt class="term">Check buttons</dt>
<dd>
<p class="para block block-first">
<a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1CheckButton.html" title="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1CheckButton.html"><span class="classname" dir="ltr">Gtk::CheckButton</span></a>.
These act like ToggleButtons, but show their state in small squares,
with their label at the side. They should be used in most situations
which require an on/off setting.
See the <a class="link" href="#sec-checkbuttons" title="CheckButton">CheckButton</a> section.
</p>
</dd>
<dt class="term">Radio buttons</dt>
<dd>
<p class="para block block-first">
Named after the station selectors on old car
radios, these buttons are used in groups for options which are
mutually exclusive. Pressing one causes all the
others in its group to turn off. They are similar to ToggleButtons or
CheckButtons (a small widget with a label at the side), but usually
look different. There is no separate radio button class. Check buttons
and toggle buttons can act as radio buttons.
See the <a class="link" href="#sec-radio-buttons" title="Radio Button">Radio Button</a> section.
</p>
</dd>
</dl></div>
<p class="para block">
Note that, due to GTK's theming system, the appearance of these
widgets will vary. In the case of check buttons and radio buttons, they
may vary considerably.
</p>
<div class="autotoc"><ul>
<li>
<span class="label">6.1. </span><a class="xref" href="#sec-pushbuttons" title="Button">Button</a>
</li>
<li>
<span class="label">6.2. </span><a class="xref" href="#sec-toggle-buttons" title="ToggleButton">ToggleButton</a>
</li>
<li>
<span class="label">6.3. </span><a class="xref" href="#sec-checkbuttons" title="CheckButton">CheckButton</a>
</li>
<li>
<span class="label">6.4. </span><a class="xref" href="#sec-radio-buttons" title="Radio Button">Radio Button</a>
</li>
</ul></div>
<div class="division sect1">
<a name="sec-pushbuttons"><!--sec-pushbuttons--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">6.1. </span>Button</span></h3></div>
<p class="para block block-first">
There are two ways to create a Button. You can specify a label
string in the <span class="classname" dir="ltr">Gtk::Button</span> constructor,
or set it later with <span class="methodname" dir="ltr">set_label()</span>.
</p>
<p class="para block">To define an accelerator key for keyboard navigation, place an underscore before one of the label's characters and specify <span class="literal" dir="ltr">true</span> for the optional <span class="literal" dir="ltr">mnemonic</span> parameter. For instance:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">Gtk::Button* pButton = new Gtk::Button("_Something", true);</pre></div>
<p class="para block">
<span class="classname" dir="ltr">Gtk::Button</span> is also
a container so you could put any other widget, such as a
<span class="classname" dir="ltr">Gtk::Image</span> into it.
</p>
<p class="para block">
The <span class="classname" dir="ltr">Gtk::Button</span> widget has the <span class="literal" dir="ltr">clicked</span> signal
which is emitted when the button is pressed and released.
</p>
<p class="para block"><a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Button.html" title="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Button.html">Reference</a></p>
<div class="autotoc"><ul><li>
<span class="label">6.1.1. </span><a class="xref" href="#pushbutton-example" title="Example">Example</a>
</li></ul></div>
<div class="division sect2">
<a name="pushbutton-example"><!--pushbutton-example--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">6.1.1. </span>Example</span></h4></div>
<p class="para block block-first">
This example creates a button with a picture and a label.
</p>
<div class=" block figure block-indent">
<a name="figure-buttons"><!--figure-buttons--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 6-1</span> </span>buttons example</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/buttons.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/buttons/button" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/buttons/button">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">buttons.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLE_BUTTONS_H
#define GTKMM_EXAMPLE_BUTTONS_H

#include &lt;gtkmm/window.h&gt;
#include &lt;gtkmm/button.h&gt;

class Buttons : public Gtk::Window
{
public:
  Buttons();
  virtual ~Buttons();

protected:
  //Signal handlers:
  void on_button_clicked();

  //Child widgets:
  Gtk::Button m_button;
};

#endif //GTKMM_EXAMPLE_BUTTONS_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "buttons.h"
#include &lt;gtkmm/application.h&gt;

int main(int argc, char *argv[])
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  //Shows the window and returns when it is closed.
  return app-&gt;make_window_and_run&lt;Buttons&gt;(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">buttons.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "buttons.h"
#include &lt;gtkmm/box.h&gt;
#include &lt;gtkmm/image.h&gt;
#include &lt;gtkmm/label.h&gt;
#include &lt;iostream&gt;

Buttons::Buttons()
{
  // This corresponds to Gtk::Bin::add_pixlabel("info.xpm", "cool button") in gtkmm3.
  //Create Image and Label widgets:
  auto pmap = Gtk::make_managed&lt;Gtk::Image&gt;("info.xpm");
  auto label = Gtk::make_managed&lt;Gtk::Label&gt;("cool button");
  label-&gt;set_expand(true);

  //Put them in a Box:
  auto hbox = Gtk::make_managed&lt;Gtk::Box&gt;(Gtk::Orientation::HORIZONTAL, 5);
  hbox-&gt;append(*pmap);
  hbox-&gt;append(*label);

  //And put that Box in the button:
  m_button.set_child(*hbox);

  set_title("Pixmap'd buttons!");

  m_button.signal_clicked().connect( sigc::mem_fun(*this,
              &amp;Buttons::on_button_clicked) );

  m_button.set_margin(10);
  set_child(m_button);
}

Buttons::~Buttons()
{
}

void Buttons::on_button_clicked()
{
  std::cout &lt;&lt; "The Button was clicked." &lt;&lt; std::endl;
}
</pre></div>
</div>
</div>
<div class="division sect1">
<a name="sec-toggle-buttons"><!--sec-toggle-buttons--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">6.2. </span>ToggleButton</span></h3></div>
<p class="para block block-first"><span class="classname" dir="ltr">ToggleButton</span>s are like normal <span class="classname" dir="ltr">Button</span>s, but when clicked they remain activated, or pressed,  until clicked again.</p>
<p class="para block">
To retrieve the state of the <span class="classname" dir="ltr">ToggleButton</span>, you can use the
<span class="methodname" dir="ltr">get_active()</span> method. This returns <span class="literal" dir="ltr">true</span> if the button
is "down". You can also set the toggle button's state, with <span class="methodname" dir="ltr">set_active()</span>. Note that, if you do this, and the state actually changes, it causes the
"clicked" signal to be emitted. This is usually what you want.
</p>
<p class="para block">
You can use the <span class="methodname" dir="ltr">toggled()</span> method to toggle the button, rather than
forcing it to be up or down: This switches the button's state, and causes the <span class="literal" dir="ltr">toggled</span> signal to be emitted.
</p>
<p class="para block"><a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1ToggleButton.html" title="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1ToggleButton.html">Reference</a></p>
</div>
<div class="division sect1">
<a name="sec-checkbuttons"><!--sec-checkbuttons--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">6.3. </span>CheckButton</span></h3></div>
<p class="para block block-first">
<span class="classname" dir="ltr">Gtk::CheckButton</span> inherits directly from
<span class="classname" dir="ltr">Gtk::Widget</span>. It is similar to <span class="classname" dir="ltr">Gtk::ToggleButton</span>.
The only real difference between the two is <span class="classname" dir="ltr">Gtk::CheckButton</span>'s
appearance. You can check and set a check button using the same
member methods as for <span class="classname" dir="ltr">Gtk::ToggleButton</span>.
</p>
<p class="para block"><a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1CheckButton.html" title="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1CheckButton.html">Reference</a></p>
<div class="autotoc"><ul><li>
<span class="label">6.3.1. </span><a class="xref" href="#checkbutton-example" title="Example">Example</a>
</li></ul></div>
<div class="division sect2">
<a name="checkbutton-example"><!--checkbutton-example--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">6.3.1. </span>Example</span></h4></div>
<div class=" block figure block-first block-indent">
<a name="figure-checkbutton"><!--figure-checkbutton--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 6-2</span> </span>CheckButton</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/checkbutton.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/buttons/checkbutton" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/buttons/checkbutton">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLE_BUTTONS_H
#define GTKMM_EXAMPLE_BUTTONS_H

#include &lt;gtkmm/window.h&gt;
#include &lt;gtkmm/checkbutton.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_button_toggled();

  //Child widgets:
  Gtk::CheckButton m_button;
};

#endif //GTKMM_EXAMPLE_BUTTONS_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;gtkmm/application.h&gt;

int main(int argc, char *argv[])
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  //Shows the window and returns when it is closed.
  return app-&gt;make_window_and_run&lt;ExampleWindow&gt;(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;iostream&gt;

ExampleWindow::ExampleWindow()
: m_button("something")
{
  set_title("checkbutton example");

  m_button.signal_toggled().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_toggled) );

  m_button.set_margin(10);
  set_child(m_button);
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_button_toggled()
{
  std::cout &lt;&lt; "The Button was toggled: state="
      &lt;&lt; (m_button.get_active() ? "true" : "false")
      &lt;&lt; std::endl;
}
</pre></div>
</div>
</div>
<div class="division sect1">
<a name="sec-radio-buttons"><!--sec-radio-buttons--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">6.4. </span>Radio Button</span></h3></div>
<p class="para block block-first">
There is no separate class for radio buttons. Check buttons and toggle buttons
act as radio buttons when they form a group. Only one button in a group can be
selected at any one time.
</p>
<div class="autotoc"><ul>
<li>
<span class="label">6.4.1. </span><a class="xref" href="#radiobutton-groups" title="Groups">Groups</a>
</li>
<li>
<span class="label">6.4.2. </span><a class="xref" href="#radiobutton-methods" title="Methods">Methods</a>
</li>
<li>
<span class="label">6.4.3. </span><a class="xref" href="#radiobutton-example" title="Example">Example</a>
</li>
</ul></div>
<div class="division sect2">
<a name="radiobutton-groups"><!--radiobutton-groups--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">6.4.1. </span>Groups</span></h4></div>
<p class="para block block-first">
You create the buttons, and set up their group afterwards. In the following example,
we put 3 radio buttons in a group:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">auto rb1 = Gtk::make_managed&lt;Gtk::CheckButton&gt;("button1");
auto rb2 = Gtk::make_managed&lt;Gtk::CheckButton&gt;("button2");
auto rb3 = Gtk::make_managed&lt;Gtk::CheckButton&gt;("button3");
rb2-&gt;set_group(*rb1);
rb3-&gt;set_group(*rb1);
</pre></div>
<p class="para block">
We told <span class="application">gtkmm</span> to put all three <span class="classname" dir="ltr">CheckButton</span>s in the
same group by using <span class="methodname" dir="ltr">set_group()</span> to tell the other
<span class="classname" dir="ltr">CheckButton</span>s to share group with the first
<span class="classname" dir="ltr">CheckButton</span>.
</p>
</div>
<div class="division sect2">
<a name="radiobutton-methods"><!--radiobutton-methods--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">6.4.2. </span>Methods</span></h4></div>
<p class="para block block-first">
<span class="classname" dir="ltr">CheckButton</span>s and <span class="classname" dir="ltr">ToggleButton</span>s are "off"
when created; this means that when you first make a group of them, they will all be off.
Don't forget to turn one of them on using <span class="methodname" dir="ltr">set_active()</span>.
</p>
<p class="para block"><a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1RadioButton.html" title="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1RadioButton.html">Reference</a></p>
</div>
<div class="division sect2">
<a name="radiobutton-example"><!--radiobutton-example--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">6.4.3. </span>Example</span></h4></div>
<p class="para block block-first">
The following example demonstrates the use of grouped
<span class="classname" dir="ltr">CheckButton</span>s:
</p>
<div class=" block figure block-indent">
<a name="figure-radiobutton"><!--figure-radiobutton--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 6-3</span> </span>RadioButton</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/radiobuttons.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/buttons/radiobutton" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/buttons/radiobutton">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">radiobuttons.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLE_RADIOBUTTONS_H
#define GTKMM_EXAMPLE_RADIOBUTTONS_H

#include &lt;gtkmm/box.h&gt;
#include &lt;gtkmm/window.h&gt;
#include &lt;gtkmm/button.h&gt;
#include &lt;gtkmm/checkbutton.h&gt;
#include &lt;gtkmm/separator.h&gt;

class RadioButtons : public Gtk::Window
{
public:
  RadioButtons();
  virtual ~RadioButtons();

protected:
  //Signal handlers:
  void on_button_clicked();

  //Child widgets:
  Gtk::Box m_Box_Top, m_Box1, m_Box2;
  Gtk::CheckButton m_RadioButton1, m_RadioButton2, m_RadioButton3;
  Gtk::Separator m_Separator;
  Gtk::Button m_Button_Close;
};

#endif //GTKMM_EXAMPLE_RADIOBUTTONS_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "radiobuttons.h"
#include &lt;gtkmm/application.h&gt;

int main(int argc, char *argv[])
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  //Shows the window and returns when it is closed.
  return app-&gt;make_window_and_run&lt;RadioButtons&gt;(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">radiobuttons.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "radiobuttons.h"

RadioButtons::RadioButtons() :
  m_Box_Top(Gtk::Orientation::VERTICAL),
  m_Box1(Gtk::Orientation::VERTICAL, 10),
  m_Box2(Gtk::Orientation::VERTICAL, 10),
  m_RadioButton1("button1"),
  m_RadioButton2("button2"),
  m_RadioButton3("button3"),
  m_Button_Close("close")
{
  // Set title and border of the window
  set_title("radio buttons");

  // Gtk::CheckButton and Gtk::ToggleButton have set_group() methods.
  // They act as radio buttons, if they are included in a group.

  // Put radio buttons 2 and 3 in the same group as 1:
  m_RadioButton2.set_group(m_RadioButton1);
  m_RadioButton3.set_group(m_RadioButton1);

  // Add outer box to the window (because the window
  // can only contain a single widget)
  set_child(m_Box_Top);

  //Put the inner boxes and the separator in the outer box:
  m_Box_Top.append(m_Box1);
  m_Box_Top.append(m_Separator);
  m_Box_Top.append(m_Box2);
  m_Separator.set_expand();

  // Set the inner boxes' margins
  m_Box1.set_margin(10);
  m_Box2.set_margin(10);

  // Put the radio buttons in Box1:
  m_Box1.append(m_RadioButton1);
  m_Box1.append(m_RadioButton2);
  m_Box1.append(m_RadioButton3);
  m_RadioButton1.set_expand();
  m_RadioButton2.set_expand();
  m_RadioButton3.set_expand();

  // Set the second button active
  m_RadioButton2.set_active(true);

  // Put Close button in Box2:
  m_Box2.append(m_Button_Close);
  m_Button_Close.set_expand();

  // Make the button the default widget
  set_default_widget(m_Button_Close);

  // Connect the toggled signal of the button to
  // RadioButtons::on_button_toggled()
  m_Button_Close.signal_clicked().connect(sigc::mem_fun(*this,
              &amp;RadioButtons::on_button_clicked) );
}

RadioButtons::~RadioButtons()
{
}

void RadioButtons::on_button_clicked()
{
  hide(); //to close the application.
}
</pre></div>
</div>
</div>
</div>
<div class="division chapter">
<a name="chapter-range-widgets"><!--chapter-range-widgets--></a><div class="header"><h2 class="chapter title"><span class="title"><span class="label">7. </span>Range Widgets</span></h2></div>
<p class="para block block-first">
<span class="classname" dir="ltr">Gtk::Scale</span> and <span class="classname" dir="ltr">Gtk::Scrollbar</span>
both inherit from <span class="classname" dir="ltr">Gtk::Range</span> and share much
functionality. They contain a "trough" and a "slider" (sometimes called a
"thumbwheel" in other GUI environments). Dragging the slider with the pointer
moves it within the trough, while clicking in the trough advances the slider
towards the location of the click, either completely, or by a designated
amount, depending on which mouse button is used. This should be familiar
scrollbar behaviour.
</p>
<p class="para block">
As will be explained in the <a class="link" href="#chapter-adjustment" title="Adjustments">Adjustments</a>
section, all Range widgets are associated with an
<span class="classname" dir="ltr">Adjustment</span> object. To change the lower, upper, and
current values used by the widget you need to use the methods of its
<span class="classname" dir="ltr">Adjustment</span>, which you can get with the
<span class="methodname" dir="ltr">get_adjustment()</span> method. The <span class="classname" dir="ltr">Range</span>
widgets' default constructors create an <span class="classname" dir="ltr">Adjustment</span>
automatically, or you can specify an existing
<span class="classname" dir="ltr">Adjustment</span>, maybe to share it with another widget. See
the <a class="link" href="#chapter-adjustment" title="Adjustments">Adjustments</a> section for further
details.
</p>
<p class="para block"><a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Range.html" title="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Range.html">Reference</a></p>
<div class="autotoc"><ul>
<li>
<span class="label">7.1. </span><a class="xref" href="#sec-scrollbar-widgets" title="Scrollbar Widgets">Scrollbar Widgets</a>
</li>
<li>
<span class="label">7.2. </span><a class="xref" href="#sec-scale-widgets" title="Scale Widgets">Scale Widgets</a>
</li>
<li>
<span class="label">7.3. </span><a class="xref" href="#sec-range-example" title="Example">Example</a>
</li>
</ul></div>
<div class="division sect1">
<a name="sec-scrollbar-widgets"><!--sec-scrollbar-widgets--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">7.1. </span>Scrollbar Widgets</span></h3></div>
<p class="para block block-first">
These are standard scrollbars. They should be used only to scroll another
widget, such as a <span class="classname" dir="ltr">Gtk::Entry</span> or a
<span class="classname" dir="ltr">Gtk::Viewport</span>, though it's usually easier to use the
<span class="classname" dir="ltr">Gtk::ScrolledWindow</span> widget in most cases.
</p>
<p class="para block">
The orientation of a <span class="classname" dir="ltr">Gtk::Scrollbar</span> can be either
horizontal or vertical.
</p>
<p class="para block"><a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Scrollbar.html" title="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Scrollbar.html">Reference</a></p>
</div>
<div class="division sect1">
<a name="sec-scale-widgets"><!--sec-scale-widgets--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">7.2. </span>Scale Widgets</span></h3></div>
<p class="para block block-first">
<span class="classname" dir="ltr">Gtk::Scale</span> widgets (or "sliders") allow the user to
visually select and manipulate a value within a specific range. You
might use one, for instance, to adjust the
magnification level on a zoomed preview of a picture, or to control
the brightness of a colour, or to specify the number of minutes of
inactivity before a screensaver takes over the screen.
</p>
<p class="para block">
As with <span class="classname" dir="ltr">Scrollbar</span>s, the orientation can be either
horizontal or vertical. The default constructor creates an
<span class="classname" dir="ltr">Adjustment</span> with all of its values set to
<span class="literal" dir="ltr">0.0</span>. This isn't useful so you will need to set some
<span class="classname" dir="ltr">Adjustment</span> details to get meaningful behaviour.
</p>
<div class="autotoc"><ul><li>
<span class="label">7.2.1. </span><a class="xref" href="#scale-useful-methods" title="Useful methods">Useful methods</a>
</li></ul></div>
<div class="division sect2">
<a name="scale-useful-methods"><!--scale-useful-methods--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">7.2.1. </span>Useful methods</span></h4></div>
<p class="para block block-first">
<span class="classname" dir="ltr">Scale</span> widgets can display their current value as a number
next to the trough. By default they show the value, but you can change this
with the <span class="methodname" dir="ltr">set_draw_value()</span> method.
</p>
<p class="para block">
The value displayed by a scale widget is rounded to one decimal point
by default, as is the <span class="literal" dir="ltr">value</span> field in its
<span class="classname" dir="ltr">Gtk::Adjustment</span>. You can change this with the
<span class="methodname" dir="ltr">set_digits()</span> method.
</p>
<p class="para block">
Also, the value can be drawn in different positions relative to the trough,
specified by the <span class="methodname" dir="ltr">set_value_pos()</span> method.
</p>
<p class="para block"><a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Scale.html" title="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Scale.html">Reference</a></p>
</div>
</div>
<div class="division sect1">
<a name="sec-range-example"><!--sec-range-example--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">7.3. </span>Example</span></h3></div>
<p class="para block block-first">
This example displays a window with three range widgets all connected
to the same adjustment, along with a couple of controls for adjusting
some of the parameters mentioned above and in the section on
adjustments, so you can see how they affect the way these widgets work
for the user.
</p>
<div class=" block figure block-indent">
<a name="figure-range-widgets"><!--figure-range-widgets--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 7-1</span> </span>Range Widgets</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/range_widgets.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/range_widgets" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/range_widgets">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLE_RANGEWIDGETS_H
#define GTKMM_EXAMPLE_RANGEWIDGETS_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_checkbutton_toggled();
  void on_combo_position();
  void on_adjustment1_value_changed();
  void on_adjustment2_value_changed();
  void on_button_quit();

  //Child widgets:
  Gtk::Box m_VBox_Top, m_VBox2, m_VBox_HScale;
  Gtk::Box m_HBox_Scales, m_HBox_Combo, m_HBox_Digits, m_HBox_PageSize;

  Glib::RefPtr&lt;Gtk::Adjustment&gt; m_adjustment, m_adjustment_digits, m_adjustment_pagesize;

  Gtk::Scale m_VScale;
  Gtk::Scale m_HScale, m_Scale_Digits, m_Scale_PageSize;

  Gtk::Separator m_Separator;

  Gtk::CheckButton m_CheckButton;

  Gtk::Scrollbar m_Scrollbar;

  //Tree model columns:
  class ModelColumns : public Gtk::TreeModel::ColumnRecord
  {
  public:

    ModelColumns()
    { add(m_col_position_type); add(m_col_title); }

    Gtk::TreeModelColumn&lt;Gtk::PositionType&gt; m_col_position_type;
    Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_col_title;
  };

  ModelColumns m_Columns;

  //Child widgets:
  Gtk::ComboBox m_ComboBox_Position;
  Glib::RefPtr&lt;Gtk::ListStore&gt; m_refTreeModel;

  Gtk::Button m_Button_Quit;
};

#endif //GTKMM_EXAMPLE_RANGEWIDGETS_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;gtkmm/application.h&gt;

int main(int argc, char *argv[])
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  //Shows the window and returns when it is closed.
  return app-&gt;make_window_and_run&lt;ExampleWindow&gt;(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;iostream&gt;

ExampleWindow::ExampleWindow()
:
  m_VBox_Top(Gtk::Orientation::VERTICAL, 0),
  m_VBox2(Gtk::Orientation::VERTICAL, 20),
  m_VBox_HScale(Gtk::Orientation::VERTICAL, 10),
  m_HBox_Scales(Gtk::Orientation::HORIZONTAL, 10),
  m_HBox_Combo(Gtk::Orientation::HORIZONTAL, 10),
  m_HBox_Digits(Gtk::Orientation::HORIZONTAL, 10),
  m_HBox_PageSize(Gtk::Orientation::HORIZONTAL, 10),

  // Value, lower, upper, step_increment, page_increment, page_size:
  // Note that the page_size value only makes a difference for
  // scrollbar widgets, and the highest value you'll get is actually
  // (upper - page_size).
  m_adjustment( Gtk::Adjustment::create(0.0, 0.0, 101.0, 0.1, 1.0, 1.0) ),
  m_adjustment_digits( Gtk::Adjustment::create(1.0, 0.0, 5.0, 1.0, 2.0) ),
  m_adjustment_pagesize( Gtk::Adjustment::create(1.0, 1.0, 101.0) ),

  m_VScale(m_adjustment, Gtk::Orientation::VERTICAL),
  m_HScale(m_adjustment, Gtk::Orientation::HORIZONTAL),
  m_Scale_Digits(m_adjustment_digits),
  m_Scale_PageSize(m_adjustment_pagesize),

  // A checkbutton to control whether the value is displayed or not:
  m_CheckButton("Display value on scale widgets", 0),

  // Reuse the same adjustment again.
  // Notice how this causes the scales to always be updated
  // continuously when the scrollbar is moved.
  m_Scrollbar(m_adjustment),

  m_Button_Quit("Quit")
{
  set_title("range controls");
  set_default_size(300, 350);

  //VScale:
  m_VScale.set_digits(1);
  m_VScale.set_value_pos(Gtk::PositionType::TOP);
  m_VScale.set_draw_value();
  m_VScale.set_inverted(); // highest value at top

  //HScale:
  m_HScale.set_digits(1);
  m_HScale.set_value_pos(Gtk::PositionType::TOP);
  m_HScale.set_draw_value();

  set_child(m_VBox_Top);
  m_VBox_Top.append(m_VBox2);
  m_VBox2.set_expand(true);
  m_VBox2.set_margin(10);
  m_VBox2.append(m_HBox_Scales);
  m_HBox_Scales.set_expand(true);

  //Put VScale and HScale (above scrollbar) side-by-side.
  m_HBox_Scales.append(m_VScale);
  m_VScale.set_expand(true);
  m_HBox_Scales.append(m_VBox_HScale);
  m_VBox_HScale.set_expand(true);

  m_VBox_HScale.append(m_HScale);
  m_HScale.set_expand(true);

  //Scrollbar:
  m_VBox_HScale.append(m_Scrollbar);
  m_Scrollbar.set_expand(true);

  //CheckButton:
  m_CheckButton.set_active();
  m_CheckButton.signal_toggled().connect( sigc::mem_fun(*this,
    &amp;ExampleWindow::on_checkbutton_toggled) );
  m_VBox2.append(m_CheckButton);

  //Position ComboBox:
  //Create the Tree model:
  m_refTreeModel = Gtk::ListStore::create(m_Columns);
  m_ComboBox_Position.set_model(m_refTreeModel);
  m_ComboBox_Position.pack_start(m_Columns.m_col_title);

  //Fill the ComboBox's Tree Model:
  auto row = *(m_refTreeModel-&gt;append());
  row[m_Columns.m_col_position_type] = Gtk::PositionType::TOP;
  row[m_Columns.m_col_title] = "Top";
  row = *(m_refTreeModel-&gt;append());
  row[m_Columns.m_col_position_type] = Gtk::PositionType::BOTTOM;
  row[m_Columns.m_col_title] = "Bottom";
  row = *(m_refTreeModel-&gt;append());
  row[m_Columns.m_col_position_type] = Gtk::PositionType::LEFT;
  row[m_Columns.m_col_title] = "Left";
  row = *(m_refTreeModel-&gt;append());
  row[m_Columns.m_col_position_type] = Gtk::PositionType::RIGHT;
  row[m_Columns.m_col_title] = "Right";

  m_VBox2.append(m_HBox_Combo);
  m_HBox_Combo.append(*Gtk::make_managed&lt;Gtk::Label&gt;("Scale Value Position:", 0));
  m_HBox_Combo.append(m_ComboBox_Position);
  m_ComboBox_Position.signal_changed().connect( sigc::mem_fun(*this, &amp;ExampleWindow::on_combo_position) );
  m_ComboBox_Position.set_active(0); // Top
  m_ComboBox_Position.set_expand(true);

  //Digits:
  m_HBox_Digits.append(*Gtk::make_managed&lt;Gtk::Label&gt;("Scale Digits:", 0));
  m_Scale_Digits.set_digits(0);
  m_Scale_Digits.set_expand(true);
  m_adjustment_digits-&gt;signal_value_changed().connect(sigc::mem_fun(*this,
    &amp;ExampleWindow::on_adjustment1_value_changed));
  m_HBox_Digits.append(m_Scale_Digits);

  //Page Size:
  m_HBox_PageSize.append(*Gtk::make_managed&lt;Gtk::Label&gt;("Scrollbar Page Size:", 0));
  m_Scale_PageSize.set_digits(0);
  m_Scale_PageSize.set_expand(true);
  m_adjustment_pagesize-&gt;signal_value_changed().connect(sigc::mem_fun(*this,
    &amp;ExampleWindow::on_adjustment2_value_changed));
  m_HBox_PageSize.append(m_Scale_PageSize);

  m_VBox2.append(m_HBox_Digits);
  m_VBox2.append(m_HBox_PageSize);
  m_VBox_Top.append(m_Separator);
  m_VBox_Top.append(m_Button_Quit);

  set_default_widget(m_Button_Quit);
  m_Button_Quit.signal_clicked().connect(sigc::mem_fun(*this,
    &amp;ExampleWindow::on_button_quit));
  m_Button_Quit.set_margin(10);
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_checkbutton_toggled()
{
  m_VScale.set_draw_value(m_CheckButton.get_active());
  m_HScale.set_draw_value(m_CheckButton.get_active());
}

void ExampleWindow::on_combo_position()
{
  const auto iter = m_ComboBox_Position.get_active();
  if(!iter)
    return;

  const auto row = *iter;
  if(!row)
    return;

  const auto postype = row[m_Columns.m_col_position_type];

  m_VScale.set_value_pos(postype);
  m_HScale.set_value_pos(postype);
}

void ExampleWindow::on_adjustment1_value_changed()
{
  const double val = m_adjustment_digits-&gt;get_value();
  m_VScale.set_digits((int)val);
  m_HScale.set_digits((int)val);
}

void ExampleWindow::on_adjustment2_value_changed()
{
  const double val = m_adjustment_pagesize-&gt;get_value();
  m_adjustment-&gt;set_page_size(val);
  m_adjustment-&gt;set_page_increment(val);

  // Note that we don't have to emit the "changed" signal
  // because gtkmm does this for us.
}

void ExampleWindow::on_button_quit()
{
  hide();
}
</pre></div>
</div>
</div>
<div class="division chapter">
<a name="chapter-misc-widgets"><!--chapter-misc-widgets--></a><div class="header"><h2 class="chapter title"><span class="title"><span class="label">8. </span>Miscellaneous Widgets</span></h2></div>
<div class="autotoc"><ul>
<li>
<span class="label">8.1. </span><a class="xref" href="#sec-labels" title="Label">Label</a>
</li>
<li>
<span class="label">8.2. </span><a class="xref" href="#sec-text-entry" title="Entry">Entry</a>
</li>
<li>
<span class="label">8.3. </span><a class="xref" href="#sec-spinbutton" title="SpinButton">SpinButton</a>
</li>
<li>
<span class="label">8.4. </span><a class="xref" href="#sec-progressbar" title="ProgressBar">ProgressBar</a>
</li>
<li>
<span class="label">8.5. </span><a class="xref" href="#sec-infobar" title="InfoBar">InfoBar</a>
</li>
<li>
<span class="label">8.6. </span><a class="xref" href="#sec-tooltips" title="Tooltips">Tooltips</a>
</li>
</ul></div>
<div class="division sect1">
<a name="sec-labels"><!--sec-labels--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">8.1. </span>Label</span></h3></div>
<p class="para block block-first">
Labels are the  main method of placing non-editable text in windows, for
instance to place a title next to an <span class="classname" dir="ltr">Entry</span> widget. You
can specify the text in the constructor, or later with the
<span class="methodname" dir="ltr">set_text()</span> or <span class="methodname" dir="ltr">set_markup()</span> methods.
</p>
<p class="para block">
The width of the label will be adjusted automatically. You can produce multi-line labels by putting line breaks ("\n") in the label string.
</p>
<p class="para block">
The label text can be justified using the <span class="methodname" dir="ltr">set_justify()</span>
method. The widget is also capable of word-wrapping, which can be activated
with <span class="methodname" dir="ltr">set_line_wrap()</span>.
</p>
<p class="para block">
Gtk::Label supports some simple formatting, for instance allowing you to make some
text bold, colored, or larger. You can do this by providing a string to
<span class="methodname" dir="ltr">set_markup()</span>, using the <a class="ulink" href="http://developer.gnome.org/pango/unstable/PangoMarkupFormat.html" title="http://developer.gnome.org/pango/unstable/PangoMarkupFormat.html">Pango Markup syntax</a>. For instance,
<span class="code" dir="ltr">
&lt;b&gt;bold text&lt;/b&gt; and &lt;s&gt;strikethrough text&lt;/s&gt;
</span>
.</p>
<p class="para block"><a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Label.html" title="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Label.html">Reference</a></p>
<div class="autotoc"><ul><li>
<span class="label">8.1.1. </span><a class="xref" href="#label-example" title="Example">Example</a>
</li></ul></div>
<div class="division sect2">
<a name="label-example"><!--label-example--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">8.1.1. </span>Example</span></h4></div>
<p class="para block block-first">
Below is a short example to illustrate these functions. This example
makes use of the Frame widget to better demonstrate the label styles.
 (The Frame widget is explained in the <a class="link" href="#sec-frame" title="Frame">Frame</a> section.)
It is possible that the first character in <span class="literal" dir="ltr">m_Label_Normal</span> is shown
underlined only when you press the <span class="keycap">Alt</span> key.
</p>
<div class=" block figure block-indent">
<a name="figure-label"><!--figure-label--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 8-1</span> </span>Label</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/label.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/label" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/label">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:

  //Child widgets:
  Gtk::Box m_HBox;
  Gtk::Box m_VBox, m_VBox2;
  Gtk::Frame m_Frame_Normal, m_Frame_Multi, m_Frame_Left, m_Frame_Right,
    m_Frame_LineWrapped, m_Frame_FilledWrapped, m_Frame_Underlined;
  Gtk::Label m_Label_Normal, m_Label_Multi, m_Label_Left, m_Label_Right,
    m_Label_LineWrapped, m_Label_FilledWrapped, m_Label_Underlined;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;gtkmm/application.h&gt;

int main(int argc, char *argv[])
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  //Shows the window and returns when it is closed.
  return app-&gt;make_window_and_run&lt;ExampleWindow&gt;(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;iostream&gt;

ExampleWindow::ExampleWindow()
:
  m_HBox(Gtk::Orientation::HORIZONTAL, 5),
  m_VBox(Gtk::Orientation::VERTICAL, 5),
  m_VBox2(Gtk::Orientation::VERTICAL, 5),
  m_Frame_Normal("Normal Label"),
  m_Frame_Multi("Multi-line Label"),
  m_Frame_Left("Left Justified Label"),
  m_Frame_Right("Right Justified Label"),
  m_Frame_LineWrapped("Line wrapped label"),
  m_Frame_FilledWrapped("Filled, wrapped label"),
  m_Frame_Underlined("Underlined label"),
  m_Label_Normal("_This is a Normal label", true),
  m_Label_Multi("This is a Multi-line label.\nSecond line\nThird line"),
  m_Label_Left("This is a Left-Justified\nMulti-line label.\nThird line"),
  m_Label_Right("This is a Right-Justified\nMulti-line label.\nThird line"),
  m_Label_Underlined("&lt;u&gt;This label is underlined!&lt;/u&gt;\n"
          "&lt;u&gt;T&lt;/u&gt;h&lt;u&gt;is one is&lt;/u&gt; &lt;u&gt;u&lt;/u&gt;n&lt;u&gt;derlin&lt;/u&gt;ed "
          "in&lt;u&gt; q&lt;/u&gt;u&lt;u&gt;ite a f&lt;/u&gt;u&lt;u&gt;nky&lt;/u&gt; fashion")
{
  set_title("Label");

  m_HBox.set_margin(5);
  set_child(m_HBox);

  m_HBox.append(m_VBox);

  m_Frame_Normal.set_child(m_Label_Normal);
  m_VBox.append(m_Frame_Normal);

  m_Frame_Multi.set_child(m_Label_Multi);
  m_VBox.append(m_Frame_Multi);

  m_Label_Left.set_justify(Gtk::Justification::LEFT);
  m_Frame_Left.set_child(m_Label_Left);
  m_VBox.append(m_Frame_Left);

  m_Label_Right.set_justify(Gtk::Justification::RIGHT);
  m_Frame_Right.set_child(m_Label_Right);
  m_VBox.append(m_Frame_Right);

  m_HBox.append(m_VBox2);

  m_Label_LineWrapped.set_text(
          "This is an example of a line-wrapped label.  It "
          /* add a big space to the next line to test spacing */
          "should not be taking up the entire             "
          "width allocated to it, but automatically "
          "wraps the words to fit.  "
          "The time has come, for all good men, to come to "
          "the aid of their party.  "
          "The sixth sheik's six sheep's sick.\n"
          "     It supports multiple paragraphs correctly, "
          "and  correctly   adds "
          "many          extra  spaces. ");
  m_Label_LineWrapped.set_wrap();
  m_Frame_LineWrapped.set_child(m_Label_LineWrapped);
  m_VBox2.append(m_Frame_LineWrapped);

  m_Label_FilledWrapped.set_text(
          "This is an example of a line-wrapped, filled label.  "
          "It should be taking "
          "up the entire              width allocated to it.  "
          "Here is a sentence to prove "
          "my point.  Here is another sentence. "
          "Here comes the sun, do de do de do.\n"
          "    This is a new paragraph.\n"
          "    This is another newer, longer, better "
          "paragraph.  It is coming to an end, "
          "unfortunately.");
  m_Label_FilledWrapped.set_justify(Gtk::Justification::FILL);
  m_Label_FilledWrapped.set_wrap();
  m_Frame_FilledWrapped.set_child(m_Label_FilledWrapped);
  m_VBox2.append(m_Frame_FilledWrapped);

  m_Label_Underlined.set_justify(Gtk::Justification::LEFT);
  m_Label_Underlined.set_use_markup(true);
  m_Frame_Underlined.set_child(m_Label_Underlined);
  m_VBox2.append(m_Frame_Underlined);
}

ExampleWindow::~ExampleWindow()
{
}
</pre></div>
</div>
</div>
<div class="division sect1">
<a name="sec-text-entry"><!--sec-text-entry--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">8.2. </span>Entry</span></h3></div>
<div class="autotoc"><ul>
<li>
<span class="label">8.2.1. </span><a class="xref" href="#sec-text-entry-simple" title="Simple Use">Simple Use</a>
</li>
<li>
<span class="label">8.2.2. </span><a class="xref" href="#sec-text-entry-completion" title="Entry Completion">Entry Completion</a>
</li>
<li>
<span class="label">8.2.3. </span><a class="xref" href="#sec-text-entry-icons" title="Entry Icons">Entry Icons</a>
</li>
<li>
<span class="label">8.2.4. </span><a class="xref" href="#sec-text-entry-progress" title="Entry Progress">Entry Progress</a>
</li>
</ul></div>
<div class="division sect2">
<a name="sec-text-entry-simple"><!--sec-text-entry-simple--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">8.2.1. </span>Simple Use</span></h4></div>
<p class="para block block-first">
Entry widgets allow the user to enter text. You can change the contents with the <span class="methodname" dir="ltr">set_text()</span> method,
and read the current contents with the <span class="methodname" dir="ltr">get_text()</span> method.
</p>
<p class="para block">
Occasionally you might want to make an <span class="classname" dir="ltr">Entry</span> widget
read-only. This can be done by passing <span class="literal" dir="ltr">false</span> to the
<span class="methodname" dir="ltr">set_editable()</span> method.
</p>
<p class="para block">
For the input of passwords, passphrases and other information you don't want
echoed on the screen, calling <span class="methodname" dir="ltr">set_visibility()</span> with
<span class="literal" dir="ltr">false</span> will cause the text to be hidden.
</p>
<p class="para block">
You might want to be notified whenever the user types in a text entry widget.
<span class="classname" dir="ltr">Gtk::Entry</span> provides two signals,
<span class="literal" dir="ltr">activate</span> and <span class="literal" dir="ltr">changed</span>, for this purpose.
<span class="literal" dir="ltr">activate</span> is emitted when the user presses the <span class="keycap">Enter</span> key in
a text-entry widget; <span class="literal" dir="ltr">changed</span> is emitted when the text in
the widget changes. You can use these, for instance, to validate or filter
the text the user types. Moving the keyboard focus to another widget may also
signal that the user has finished entering text. The <span class="literal" dir="ltr">focus_out_event</span>
signal that <span class="classname" dir="ltr">Gtk::Entry</span> inherits from
<span class="classname" dir="ltr">Gtk::Widget</span> can notify you when that happens.
The <a class="link" href="#sec-comboboxentry" title="ComboBox with an Entry">ComboBox with an Entry</a> section
contains example programs that use these signals.
</p>
<p class="para block">
If you pass <span class="literal" dir="ltr">true</span> to the <span class="methodname" dir="ltr">set_activates_default()</span>
method, pressing <span class="keycap">Enter</span> in the <span class="classname" dir="ltr">Gtk::Entry</span> will activate
the default widget for the window containing the <span class="classname" dir="ltr">Gtk::Entry</span>.
This is especially useful in dialog boxes. The default widget is usually one of
the dialog buttons, which e.g. will close the dialog box. To set a widget as the
default widget, use <span class="methodname" dir="ltr">Gtk::Widget::set_can_default()</span> and
<span class="methodname" dir="ltr">Gtk::Widget::grab_default()</span>.
</p>
<p class="para block"><a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Entry.html" title="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Entry.html">Reference</a></p>
<div class="autotoc"><ul><li>
<span class="label">8.2.1.1. </span><a class="xref" href="#entry-example" title="Simple Entry Example">Simple Entry Example</a>
</li></ul></div>
<div class="division sect3">
<a name="entry-example"><!--entry-example--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">8.2.1.1. </span>Simple Entry Example</span></h5></div>
<p class="para block block-first">
This example uses <span class="classname" dir="ltr">Gtk::Entry</span>. It also has two
<span class="classname" dir="ltr">CheckButton</span>s, with which you can toggle the editable and
visible flags.
</p>
<div class=" block figure block-indent">
<a name="figure-entry-simple"><!--figure-entry-simple--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 8-2</span> </span>Entry</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/entry.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/entry/simple" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/entry/simple">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_checkbox_editable_toggled();
  void on_checkbox_visibility_toggled();
  void on_button_close();

  //Child widgets:
  Gtk::Box m_HBox;
  Gtk::Box m_VBox;
  Gtk::Entry m_Entry;
  Gtk::Button m_Button_Close;
  Gtk::CheckButton m_CheckButton_Editable, m_CheckButton_Visible;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;gtkmm/application.h&gt;

int main(int argc, char *argv[])
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  //Shows the window and returns when it is closed.
  return app-&gt;make_window_and_run&lt;ExampleWindow&gt;(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;iostream&gt;

ExampleWindow::ExampleWindow()
: m_VBox(Gtk::Orientation::VERTICAL),
  m_Button_Close("Close"),
  m_CheckButton_Editable("Editable"),
  m_CheckButton_Visible("Visible")
{
  set_size_request(200, 100);
  set_title("Gtk::Entry");

  set_child(m_VBox);

  m_Entry.set_max_length(50);
  m_Entry.set_text("hello");
  m_Entry.set_text(m_Entry.get_text() + " world");
  m_Entry.select_region(0, m_Entry.get_text_length());
  m_Entry.set_expand(true);
  m_VBox.append(m_Entry);

  m_VBox.append(m_HBox);

  m_HBox.append(m_CheckButton_Editable);
  m_CheckButton_Editable.set_expand(true);
  m_CheckButton_Editable.signal_toggled().connect( sigc::mem_fun(*this,
              &amp;ExampleWindow::on_checkbox_editable_toggled) );
  m_CheckButton_Editable.set_active(true);

  m_HBox.append(m_CheckButton_Visible);
  m_CheckButton_Visible.set_expand(true);
  m_CheckButton_Visible.signal_toggled().connect( sigc::mem_fun(*this,
              &amp;ExampleWindow::on_checkbox_visibility_toggled) );
  m_CheckButton_Visible.set_active(true);

  m_Button_Close.signal_clicked().connect( sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_close) );
  m_VBox.append(m_Button_Close);
  m_Button_Close.set_expand();
  set_default_widget(m_Button_Close);
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_checkbox_editable_toggled()
{
  m_Entry.set_editable(m_CheckButton_Editable.get_active());
}

void ExampleWindow::on_checkbox_visibility_toggled()
{
  m_Entry.set_visibility(m_CheckButton_Visible.get_active());
}

void ExampleWindow::on_button_close()
{
  hide();
}

</pre></div>
</div>
</div>
<div class="division sect2">
<a name="sec-text-entry-completion"><!--sec-text-entry-completion--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">8.2.2. </span>Entry Completion</span></h4></div>
<p class="para block block-first">An <span class="classname" dir="ltr">Entry</span> widget can offer a drop-down list of
pre-existing choices based on the first few characters typed by the user. For
instance, a search dialog could suggest text from previous searches.
</p>
<p class="para block">To enable this functionality, you must create an
<span class="classname" dir="ltr">EntryCompletion</span> object, and provide it to the
<span class="classname" dir="ltr">Entry</span> widget via the
<span class="methodname" dir="ltr">set_completion()</span> method.</p>
<p class="para block">The <span class="classname" dir="ltr">EntryCompletion</span> may use a
<span class="classname" dir="ltr">TreeModel</span> containing possible entries, specified with
<span class="methodname" dir="ltr">set_model()</span>. You should then call
<span class="methodname" dir="ltr">set_text_column()</span> to specify which of your model columns
should be used to match possible text entries.</p>
<p class="para block">Alternatively, if a complete list of possible entries
would be too large or too inconvenient to generate, a callback slot may instead
be specified with <span class="methodname" dir="ltr">set_match_func()</span>.
This is also useful if you wish to match on a part of the string other
than the start.</p>
<p class="para block"><a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1EntryCompletion.html" title="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1EntryCompletion.html">Reference</a></p>
<div class="autotoc"><ul><li>
<span class="label">8.2.2.1. </span><a class="xref" href="#entry-completion-example" title="Entry Completion Example">Entry Completion Example</a>
</li></ul></div>
<div class="division sect3">
<a name="entry-completion-example"><!--entry-completion-example--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">8.2.2.1. </span>Entry Completion Example</span></h5></div>
<p class="para block block-first">
This example creates a <span class="classname" dir="ltr">Gtk::EntryCompletion</span> and associates
it with a <span class="classname" dir="ltr">Gtk::Entry</span> widget. The completion uses a
<span class="classname" dir="ltr">Gtk::TreeModel</span> of possible entries, and some additional
actions.
</p>
<div class=" block figure block-indent">
<a name="figure-entry-completion"><!--figure-entry-completion--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 8-3</span> </span>Entry Completion</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/entry_completion.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/entry/completion" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/entry/completion">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_button_close();

  //See the comment in the implementation:
  //bool on_completion_match(const Glib::ustring&amp; key, const Gtk::TreeModel::const_iterator&amp; iter);

  //Tree model columns, for the EntryCompletion's filter model:
  class ModelColumns : public Gtk::TreeModel::ColumnRecord
  {
  public:
    ModelColumns()
    { add(m_col_id); add(m_col_name); }

    Gtk::TreeModelColumn&lt;unsigned int&gt; m_col_id;
    Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_col_name;
  };

  ModelColumns m_Columns;

  //Child widgets:
  Gtk::Box m_HBox;
  Gtk::Box m_VBox;
  Gtk::Entry m_Entry;
  Gtk::Label m_Label;
  Gtk::Button m_Button_Close;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;gtkmm/application.h&gt;

int main(int argc, char *argv[])
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  //Shows the window and returns when it is closed.
  return app-&gt;make_window_and_run&lt;ExampleWindow&gt;(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;iostream&gt;

ExampleWindow::ExampleWindow()
: m_VBox(Gtk::Orientation::VERTICAL),
  m_Label("Press a or b to see a list of possible completions."),
  m_Button_Close("Close")
{
  //set_size_request(200, 100);
  set_title("Gtk::EntryCompletion");

  set_child(m_VBox);
  m_VBox.append(m_Entry);

  m_VBox.append(m_Label);
  m_Label.set_expand(true);

  m_Button_Close.signal_clicked().connect( sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_close) );
  m_VBox.append(m_Button_Close);
  set_default_widget(m_Button_Close);

  //Add an EntryCompletion:
  auto completion =
      Gtk::EntryCompletion::create();
  m_Entry.set_completion(completion);

  //Create and fill the completion's filter model
  auto refCompletionModel =
      Gtk::ListStore::create(m_Columns);
  completion-&gt;set_model(refCompletionModel);

  // For more complex comparisons, use a filter match callback, like this.
  // See the comment below for more details:
  //completion-&gt;set_match_func( sigc::mem_fun(*this,
              //&amp;ExampleWindow::on_completion_match) );

  //Fill the TreeView's model
  auto row = *(refCompletionModel-&gt;append());
  row[m_Columns.m_col_id] = 1;
  row[m_Columns.m_col_name] = "Alan Zebedee";

  row = *(refCompletionModel-&gt;append());
  row[m_Columns.m_col_id] = 2;
  row[m_Columns.m_col_name] = "Adrian Boo";

  row = *(refCompletionModel-&gt;append());
  row[m_Columns.m_col_id] = 3;
  row[m_Columns.m_col_name] = "Bob McRoberts";

  row = *(refCompletionModel-&gt;append());
  row[m_Columns.m_col_id] = 4;
  row[m_Columns.m_col_name] = "Bob McBob";

  //Tell the completion what model column to use to
  //- look for a match (when we use the default matching, instead of
  //  set_match_func().
  //- display text in the entry when a match is found.
  completion-&gt;set_text_column(m_Columns.m_col_name);
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_button_close()
{
  hide();
}

/* You can do more complex matching with a handler like this.
 * For instance, you could check for substrings inside the string instead of the start,
 * or you could look for the key in extra model columns as well as the model column that will be displayed.
 * The code here is not actually more complex - it's a reimplementation of the default behaviour.
 *
bool ExampleWindow::on_completion_match(const Glib::ustring&amp; key, const
        Gtk::TreeModel::const_iterator&amp; iter)
{
  if(iter)
  {
    const auto row = *iter;

    const auto key_length = key.size();
    auto filter_string = row[m_Columns.m_col_name];

    auto filter_string_start = filter_string.substr(0, key_length);
    //The key is lower-case, even if the user input is not.
    filter_string_start = filter_string_start.lowercase();

    if(key == filter_string_start)
      return true; //A match was found.
  }

  return false; //No match.
}
*/
</pre></div>
</div>
</div>
<div class="division sect2">
<a name="sec-text-entry-icons"><!--sec-text-entry-icons--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">8.2.3. </span>Entry Icons</span></h4></div>
<p class="para block block-first">An <span class="classname" dir="ltr">Entry</span> widget can show an icon at the start or
end of the text area. The icon can be specifed by methods such as
<span class="methodname" dir="ltr">set_icon_from_pixbuf()</span> or
<span class="methodname" dir="ltr">set_icon_from_icon_name()</span>. An application can respond to the
user pressing the icon by handling the
<span class="methodname" dir="ltr">signal_icon_press</span> signal.</p>
<div class="autotoc"><ul><li>
<span class="label">8.2.3.1. </span><a class="xref" href="#entry-icon-example" title="Entry Icon Example">Entry Icon Example</a>
</li></ul></div>
<div class="division sect3">
<a name="entry-icon-example"><!--entry-icon-example--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">8.2.3.1. </span>Entry Icon Example</span></h5></div>
<p class="para block block-first">
This example shows a <span class="classname" dir="ltr">Gtk::Entry</span> widget with a named
search icon, and prints text to the terminal when the icon is pressed.
</p>
<div class=" block figure block-indent">
<a name="figure-entry-icon"><!--figure-entry-icon--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 8-4</span> </span>Entry with Icon</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/entry_icon.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/entry/icon" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/entry/icon">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_icon_pressed(Gtk::Entry::IconPosition icon_pos);
  void on_button_close();

  //Child widgets:
  Gtk::Box m_VBox;
  Gtk::Entry m_Entry;
  Gtk::Button m_Button_Close;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;gtkmm/application.h&gt;

int main(int argc, char *argv[])
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  //Shows the window and returns when it is closed.
  return app-&gt;make_window_and_run&lt;ExampleWindow&gt;(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;iostream&gt;

ExampleWindow::ExampleWindow()
: m_VBox(Gtk::Orientation::VERTICAL),
  m_Button_Close("Close")
{
  set_title("Gtk::Entry");

  set_child(m_VBox);

  m_Entry.set_max_length(50);
  m_Entry.set_text("Hello world");
  m_VBox.append(m_Entry);

  m_Entry.set_icon_from_icon_name("edit-find");
  m_Entry.signal_icon_press().connect( sigc::mem_fun(*this, &amp;ExampleWindow::on_icon_pressed) );


  m_Button_Close.signal_clicked().connect( sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_close) );
  m_VBox.append(m_Button_Close);
  set_default_widget(m_Button_Close);
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_icon_pressed(Gtk::Entry::IconPosition /* icon_pos */)
{
  std::cout &lt;&lt; "Icon pressed." &lt;&lt; std::endl;
}

void ExampleWindow::on_button_close()
{
  hide();
}

</pre></div>
</div>
</div>
<div class="division sect2">
<a name="sec-text-entry-progress"><!--sec-text-entry-progress--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">8.2.4. </span>Entry Progress</span></h4></div>
<p class="para block block-first">An <span class="classname" dir="ltr">Entry</span> widget can show a progress bar inside the
text area, under the entered text. The progress bar will be shown if the
<span class="methodname" dir="ltr">set_progress_fraction()</span> or
<span class="methodname" dir="ltr">set_progress_pulse_step()</span> methods are called.</p>
<div class="autotoc"><ul><li>
<span class="label">8.2.4.1. </span><a class="xref" href="#entry-progress-example" title="Entry Progress Example">Entry Progress Example</a>
</li></ul></div>
<div class="division sect3">
<a name="entry-progress-example"><!--entry-progress-example--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">8.2.4.1. </span>Entry Progress Example</span></h5></div>
<p class="para block block-first">
This example shows a <span class="classname" dir="ltr">Gtk::Entry</span> widget with a progress
bar.
</p>
<div class=" block figure block-indent">
<a name="figure-entry-progress"><!--figure-entry-progress--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 8-5</span> </span>Entry with Progress Bar</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/entry_progress.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/entry/progress" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/entry/progress">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  bool on_timeout();
  void on_button_close();

  //Child widgets:
  Gtk::Box m_VBox;
  Gtk::Entry m_Entry;
  Gtk::Button m_Button_Close;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;gtkmm/application.h&gt;

int main(int argc, char *argv[])
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  //Shows the window and returns when it is closed.
  return app-&gt;make_window_and_run&lt;ExampleWindow&gt;(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;iostream&gt;

ExampleWindow::ExampleWindow()
: m_VBox(Gtk::Orientation::VERTICAL),
  m_Button_Close("Close")
{
  set_title("Gtk::Entry");

  set_child(m_VBox);

  m_Entry.set_max_length(50);
  m_Entry.set_text("Hello world");
  m_VBox.append(m_Entry);

  //Change the progress fraction every 0.1 second:
  Glib::signal_timeout().connect(
    sigc::mem_fun(*this, &amp;ExampleWindow::on_timeout),
    100
  );

  m_Button_Close.signal_clicked().connect( sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_close) );
  m_VBox.append(m_Button_Close);
  set_default_widget(m_Button_Close);
}

ExampleWindow::~ExampleWindow()
{
}

bool ExampleWindow::on_timeout()
{
  static double fraction = 0;
  m_Entry.set_progress_fraction(fraction);

  fraction += 0.01;
  if(fraction &gt; 1)
    fraction = 0;

  return true;
}

void ExampleWindow::on_button_close()
{
  hide();
}

</pre></div>
</div>
</div>
</div>
<div class="division sect1">
<a name="sec-spinbutton"><!--sec-spinbutton--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">8.3. </span>SpinButton</span></h3></div>
<p class="para block block-first">
A <span class="classname" dir="ltr">SpinButton</span> allows the user to select a value from a
range of numeric values. It has an <span class="classname" dir="ltr">Entry</span> widget with increment and decrement buttons
at the side. Clicking the buttons causes the value to 'spin' up and down across
the range of possible values. The <span class="classname" dir="ltr">Entry</span> widget may also
be used to enter a value directly.
</p>
<p class="para block">
The value can have an adjustable number of decimal places, and the step size is
configurable. <span class="classname" dir="ltr">SpinButton</span>s have an 'auto-repeat' feature
as well: holding down the increment or decrement button can optionally cause the value to
change more quickly the longer the button is held down.
</p>
<p class="para block">
<span class="classname" dir="ltr">SpinButton</span>s use an <a class="link" href="#chapter-adjustment" title="Adjustments">Adjustment</a> object to hold information about
the range of values. These Adjustment attributes are used by the Spin Button
like so:
<div class="block list itemizedlist"><ul class="itemizedlist">
<li class="li-first">

<span class="para">
 <span class="literal" dir="ltr">value</span>: value for the Spin Button
</span>
</li>
<li>

<span class="para">
 <span class="literal" dir="ltr">lower</span>: lower range value
</span>
</li>
<li>

<span class="para">
 <span class="literal" dir="ltr">upper</span>: upper range value
</span>
</li>
<li>
<span class="para">
 <span class="literal" dir="ltr">step_increment</span>: value to increment/decrement when pressing
mouse button 1
</span>
</li>
<li>

<span class="para">
 <span class="literal" dir="ltr">page_increment</span>: value to increment/decrement when pressing
mouse button 2
</span>
</li>
<li>

<span class="para">
 <span class="literal" dir="ltr">page_size</span>: unused
</span>
</li>
</ul></div>
</p>
<p class="para block">
Additionally, mouse button 3 can be used to jump directly to the
<span class="literal" dir="ltr">upper</span> or <span class="literal" dir="ltr">lower</span> values.
</p>
<p class="para block">
The <span class="classname" dir="ltr">SpinButton</span> can create a default
<span class="classname" dir="ltr">Adjustment</span>, which you can access via the
<span class="methodname" dir="ltr">get_adjustment()</span> method, or you can specify an existing
<span class="classname" dir="ltr">Adjustment</span> in the constructor.
</p>
<div class="autotoc"><ul>
<li>
<span class="label">8.3.1. </span><a class="xref" href="#spinbutton-methods" title="Methods">Methods</a>
</li>
<li>
<span class="label">8.3.2. </span><a class="xref" href="#spinbutton-example" title="Example">Example</a>
</li>
</ul></div>
<div class="division sect2">
<a name="spinbutton-methods"><!--spinbutton-methods--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">8.3.1. </span>Methods</span></h4></div>
<p class="para block block-first">
The number of decimal places can be altered using the
<span class="methodname" dir="ltr">set_digits()</span> method.
</p>
<p class="para block">
You can set the spinbutton's value using the <span class="methodname" dir="ltr">set_value()</span>
method, and retrieve it with <span class="methodname" dir="ltr">get_value()</span>.
</p>
<p class="para block">
The <span class="methodname" dir="ltr">spin()</span> method 'spins' the
<span class="classname" dir="ltr">SpinButton</span>, as if its increment or decrement button had been clicked.
You need to specify a <span class="classname" dir="ltr">Gtk::SpinType</span> to specify the
direction or new position.
</p>
<p class="para block">
To prevent the user from typing non-numeric characters into the entry box, pass
<span class="literal" dir="ltr">true</span> to the <span class="methodname" dir="ltr">set_numeric()</span> method.
</p>
<p class="para block">
To make the <span class="classname" dir="ltr">SpinButton</span> 'wrap' between its upper and
lower bounds, use the <span class="methodname" dir="ltr">set_wrap()</span> method.
</p>
<p class="para block">
To force it to snap to the nearest <span class="literal" dir="ltr">step_increment</span>,
use <span class="methodname" dir="ltr">set_snap_to_ticks()</span>.
</p>
<p class="para block"><a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1SpinButton.html" title="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1SpinButton.html">Reference</a></p>
</div>
<div class="division sect2">
<a name="spinbutton-example"><!--spinbutton-example--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">8.3.2. </span>Example</span></h4></div>
<p class="para block block-first">
Here's an example of a <span class="classname" dir="ltr">SpinButton</span> in action:
</p>
<div class=" block figure block-indent">
<a name="figure-spinbutton"><!--figure-spinbutton--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 8-6</span> </span>SpinButton</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/spinbutton.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/spinbutton" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/spinbutton">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_checkbutton_snap();
  void on_checkbutton_numeric();
  void on_spinbutton_digits_changed();
  void on_button_close();

  enum enumValueFormats
  {
    VALUE_FORMAT_INT,
    VALUE_FORMAT_FLOAT
  };
  void on_button_getvalue(enumValueFormats display);

  //Child widgets:
  Gtk::Frame m_Frame_NotAccelerated, m_Frame_Accelerated;
  Gtk::Box m_HBox_NotAccelerated, m_HBox_Accelerated,
    m_HBox_Buttons;
  Gtk::Box m_VBox_Main, m_VBox, m_VBox_Day, m_VBox_Month, m_VBox_Year,
    m_VBox_Accelerated, m_VBox_Value, m_VBox_Digits;
  Gtk::Label m_Label_Day, m_Label_Month, m_Label_Year,
    m_Label_Value, m_Label_Digits,
    m_Label_ShowValue;
  Glib::RefPtr&lt;Gtk::Adjustment&gt; m_adjustment_day, m_adjustment_month, m_adjustment_year,
    m_adjustment_value, m_adjustment_digits;
  Gtk::SpinButton m_SpinButton_Day, m_SpinButton_Month, m_SpinButton_Year,
    m_SpinButton_Value, m_SpinButton_Digits;
  Gtk::CheckButton m_CheckButton_Snap, m_CheckButton_Numeric;
  Gtk::Button m_Button_Int, m_Button_Float, m_Button_Close;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;gtkmm/application.h&gt;

int main(int argc, char *argv[])
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  //Shows the window and returns when it is closed.
  return app-&gt;make_window_and_run&lt;ExampleWindow&gt;(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;iostream&gt;
#include &lt;cstdio&gt;

ExampleWindow::ExampleWindow()
:
  m_Frame_NotAccelerated("Not accelerated"),
  m_Frame_Accelerated("Accelerated"),
  m_VBox_Main(Gtk::Orientation::VERTICAL, 5),
  m_VBox(Gtk::Orientation::VERTICAL),
  m_VBox_Day(Gtk::Orientation::VERTICAL),
  m_VBox_Month(Gtk::Orientation::VERTICAL),
  m_VBox_Year(Gtk::Orientation::VERTICAL),
  m_VBox_Accelerated(Gtk::Orientation::VERTICAL),
  m_VBox_Value(Gtk::Orientation::VERTICAL),
  m_VBox_Digits(Gtk::Orientation::VERTICAL),
  m_Label_Day("Day: ", Gtk::Align::START),
  m_Label_Month("Month: ", Gtk::Align::START),
  m_Label_Year("Year: ", Gtk::Align::START),
  m_Label_Value("Value: ", Gtk::Align::START),
  m_Label_Digits("Digits: ", Gtk::Align::START),
  m_adjustment_day( Gtk::Adjustment::create(1.0, 1.0, 31.0, 1.0, 5.0, 0.0) ),
  m_adjustment_month( Gtk::Adjustment::create(1.0, 1.0, 12.0, 1.0, 5.0, 0.0) ),
  m_adjustment_year( Gtk::Adjustment::create(2012.0, 1.0, 2200.0, 1.0, 100.0, 0.0) ),
  m_adjustment_value( Gtk::Adjustment::create(0.0, -10000.0, 10000.0, 0.5, 100.0, 0.0) ),
  m_adjustment_digits( Gtk::Adjustment::create(2.0, 1.0, 5.0, 1.0, 1.0, 0.0) ),
  m_SpinButton_Day(m_adjustment_day),
  m_SpinButton_Month(m_adjustment_month),
  m_SpinButton_Year(m_adjustment_year),
  m_SpinButton_Value(m_adjustment_value, 1.0, 2),
  m_SpinButton_Digits(m_adjustment_digits),
  m_CheckButton_Snap("Snap to 0.5-ticks"),
  m_CheckButton_Numeric("Numeric only input mode"),
  m_Button_Int("Value as Int"),
  m_Button_Float("Value as Float"),
  m_Button_Close("Close")
{
  set_title("SpinButton");

  m_VBox_Main.set_margin(10);
  set_child(m_VBox_Main);

  m_VBox_Main.append(m_Frame_NotAccelerated);

  m_VBox.set_margin(5);
  m_Frame_NotAccelerated.set_child(m_VBox);

  /* Day, month, year spinners */

  m_VBox.set_spacing(5);
  m_VBox.append(m_HBox_NotAccelerated);

  m_Label_Day.set_expand();
  m_VBox_Day.append(m_Label_Day);

  m_SpinButton_Day.set_wrap();
  m_SpinButton_Day.set_expand();
  m_VBox_Day.append(m_SpinButton_Day);

  m_HBox_NotAccelerated.set_spacing(5);
  m_HBox_NotAccelerated.append(m_VBox_Day);

  m_Label_Month.set_expand();
  m_VBox_Month.append(m_Label_Month);

  m_SpinButton_Month.set_wrap();
  m_SpinButton_Month.set_expand();
  m_VBox_Month.append(m_SpinButton_Month);

  m_HBox_NotAccelerated.append(m_VBox_Month);

  m_Label_Year.set_expand();
  m_VBox_Year.append(m_Label_Year);

  m_SpinButton_Year.set_wrap();
  m_SpinButton_Year.set_expand();
  m_SpinButton_Year.set_size_request(55, -1);
  m_VBox_Year.append(m_SpinButton_Year);

  m_HBox_NotAccelerated.append(m_VBox_Year);

  //Accelerated:
  m_VBox_Main.append(m_Frame_Accelerated);

  m_VBox_Accelerated.set_margin(5);
  m_Frame_Accelerated.set_child(m_VBox_Accelerated);

  m_VBox_Accelerated.set_spacing(5);
  m_VBox_Accelerated.append(m_HBox_Accelerated);

  m_HBox_Accelerated.append(m_VBox_Value);

  m_Label_Value.set_expand();
  m_VBox_Value.append(m_Label_Value);

  m_SpinButton_Value.set_wrap();
  m_SpinButton_Value.set_expand();
  m_SpinButton_Value.set_size_request(100, -1);
  m_VBox_Value.append(m_SpinButton_Value);

  m_HBox_Accelerated.append(m_VBox_Digits);

  m_VBox_Digits.append(m_Label_Digits);
  m_Label_Digits.set_expand();

  m_SpinButton_Digits.set_wrap();
  m_adjustment_digits-&gt;signal_value_changed().connect( sigc::mem_fun(*this,
              &amp;ExampleWindow::on_spinbutton_digits_changed) );

  m_VBox_Digits.append(m_SpinButton_Digits);
  m_SpinButton_Digits.set_expand();

  //CheckButtons:
  m_VBox_Accelerated.append(m_CheckButton_Snap);
  m_CheckButton_Snap.set_expand();
  m_CheckButton_Snap.set_active();
  m_CheckButton_Snap.signal_toggled().connect( sigc::mem_fun(*this,
              &amp;ExampleWindow::on_checkbutton_snap) );

  m_VBox_Accelerated.append(m_CheckButton_Numeric);
  m_CheckButton_Numeric.set_expand();
  m_CheckButton_Numeric.set_active();
  m_CheckButton_Numeric.signal_toggled().connect( sigc::mem_fun(*this,
              &amp;ExampleWindow::on_checkbutton_numeric) );

  //Buttons:
  m_VBox_Accelerated.append(m_HBox_Buttons);

  m_Button_Int.signal_clicked().connect( sigc::bind( sigc::mem_fun(*this,
                  &amp;ExampleWindow::on_button_getvalue), VALUE_FORMAT_INT) );
  m_HBox_Buttons.set_spacing(5);
  m_HBox_Buttons.append(m_Button_Int);
  m_Button_Int.set_expand();

  m_Button_Float.signal_clicked().connect( sigc::bind( sigc::mem_fun(*this,
                  &amp;ExampleWindow::on_button_getvalue), VALUE_FORMAT_FLOAT) );
  m_HBox_Buttons.append(m_Button_Float);
  m_Button_Float.set_expand();

  m_VBox_Accelerated.append(m_Label_ShowValue);
  m_Label_ShowValue.set_expand();
  m_Label_ShowValue.set_text("0");

  //Close button:
  m_Button_Close.signal_clicked().connect( sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_close) );
  m_VBox_Main.append(m_Button_Close);
}

ExampleWindow::~ExampleWindow()
{
}


void ExampleWindow::on_button_close()
{
  hide();
}

void ExampleWindow::on_checkbutton_snap()
{
  m_SpinButton_Value.set_snap_to_ticks( m_CheckButton_Snap.get_active() );
}

void ExampleWindow::on_checkbutton_numeric()
{
  m_SpinButton_Value.set_numeric( m_CheckButton_Numeric.get_active() );
}

void ExampleWindow::on_spinbutton_digits_changed()
{
  m_SpinButton_Value.set_digits( m_SpinButton_Digits.get_value_as_int() );
}

void ExampleWindow::on_button_getvalue(enumValueFormats display)
{
  gchar buf[32];

  if (display == VALUE_FORMAT_INT)
    sprintf (buf, "%d", m_SpinButton_Value.get_value_as_int());
  else
    sprintf (buf, "%0.*f", m_SpinButton_Value.get_digits(),
            m_SpinButton_Value.get_value());

  m_Label_ShowValue.set_text(buf);
}
</pre></div>
</div>
</div>
<div class="division sect1">
<a name="sec-progressbar"><!--sec-progressbar--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">8.4. </span>ProgressBar</span></h3></div>
<p class="para block block-first">
Progress bars are used to show the status of an ongoing operation. For
instance, a <span class="classname" dir="ltr">ProgressBar</span> can show how much of a task has
been completed.
</p>
<p class="para block">
To change the value shown, use the <span class="methodname" dir="ltr">set_fraction()</span> method,
passing a <span class="type" dir="ltr">double</span> between 0.0 and 1.0 to provide the new fraction.
</p>
<p class="para block">
A <span class="classname" dir="ltr">ProgressBar</span> is horizontal and left-to-right by default,
but you can change it to a vertical progress bar by using the
<span class="methodname" dir="ltr">set_orientation()</span> method.
</p>
<p class="para block"><a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1ProgressBar.html" title="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1ProgressBar.html">Reference</a></p>
<div class="autotoc"><ul>
<li>
<span class="label">8.4.1. </span><a class="xref" href="#progressbar-activity-mode" title="Activity Mode">Activity Mode</a>
</li>
<li>
<span class="label">8.4.2. </span><a class="xref" href="#progressbar-example" title="Example">Example</a>
</li>
</ul></div>
<div class="division sect2">
<a name="progressbar-activity-mode"><!--progressbar-activity-mode--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">8.4.1. </span>Activity Mode</span></h4></div>
<p class="para block block-first">
Besides indicating the amount of progress that has occured, the
progress bar can also be used to indicate that there is some activity;
this is done by placing the progress bar in <span class="emphasis">activity mode</span>. In
this mode, the progress bar displays a small rectangle which moves
back and forth. Activity mode is useful in situations where the
progress of an operation cannot be calculated as a value range (e.g.,
receiving a file of unknown length).
</p>
<p class="para block">
To do this, you need to call the <span class="methodname" dir="ltr">pulse()</span> method at regular
intervals. You can also choose the step size, with the
<span class="methodname" dir="ltr">set_pulse_step()</span> method.
</p>
<p class="para block">
The progress bar can also display a configurable text
string next to the bar, using the <span class="methodname" dir="ltr">set_text()</span> method.
</p>
</div>
<div class="division sect2">
<a name="progressbar-example"><!--progressbar-example--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">8.4.2. </span>Example</span></h4></div>
<div class=" block figure block-first block-indent">
<a name="figure-progressbar"><!--figure-progressbar--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 8-7</span> </span>ProgressBar</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/progressbar.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/progressbar" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/progressbar">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_checkbutton_text();
  void on_checkbutton_activity();
  void on_checkbutton_inverted();

  bool on_timeout();
  void on_button_close();

  //Child widgets:
  Gtk::Box m_VBox;
  Gtk::Grid m_Grid;
  Gtk::ProgressBar m_ProgressBar;
  Gtk::Separator m_Separator;
  Gtk::CheckButton m_CheckButton_Text, m_CheckButton_Activity, m_CheckButton_Inverted;
  Gtk::Button m_Button_Close;

  sigc::connection m_connection_timeout;
  bool m_bActivityMode;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;gtkmm/application.h&gt;

int main(int argc, char *argv[])
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  //Shows the window and returns when it is closed.
  return app-&gt;make_window_and_run&lt;ExampleWindow&gt;(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;iostream&gt;

ExampleWindow::ExampleWindow()
: m_VBox(Gtk::Orientation::VERTICAL, 5),
  m_CheckButton_Text("Show text"),
  m_CheckButton_Activity("Activity mode"),
  m_CheckButton_Inverted("Right to Left"),
  m_Button_Close("Close"),
  m_bActivityMode(false)
{
  set_resizable();
  set_title("Gtk::ProgressBar");

  m_VBox.set_margin(10);
  set_child(m_VBox);

  m_VBox.append(m_ProgressBar);
  m_ProgressBar.set_margin_end(5);
  m_ProgressBar.set_halign(Gtk::Align::CENTER);
  m_ProgressBar.set_valign(Gtk::Align::CENTER);
  m_ProgressBar.set_size_request(100, -1);
  m_ProgressBar.set_text("some text");
  m_ProgressBar.set_show_text(false);

  //Add a timer callback to update the value of the progress bar:
  m_connection_timeout = Glib::signal_timeout().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_timeout), 50 );

  m_VBox.append(m_Separator);
  m_VBox.append(m_Grid);
  m_Grid.set_expand(true);
  m_Grid.set_row_homogeneous(true);

  //Add a check button to select displaying of the trough text:
  m_Grid.attach(m_CheckButton_Text, 0, 0);
  m_CheckButton_Text.set_margin(5);
  m_CheckButton_Text.signal_toggled().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_checkbutton_text) );

  //Add a check button to toggle activity mode:
  m_Grid.attach(m_CheckButton_Activity, 0, 1);
  m_CheckButton_Activity.set_margin(5);
  m_CheckButton_Activity.signal_toggled().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_checkbutton_activity) );

  //Add a check button to select growth from left to right or from right to left:
  m_Grid.attach(m_CheckButton_Inverted, 0, 2);
  m_CheckButton_Inverted.set_margin(5);
  m_CheckButton_Inverted.signal_toggled().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_checkbutton_inverted) );

  //Add a button to exit the program.
  m_VBox.append(m_Button_Close);
  m_Button_Close.signal_clicked().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_close) );
  set_default_widget(m_Button_Close);
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_checkbutton_text()
{
  const bool show_text = m_CheckButton_Text.get_active();
  m_ProgressBar.set_show_text(show_text);
}

void ExampleWindow::on_checkbutton_activity()
{
  m_bActivityMode = m_CheckButton_Activity.get_active();

  if(m_bActivityMode)
    m_ProgressBar.pulse();
  else
    m_ProgressBar.set_fraction(0.0);
}

void ExampleWindow::on_checkbutton_inverted()
{
  const bool inverted = m_CheckButton_Inverted.get_active();
  m_ProgressBar.set_inverted(inverted);
}

void ExampleWindow::on_button_close()
{
  hide();
}

/* Update the value of the progress bar so that we get
 * some movement */
bool ExampleWindow::on_timeout()
{
  if(m_bActivityMode)
    m_ProgressBar.pulse();
  else
  {
    double new_val = m_ProgressBar.get_fraction() + 0.01;

    if(new_val &gt; 1.0)
      new_val = 0.0;

    //Set the new value:
    m_ProgressBar.set_fraction(new_val);
  }

  //As this is a timeout function, return true so that it
  //continues to get called
  return true;
}
</pre></div>
</div>
</div>
<div class="division sect1">
<a name="sec-infobar"><!--sec-infobar--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">8.5. </span>InfoBar</span></h3></div>
<p class="para block block-first">
An <span class="classname" dir="ltr">InfoBar</span> may show small items of information or ask brief questions. Unlike a <span class="classname" dir="ltr">Dialog</span>, it appears at the top of the current window instead of opening a new window. Its API is very similar to the <a class="link" href="#chapter-dialogs" title="Dialogs">Gtk::Dialog</a> API.</p>
<p class="para block"><a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1InfoBar.html" title="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1InfoBar.html">Reference</a></p>
<div class="autotoc"><ul><li>
<span class="label">8.5.1. </span><a class="xref" href="#infobar-example" title="Example">Example</a>
</li></ul></div>
<div class="division sect2">
<a name="infobar-example"><!--infobar-example--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">8.5.1. </span>Example</span></h4></div>
<div class=" block figure block-first block-indent">
<a name="figure-infobar"><!--figure-infobar--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 8-8</span> </span>InfoBar</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/infobar.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/infobar" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/infobar">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_infobar_response(int response);
  void on_button_quit();
  void on_button_clear();
  void on_textbuffer_changed();

  //Child widgets:
  Gtk::Box m_VBox;

  Gtk::ScrolledWindow m_ScrolledWindow;
  Gtk::TextView m_TextView;

  Glib::RefPtr&lt;Gtk::TextBuffer&gt; m_refTextBuffer;

  Gtk::InfoBar m_InfoBar;
  Gtk::Label m_Message_Label;

  Gtk::Box m_ButtonBox;
  Gtk::Button m_Button_Quit, m_Button_Clear;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;gtkmm/application.h&gt;

int main(int argc, char *argv[])
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  //Shows the window and returns when it is closed.
  return app-&gt;make_window_and_run&lt;ExampleWindow&gt;(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"

ExampleWindow::ExampleWindow()
: m_VBox(Gtk::Orientation::VERTICAL, 6),
  m_Button_Quit("_Quit", true),
  m_Button_Clear("_Clear", true)
{
  set_title("Gtk::InfoBar example");
  set_default_size(400, 200);

  m_VBox.set_margin(6);
  set_child(m_VBox);

  // Add the message label to the InfoBar:
  m_InfoBar.add_child(m_Message_Label);

  // Add an ok button to the InfoBar:
  m_InfoBar.add_button("_OK", 0);

  // Add the InfoBar to the vbox:
  m_VBox.append(m_InfoBar);

  // Create the buffer and set it for the TextView:
  m_refTextBuffer = Gtk::TextBuffer::create();
  m_TextView.set_buffer(m_refTextBuffer);

  // Add the TreeView, inside a ScrolledWindow:
  m_ScrolledWindow.set_child(m_TextView);

  // Show the scrollbars only when they are necessary:
  m_ScrolledWindow.set_policy(Gtk::PolicyType::AUTOMATIC, Gtk::PolicyType::AUTOMATIC);
  m_ScrolledWindow.set_expand();

  m_VBox.append(m_ScrolledWindow);

  // Add button box:
  m_VBox.append(m_ButtonBox);

  m_ButtonBox.append(m_Button_Clear);
  m_ButtonBox.append(m_Button_Quit);
  m_ButtonBox.set_spacing(6);
  m_Button_Clear.set_hexpand(true);
  m_Button_Clear.set_halign(Gtk::Align::END);

  // Connect signals:
  m_InfoBar.signal_response().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_infobar_response) );
  m_Button_Quit.signal_clicked().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_quit) );
  m_Button_Clear.signal_clicked().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_clear) );
  m_refTextBuffer-&gt;signal_changed().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_textbuffer_changed) );

  // Keep the InfoBar hidden until a message needs to be shown:
  m_InfoBar.hide();

  // Make the clear button insensitive until text is typed in the buffer.  When
  // the button is sensitive and it is pressed, the InfoBar is displayed with a
  // message.
  m_Button_Clear.set_sensitive(false);
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_infobar_response(int)
{
  // Clear the message and hide the info bar:
  m_Message_Label.set_text("");
  m_InfoBar.hide();
}

void ExampleWindow::on_button_quit()
{
  hide();
}

void ExampleWindow::on_button_clear()
{
  m_refTextBuffer-&gt;set_text("");
  m_Message_Label.set_text("Cleared the text.");
  m_InfoBar.set_message_type(Gtk::MessageType::INFO);
  m_InfoBar.show();
}

void ExampleWindow::on_textbuffer_changed()
{
  m_Button_Clear.set_sensitive(m_refTextBuffer-&gt;size() &gt; 0);
}
</pre></div>
</div>
</div>
<div class="division sect1">
<a name="sec-tooltips"><!--sec-tooltips--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">8.6. </span>Tooltips</span></h3></div>
<p class="para block block-first">
Tooltips are the little information windows that pop up when you leave your
pointer over a widget for a few seconds. Use
<span class="methodname" dir="ltr">set_tooltip_text()</span> to set a text string as a tooltip
on any <span class="classname" dir="ltr">Widget</span>.
<span class="classname" dir="ltr">Gtk::Tooltip</span> is used for more advanced tooltip usage,
such as showing an image as well as text.
</p>
<p class="para block"><a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Widget.html" title="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Widget.html">Widget Reference</a></p>
<p class="para block"><a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Tooltip.html" title="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Tooltip.html">Tooltip Reference</a></p>
<div class="autotoc"><ul><li>
<span class="label">8.6.1. </span><a class="xref" href="#tooltip-example" title="Example">Example</a>
</li></ul></div>
<div class="division sect2">
<a name="tooltip-example"><!--tooltip-example--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">8.6.1. </span>Example</span></h4></div>
<div class=" block figure block-first block-indent">
<a name="figure-tooltip"><!--figure-tooltip--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 8-9</span> </span>Tooltip</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/tooltip.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/tooltips" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/tooltips">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:

  ExampleWindow();
  virtual ~ExampleWindow();

protected:

  //Methods:
  void prepare_textview();
  void connect_signals();

  //Signal handlers:
  void on_markup_checkbutton_toggled();
  bool on_textview_query_tooltip(int x, int y, bool keyboard_tooltip, const Glib::RefPtr&lt;Gtk::Tooltip&gt;&amp; tooltip);
  bool on_button_query_tooltip(int x, int y, bool keyboard_tooltip, const Glib::RefPtr&lt;Gtk::Tooltip&gt;&amp; tooltip);

  //Child widgets:
  Gtk::Box m_vbox;

  Gtk::CheckButton m_checkbutton;
  Gtk::Label m_label;

  Gtk::ScrolledWindow m_scrolled_window;
  Gtk::TextView m_text_view;
  Glib::RefPtr&lt;Gtk::TextBuffer&gt; m_ref_text_buffer;
  Glib::RefPtr&lt;Gtk::TextTag&gt; m_ref_bold_tag;

  Gtk::Button m_button;
  Gtk::Box m_button_tooltip_widget;
};

#endif // GTKMM_EXAMPLEWINDOW_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;gtkmm/application.h&gt;

int main(int argc, char *argv[])
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  //Shows the window and returns when it is closed.
  return app-&gt;make_window_and_run&lt;ExampleWindow&gt;(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;vector&gt;

const Glib::ustring app_title = "gtkmm tooltips example";
const Glib::ustring non_markedup_tip = "A tooltip without markup.";
const Glib::ustring markedup_tip = "&lt;i&gt;Markup&lt;/i&gt; in a tooltip.";

ExampleWindow::ExampleWindow()
  :
  m_vbox(Gtk::Orientation::VERTICAL, 3),
  m_checkbutton("Click to alternate markup in tooltip"),
  m_label("A label"),
  m_button("Button with a custom tooltip widget")
{
  //Set up window and the top-level container:
  set_title(app_title);

  m_vbox.set_margin(10);
  set_child(m_vbox);

  //Check button with markup in tooltip:
  m_checkbutton.set_tooltip_text(non_markedup_tip);
  m_vbox.append(m_checkbutton);

  //Label:
  m_label.set_tooltip_text("Another tooltip");
  m_vbox.append(m_label);

  //Textview:
  prepare_textview();

  //Button:
  //When only connecting to the query-tooltip signal, and not using any
  //of set_tooltip_text() or set_tooltip_markup(), we need to explicitly
  //tell GTK that the widget has a tooltip which we'll show.
  m_button.set_has_tooltip();
  m_vbox.append(m_button);

  //Button's custom tooltip widget:
  auto label = Gtk::make_managed&lt;Gtk::Label&gt;("A label in a custom tooltip widget");
  m_button_tooltip_widget.append(*label);

  connect_signals();
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::prepare_textview()
{
  Gtk::TextIter iter;
  std::vector&lt;Glib::RefPtr&lt;Gtk::TextTag&gt;&gt; tags;

  //Set up a scrolled window:
  m_scrolled_window.set_child(m_text_view);
  m_scrolled_window.set_policy(Gtk::PolicyType::AUTOMATIC, Gtk::PolicyType::AUTOMATIC);
  m_scrolled_window.set_expand();
  m_vbox.append(m_scrolled_window);

  //Create a text buffer with some text:
  m_ref_text_buffer = Gtk::TextBuffer::create();

  iter = m_ref_text_buffer-&gt;end();
  m_ref_text_buffer-&gt;insert(iter, "Hover over the text ");

  //Insert some text with a tag.
  //In the tooltip signal handler below, we will show a tooltip
  //when mouse pointer is above this tagged text.
  m_ref_bold_tag = m_ref_text_buffer-&gt;create_tag("bold");
  m_ref_bold_tag-&gt;set_property("weight", Pango::Weight::BOLD);

  tags.push_back(m_ref_bold_tag);

  iter = m_ref_text_buffer-&gt;end();
  m_ref_text_buffer-&gt;insert_with_tags(iter, "in bold", tags);

  iter = m_ref_text_buffer-&gt;end();
  m_ref_text_buffer-&gt;insert(iter, " to see its tooltip");

  m_text_view.set_buffer(m_ref_text_buffer);

  m_text_view.set_size_request(320, 50);

  //When only connecting to the query-tooltip signal, and not using any
  //of set_tooltip_text() or set_tooltip_markup(), we need to explicitly
  //tell GTK that the widget has a tooltip which we'll show.
  m_text_view.set_has_tooltip();
}

void ExampleWindow::connect_signals()
{
  m_checkbutton.signal_toggled().connect(
    sigc::mem_fun(*this, &amp;ExampleWindow::on_markup_checkbutton_toggled));

  m_text_view.signal_query_tooltip().connect(
    sigc::mem_fun(*this, &amp;ExampleWindow::on_textview_query_tooltip), true);

  m_button.signal_query_tooltip().connect(
    sigc::mem_fun(*this, &amp;ExampleWindow::on_button_query_tooltip), true);
}

void ExampleWindow::on_markup_checkbutton_toggled()
{
  if (m_checkbutton.get_active())
  {
    m_checkbutton.set_tooltip_markup(markedup_tip);
  }
  else
  {
    m_checkbutton.set_tooltip_markup(non_markedup_tip);
  }
}

bool ExampleWindow::on_textview_query_tooltip(int x, int y, bool keyboard_tooltip, const Glib::RefPtr&lt;Gtk::Tooltip&gt;&amp; tooltip)
{
  Gtk::TextIter iter;

  if (keyboard_tooltip)
  {
    int offset = m_ref_text_buffer-&gt;property_cursor_position().get_value();
    iter = m_ref_text_buffer-&gt;get_iter_at_offset(offset);
  }
  else
  {
    int mouse_x, mouse_y, trailing;
    m_text_view.window_to_buffer_coords(Gtk::TextWindowType::TEXT,
                                        x, y, mouse_x, mouse_y);
    m_text_view.get_iter_at_position(iter, trailing, mouse_x, mouse_y);
  }

  if (!iter.has_tag(m_ref_bold_tag))
    return false;

  //Show a tooltip if the cursor or mouse pointer is over the text
  //with the specific tag:
  tooltip-&gt;set_markup("&lt;b&gt;Information&lt;/b&gt; attached to a text tag");
  tooltip-&gt;set_icon("dialog-information");
  return true;
}

bool ExampleWindow::on_button_query_tooltip(int, int, bool, const Glib::RefPtr&lt;Gtk::Tooltip&gt;&amp; tooltip)
{
  tooltip-&gt;set_custom(m_button_tooltip_widget);
  return true;
}
</pre></div>
</div>
</div>
</div>
<div class="division chapter">
<a name="chapter-container-widgets"><!--chapter-container-widgets--></a><div class="header"><h2 class="chapter title"><span class="title"><span class="label">9. </span>Container Widgets</span></h2></div>
<p class="para block block-first">
Container widgets, like other widgets, derive from <span class="classname" dir="ltr">Gtk::Widget</span>.
Some container widgets, such as <span class="classname" dir="ltr">Gtk::Grid</span> can hold many
child widgets, so these typically have more complex interfaces. Others, such as
<span class="classname" dir="ltr">Gtk::Frame</span> contain only one child widget.
</p>
<div class="autotoc"><ul>
<li>
<span class="label">9.1. </span><a class="xref" href="#sec-single-item-containers" title="Single-item Containers">Single-item Containers</a>
</li>
<li>
<span class="label">9.2. </span><a class="xref" href="#sec-multi-item-containers" title="Multiple-item Containers ">Multiple-item Containers </a>
</li>
</ul></div>
<div class="division sect1">
<a name="sec-single-item-containers"><!--sec-single-item-containers--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">9.1. </span>Single-item Containers</span></h3></div>
<p class="para block block-first">
Most single-item container widgets have <span class="methodname" dir="ltr">set_child()</span>
and <span class="methodname" dir="ltr">unset_child()</span> methods for the child widget.
<span class="classname" dir="ltr">Gtk::Button</span> and <span class="classname" dir="ltr">Gtk::Window</span> are
technically single-item containers, but we have discussed them already elsewhere.
</p>
<p class="para block">
We also discuss the <span class="classname" dir="ltr">Gtk::Paned</span> widget, which allows you
to divide a window into two separate "panes". This widget actually contains
two child widgets, but the number is fixed so it seems appropriate.
</p>
<div class="autotoc"><ul>
<li>
<span class="label">9.1.1. </span><a class="xref" href="#sec-frame" title="Frame">Frame</a>
</li>
<li>
<span class="label">9.1.2. </span><a class="xref" href="#sec-paned" title="Paned">Paned</a>
</li>
<li>
<span class="label">9.1.3. </span><a class="xref" href="#sec-scrolledwindow" title="ScrolledWindow">ScrolledWindow</a>
</li>
<li>
<span class="label">9.1.4. </span><a class="xref" href="#sec-aspectframe" title="AspectFrame">AspectFrame</a>
</li>
<li>
<span class="label">9.1.5. </span><a class="xref" href="#sec-other-single-item-containers" title="Other Single-item Containers">Other Single-item Containers</a>
</li>
</ul></div>
<div class="division sect2">
<a name="sec-frame"><!--sec-frame--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">9.1.1. </span>Frame</span></h4></div>
<p class="para block block-first">
Frames can enclose one or a group of widgets within a box, optionally with a
title. For instance, you might place a group of
<span class="classname" dir="ltr">ToggleButton</span>s or <span class="classname" dir="ltr">CheckButton</span>s in a
<span class="classname" dir="ltr">Frame</span>.
</p>
<p class="para block"><a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Frame.html" title="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Frame.html">Reference</a></p>
<div class="autotoc"><ul><li>
<span class="label">9.1.1.1. </span><a class="xref" href="#frame-example" title="Example">Example</a>
</li></ul></div>
<div class="division sect3">
<a name="frame-example"><!--frame-example--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">9.1.1.1. </span>Example</span></h5></div>
<div class=" block figure block-first block-indent">
<a name="figure-frame"><!--figure-frame--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 9-1</span> </span>Frame</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/frame.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/frame" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/frame">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:

  //Child widgets:
  Gtk::Frame m_Frame;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;gtkmm/application.h&gt;

int main(int argc, char *argv[])
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  //Shows the window and returns when it is closed.
  return app-&gt;make_window_and_run&lt;ExampleWindow&gt;(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"

ExampleWindow::ExampleWindow()
{
 /* Set some window properties */
  set_title("Frame Example");
  set_size_request(300, 300);

  /* Sets the margin around the frame. */
  m_Frame.set_margin(10);

  set_child(m_Frame);

  /* Set the frames label */
  m_Frame.set_label("Gtk::Frame Widget");

  /* Align the label at the right of the frame */
  m_Frame.set_label_align(Gtk::Align::END);
}

ExampleWindow::~ExampleWindow()
{
}

</pre></div>
</div>
</div>
<div class="division sect2">
<a name="sec-paned"><!--sec-paned--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">9.1.2. </span>Paned</span></h4></div>
<p class="para block block-first">
Panes divide a widget into two halves, separated by a moveable divider.
The two halves (panes) can be oriented either horizontally (side by side) or
vertically (one above the other).
</p>
<p class="para block">
Unlike the other widgets in this section, pane widgets contain not one but two
child widgets, one in each pane. Therefore, you should use
<span class="methodname" dir="ltr">set_start_child()</span> and <span class="methodname" dir="ltr">set_end_child()</span>
instead of a <span class="methodname" dir="ltr">set_child()</span> method.
</p>
<p class="para block">
You can adjust the position of the divider using the
<span class="methodname" dir="ltr">set_position()</span> method, and you will probably need to do
so.
</p>
<p class="para block"><a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Paned.html" title="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Paned.html">Reference</a></p>
<div class="autotoc"><ul><li>
<span class="label">9.1.2.1. </span><a class="xref" href="#paned-example" title="Example">Example</a>
</li></ul></div>
<div class="division sect3">
<a name="paned-example"><!--paned-example--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">9.1.2.1. </span>Example</span></h5></div>
<div class=" block figure block-first block-indent">
<a name="figure-paned"><!--figure-paned--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 9-2</span> </span>Paned</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/paned.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/paned" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/paned">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include "messageslist.h"
#include "messagetext.h"
#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:

  //Child widgets:
  Gtk::Paned m_VPaned;
  MessagesList m_MessagesList;
  MessageText m_MessageText;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">messageslist.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLE_MESSAGESLIST_H
#define GTKMM_EXAMPLE_MESSAGESLIST_H

#include &lt;gtkmm.h&gt;

class MessagesList: public Gtk::ScrolledWindow
{
public:
  MessagesList();
  virtual ~MessagesList();

  class ModelColumns : public Gtk::TreeModel::ColumnRecord
  {
  public:

    ModelColumns()
    { add(m_col_text); }

    Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_col_text;
  };

  ModelColumns m_Columns;

protected:
  Glib::RefPtr&lt;Gtk::ListStore&gt; m_refListStore; //The Tree Model.
  Gtk::TreeView m_TreeView; //The Tree View.
};
#endif //GTKMM_EXAMPLE_MESSAGESLIST_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">messagetext.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLE_MESSAGETEXT_H
#define GTKMM_EXAMPLE_MESSAGETEXT_H

#include &lt;gtkmm.h&gt;

class MessageText : public Gtk::ScrolledWindow
{
public:
  MessageText();
  virtual ~MessageText();

  void insert_text();

protected:
  Gtk::TextView m_TextView;
};

#endif //GTKMM_EXAMPLE_MESSAGETEXT_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;gtkmm/application.h&gt;

int main(int argc, char *argv[])
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  //Shows the window and returns when it is closed.
  return app-&gt;make_window_and_run&lt;ExampleWindow&gt;(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"

ExampleWindow::ExampleWindow()
: m_VPaned(Gtk::Orientation::VERTICAL)
{
  set_title ("Paned Windows");
  set_default_size(450, 400);
  m_VPaned.set_margin(10);

  /* Add a vpaned widget to our toplevel window */
  set_child(m_VPaned);

  /* Now add the contents of the two halves of the window */
  m_VPaned.set_start_child(m_MessagesList);
  m_VPaned.set_end_child(m_MessageText);
}

ExampleWindow::~ExampleWindow()
{
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">messageslist.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "messageslist.h"
#include &lt;sstream&gt;

MessagesList::MessagesList()
{
  /* Create a new scrolled window, with scrollbars only if needed */
  set_policy(Gtk::PolicyType::AUTOMATIC, Gtk::PolicyType::AUTOMATIC);

  set_child(m_TreeView);

  /* create list store */
  m_refListStore = Gtk::ListStore::create(m_Columns);

  m_TreeView.set_model(m_refListStore);

  /* Add some messages to the window */
  for(int i = 0; i &lt; 10; ++i)
  {
    std::ostringstream text;
    text &lt;&lt; "message #" &lt;&lt; i;

    auto row = *(m_refListStore-&gt;append());
    row[m_Columns.m_col_text] = text.str();
  }

  //Add the Model's column to the View's columns:
  m_TreeView.append_column("Messages", m_Columns.m_col_text);
}

MessagesList::~MessagesList()
{
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">messagetext.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "messagetext.h"

MessageText::MessageText()
{
  set_policy(Gtk::PolicyType::AUTOMATIC, Gtk::PolicyType::AUTOMATIC);

  set_child(m_TextView);
  insert_text();
}

MessageText::~MessageText()
{
}

void MessageText::insert_text()
{
  auto refTextBuffer = m_TextView.get_buffer();

  auto iter = refTextBuffer-&gt;get_iter_at_offset(0);
  refTextBuffer-&gt;insert(iter,
    "From: pathfinder@nasa.gov\n"
    "To: mom@nasa.gov\n"
    "Subject: Made it!\n"
    "\n"
    "We just got in this morning. The weather has been\n"
    "great - clear but cold, and there are lots of fun sights.\n"
    "Sojourner says hi. See you soon.\n"
    " -Path\n");
}
</pre></div>
</div>
</div>
<div class="division sect2">
<a name="sec-scrolledwindow"><!--sec-scrolledwindow--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">9.1.3. </span>ScrolledWindow</span></h4></div>
<p class="para block block-first">
<span class="classname" dir="ltr">ScrolledWindow</span> widgets create a scrollable
area. You can insert any type of widget into a
<span class="classname" dir="ltr">ScrolledWindow</span>, and it will be accessible
regardless of its size by using the scrollbars. Note that
<span class="classname" dir="ltr">ScrolledWindow</span> is not a
<span class="classname" dir="ltr">Gtk::Window</span> despite the slightly misleading name.
</p>
<p class="para block">
Scrolled windows have <span class="emphasis">scrollbar policies</span> which determine
whether the <span class="classname" dir="ltr">Scrollbar</span>s will be displayed. The policies
can be set with the <span class="methodname" dir="ltr">set_policy()</span> method. The policy may be
for instance <span class="literal" dir="ltr">Gtk::PolicyType::AUTOMATIC</span> or
<span class="literal" dir="ltr">Gtk::PolicyType::ALWAYS</span>.
<span class="literal" dir="ltr">Gtk::PolicyType::AUTOMATIC</span> will cause the scrolled window
to display the scrollbar only if the contained widget is larger than the
visible area. <span class="literal" dir="ltr">Gtk::PolicyType::ALWAYS</span> will cause the
scrollbar to be displayed always.
</p>
<p class="para block"><a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1ScrolledWindow.html" title="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1ScrolledWindow.html">Reference</a></p>
<div class="autotoc"><ul><li>
<span class="label">9.1.3.1. </span><a class="xref" href="#scrolledwindow-example" title="Example">Example</a>
</li></ul></div>
<div class="division sect3">
<a name="scrolledwindow-example"><!--scrolledwindow-example--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">9.1.3.1. </span>Example</span></h5></div>
<p class="para block block-first">
Here is a simple example that packs 100 toggle buttons into a ScrolledWindow. Try resizing the window to see the scrollbars react.
</p>
<div class=" block figure block-indent">
<a name="figure-scrolledwindow"><!--figure-scrolledwindow--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 9-3</span> </span>ScrolledWindow</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/scrolledwindow.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/scrolledwindow" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/scrolledwindow">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Dialog
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_dialog_response(int response_id);

  //Child widgets:
  Gtk::ScrolledWindow m_ScrolledWindow;
  Gtk::Grid m_Grid;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;gtkmm/application.h&gt;

int main(int argc, char *argv[])
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  //Shows the window and returns when it is closed.
  return app-&gt;make_window_and_run&lt;ExampleWindow&gt;(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;iostream&gt;

ExampleWindow::ExampleWindow()
{
  set_title("Gtk::ScrolledWindow example");
  set_size_request(300, 300);

  m_ScrolledWindow.set_margin(10);

  /* the policy is one of Gtk::PolicyType::AUTOMATIC, or Gtk::PolicyType::ALWAYS.
   * Gtk::PolicyType::AUTOMATIC will automatically decide whether you need
   * scrollbars, whereas Gtk::PolicyType::ALWAYS will always leave the scrollbars
   * there.  The first one is the horizontal scrollbar, the second,
   * the vertical. */
  m_ScrolledWindow.set_policy(Gtk::PolicyType::AUTOMATIC, Gtk::PolicyType::ALWAYS);
  m_ScrolledWindow.set_expand();

  get_content_area()-&gt;append(m_ScrolledWindow);

  /* set the spacing to 10 on x and 10 on y */
  m_Grid.set_row_spacing(10);
  m_Grid.set_column_spacing(10);

  /* pack the grid into the scrolled window */
  m_ScrolledWindow.set_child(m_Grid);

  /* this simply creates a grid of toggle buttons
   * to demonstrate the scrolled window. */
  for(int i = 0; i &lt; 10; i++)
  {
     for(int j = 0; j &lt; 10; j++)
     {
        char buffer[32];
        sprintf(buffer, "button (%d,%d)\n", i, j);
        auto pButton = Gtk::make_managed&lt;Gtk::ToggleButton&gt;(buffer);
        m_Grid.attach(*pButton, i, j, 1, 1);
     }
  }

  /* Add a "close" button to the bottom of the dialog */
  add_button("_Close", Gtk::ResponseType::CLOSE);
  signal_response().connect(sigc::mem_fun(*this, &amp;ExampleWindow::on_dialog_response));

  /* This makes it so the button is the default.
   * Simply hitting the "Enter" key will cause this button to activate. */
  set_default_response(Gtk::ResponseType::CLOSE);
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_dialog_response(int response_id)
{
  switch (response_id)
  {
  case Gtk::ResponseType::CLOSE:
  case Gtk::ResponseType::DELETE_EVENT:
    hide();
    break;
  default:
    std::cout &lt;&lt; "Unexpected response_id=" &lt;&lt; response_id &lt;&lt; std::endl;
    break;
  }
}
</pre></div>
</div>
</div>
<div class="division sect2">
<a name="sec-aspectframe"><!--sec-aspectframe--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">9.1.4. </span>AspectFrame</span></h4></div>
<p class="para block block-first">
The <span class="classname" dir="ltr">AspectFrame</span> widget looks like a
<span class="classname" dir="ltr">Frame</span> widget, but it also enforces the <span class="emphasis">aspect
    ratio</span> (the ratio of the width to the height) of the child
widget, adding extra space if necessary. For instance, this would allow you to
display a photograph without allowing the user to distort it horizontally or
vertically while resizing.
</p>
<p class="para block"><a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1AspectFrame.html" title="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1AspectFrame.html">Reference</a></p>
<div class="autotoc"><ul><li>
<span class="label">9.1.4.1. </span><a class="xref" href="#aspectframe-example" title="Example">Example</a>
</li></ul></div>
<div class="division sect3">
<a name="aspectframe-example"><!--aspectframe-example--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">9.1.4.1. </span>Example</span></h5></div>
<p class="para block block-first">
The following program uses a <span class="classname" dir="ltr">Gtk::AspectFrame</span> to present a
drawing area whose aspect ratio will always be 2:1, no matter how the user
resizes the top-level window.
</p>
<div class=" block figure block-indent">
<a name="figure-aspectframe"><!--figure-aspectframe--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 9-4</span> </span>AspectFrame</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/aspectframe.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/aspectframe" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/aspectframe">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:

  //Child widgets:
  Gtk::AspectFrame m_AspectFrame;
  Gtk::Frame m_Frame;
  Gtk::DrawingArea m_DrawingArea;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;gtkmm/application.h&gt;

int main(int argc, char *argv[])
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  //Shows the window and returns when it is closed.
  return app-&gt;make_window_and_run&lt;ExampleWindow&gt;(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"

ExampleWindow::ExampleWindow()
: m_AspectFrame(
    Gtk::Align::CENTER, /* center x */
    Gtk::Align::CENTER, /* center y */
    2.0, /* xsize/ysize = 2 */
    false /* ignore child's aspect */),
  m_Frame("2x1" /* label */)
{
  set_title("Aspect Frame");

  // Set a child widget to the aspect frame */
  // Ask for a 200x200 window, but the AspectFrame will give us a 200x100
  // window since we are forcing a 2x1 aspect ratio */
  m_DrawingArea.set_content_width(200);
  m_DrawingArea.set_content_height(200);
  m_Frame.set_child(m_DrawingArea);
  m_AspectFrame.set_child(m_Frame);
  m_AspectFrame.set_margin(10);

  // Add the aspect frame to our toplevel window:
  set_child(m_AspectFrame);
}

ExampleWindow::~ExampleWindow()
{
}

</pre></div>
</div>
</div>
<div class="division sect2">
<a name="sec-other-single-item-containers"><!--sec-other-single-item-containers--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">9.1.5. </span>Other Single-item Containers</span></h4></div>
<p class="para block block-first">
There are other single-item containers. See the reference documentation for a
complete list. Here are links to some example programs that show containers,
which are not mentioned elsewhere in this tutorial.
</p>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/expander" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/expander">Source Code, Expander</a></p>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/popover" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/popover">Source Code, Popover</a></p>
</div>
</div>
<div class="division sect1">
<a name="sec-multi-item-containers"><!--sec-multi-item-containers--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">9.2. </span>Multiple-item Containers </span></h3></div>
<p class="para block block-first">
Multiple-item container widgets have other methods than <span class="methodname" dir="ltr">set_child()</span>
and <span class="methodname" dir="ltr">unset_child()</span>. Different containers can have different
methods for adding and removing child widgets. For instance, <span class="classname" dir="ltr">Gtk::Box</span>
has <span class="methodname" dir="ltr">append()</span> and <span class="methodname" dir="ltr">remove()</span> as
well as other methods. The <span class="methodname" dir="ltr">remove()</span> method for multiple-item
containers takes an argument, specifying which widget to remove.
</p>
<div class="autotoc"><ul>
<li>
<span class="label">9.2.1. </span><a class="xref" href="#container-packing" title="Packing">Packing</a>
</li>
<li>
<span class="label">9.2.2. </span><a class="xref" href="#sec-helloworld2" title="An improved Hello World">An improved Hello World</a>
</li>
<li>
<span class="label">9.2.3. </span><a class="xref" href="#sec-boxes" title="Boxes">Boxes</a>
</li>
<li>
<span class="label">9.2.4. </span><a class="xref" href="#sec-grid" title="Grid">Grid</a>
</li>
<li>
<span class="label">9.2.5. </span><a class="xref" href="#sec-notebook" title="Notebook">Notebook</a>
</li>
<li>
<span class="label">9.2.6. </span><a class="xref" href="#sec-assistant" title="Assistant">Assistant</a>
</li>
<li>
<span class="label">9.2.7. </span><a class="xref" href="#sec-other-multi-item-containers" title="Other Multi-item Containers">Other Multi-item Containers</a>
</li>
</ul></div>
<div class="division sect2">
<a name="container-packing"><!--container-packing--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">9.2.1. </span>Packing</span></h4></div>
<p class="para block block-first">
You've probably noticed that <span class="application">gtkmm</span> windows seem "elastic" - they can usually be stretched in many  different ways. This is due to the <span class="emphasis">widget packing</span>
system.
</p>
<p class="para block">
Many GUI toolkits require you to precisely place widgets in a window, using absolute positioning, often using a visual editor. This leads to several problems:
</p>
<div class="block list itemizedlist"><ul class="itemizedlist">
<li class="li-first">
<span class="para">The widgets don't rearrange themselves when the window is resized. Some widgets are hidden when the window is made smaller, and lots of useless space appears when the window is made larger.</span>
</li>
<li>
<span class="para">It's impossible to predict the amount of space necessary for text after it has been translated to other languages, or displayed in a different font. On Unix it is also impossible to anticipate the effects of every theme and window manager.</span>
</li>
<li>
<span class="para">
Changing the layout of a window "on the fly", to make some extra widgets appear, for instance, is complex. It  requires tedious recalculation of every widget's position.</span>
</li>
</ul></div>
<p class="para block">
<span class="application">gtkmm</span> uses the packing system to solve these problems. Rather than specifying the position and size of each widget in the window,
you can arrange your widgets in rows, columns,
and/or grids. <span class="application">gtkmm</span> can size your window automatically, based on the
sizes of the widgets it contains. And the sizes of the widgets are, in turn, determined by the amount of text they contain, or the minimum and maximum sizes that you specify, and/or how you have requested that the available space should be shared between sets of widgets.
You can perfect your layout by
specifying margins and centering values for each of your widgets. <span class="application">gtkmm</span> then uses
all this information to resize and reposition everything sensibly and smoothly when the user manipulates the window. </p>
<p class="para block">
<span class="application">gtkmm</span> arranges widgets hierarchically, using <span class="emphasis">containers</span>.
A container widget contains other widgets. Most <span class="application">gtkmm</span> widgets are
containers. Windows, Notebook tabs, and Buttons are all container widgets.
There are two flavours of containers: single-child containers and multiple-child
containers. Most container widgets in <span class="application">gtkmm</span> are single-child containers,
including <span class="classname" dir="ltr">Gtk::Window</span>.
</p>
<p class="para block">
Yes, that's correct: a Window can contain at most one widget. How, then, can
we use a window for anything useful?  By placing a multiple-child container in
the window. The most useful container widgets are
<span class="classname" dir="ltr">Gtk::Grid</span> and <span class="classname" dir="ltr">Gtk::Box</span>.
</p>
<div class="block list itemizedlist"><ul class="itemizedlist">
<li class="li-first">
<span class="para">
<span class="classname" dir="ltr">Gtk::Grid</span> arranges its child widgets in rows and
columns. Use <span class="methodname" dir="ltr">attach()</span> and
<span class="methodname" dir="ltr">attach_next_to()</span> to insert child widgets.
</span>
</li>
<li>
<span class="para">
<span class="classname" dir="ltr">Gtk::Box</span> arranges its child widgets vertically or horizontally.
Use <span class="methodname" dir="ltr">append()</span> to insert child widgets.
</span>
</li>
</ul></div>
<p class="para block">
 There are several other containers, which we will also discuss.
</p>
<p class="para block">
If you've never used a packing toolkit before, it can take some
getting used to. You'll probably find, however, that you don't
need to rely on visual form editors quite as much as you might with
other toolkits.
</p>
</div>
<div class="division sect2">
<a name="sec-helloworld2"><!--sec-helloworld2--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">9.2.2. </span>An improved Hello World</span></h4></div>
<p class="para block block-first">
Let's take a look at a slightly improved <span class="literal" dir="ltr">helloworld</span>, showing what we've learnt.
</p>
<div class=" block figure block-indent">
<a name="figure-helloworld2"><!--figure-helloworld2--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 9-5</span> </span>Hello World 2</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/helloworld2.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/helloworld2" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/helloworld2">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">helloworld.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLE_HELLOWORLD_H
#define GTKMM_EXAMPLE_HELLOWORLD_H

#include &lt;gtkmm/box.h&gt;
#include &lt;gtkmm/button.h&gt;
#include &lt;gtkmm/window.h&gt;

class HelloWorld : public Gtk::Window
{
public:
  HelloWorld();
  ~HelloWorld() override;

protected:

  // Signal handlers:
  // Our new improved on_button_clicked().
  void on_button_clicked(const Glib::ustring&amp; data);

  // Child widgets:
  Gtk::Box m_box1;
  Gtk::Button m_button1, m_button2;
};

#endif // GTKMM_EXAMPLE_HELLOWORLD_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "helloworld.h"
#include &lt;gtkmm/application.h&gt;

int main(int argc, char* argv[])
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  //Shows the window and returns when it is closed.
  return app-&gt;make_window_and_run&lt;HelloWorld&gt;(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">helloworld.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "helloworld.h"
#include &lt;iostream&gt;

HelloWorld::HelloWorld()
: m_button1("Button 1"),
  m_button2("Button 2")
{
  // This just sets the title of our new window.
  set_title("Hello Buttons!");

  // Sets the margin around the box.
  m_box1.set_margin(10);

  // put the box into the main window.
  set_child(m_box1);

  // Now when the button is clicked, we call the on_button_clicked() function
  // with a pointer to "button 1" as its argument.
  m_button1.signal_clicked().connect(sigc::bind(
              sigc::mem_fun(*this, &amp;HelloWorld::on_button_clicked), "button 1"));

  // We use Gtk::Box::append() to pack this button into the box,
  // which has been packed into the window.
  // A widget's default behaviour is not to expand if extra space is available.
  // A container widget by default expands if any of the contained widgets
  // wants to expand.
  m_box1.append(m_button1);
  m_button1.set_expand();

  // call the same signal handler with a different argument,
  // passing a pointer to "button 2" instead.
  m_button2.signal_clicked().connect(sigc::bind(
              sigc::mem_fun(*this, &amp;HelloWorld::on_button_clicked), "button 2"));

  m_box1.append(m_button2);
  m_button2.set_expand();

  // Gtk::Widget::show() is seldom needed. All widgets are visible by default.
}

HelloWorld::~HelloWorld()
{
}

// Our new improved signal handler.  The data passed to this method is
// printed to stdout.
void HelloWorld::on_button_clicked(const Glib::ustring&amp; data)
{
  std::cout &lt;&lt; "Hello World - " &lt;&lt; data &lt;&lt; " was pressed" &lt;&lt; std::endl;
}

</pre></div>
<p class="para block">
After building and running this program, try resizing the window to see the
behaviour. Also, try playing with <span class="methodname" dir="ltr">set_expand()</span>,
<span class="methodname" dir="ltr">set_hexpand()</span>, <span class="methodname" dir="ltr">set_vexpand()</span>,
<span class="methodname" dir="ltr">set_halign()</span> and <span class="methodname" dir="ltr">set_valign()</span>
while reading the <a class="link" href="#sec-boxes" title="Boxes">Boxes</a> section.
</p>
</div>
<div class="division sect2">
<a name="sec-boxes"><!--sec-boxes--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">9.2.3. </span>Boxes</span></h4></div>
<p class="para block block-first">
Most packing uses boxes as in the above example. These
are invisible containers into which we can pack our widgets. When
packing widgets into a horizontal box, the objects are inserted
horizontally from left to right. In a vertical box, widgets are packed from
top to bottom. You may use any combination of boxes inside or beside other
boxes to create the desired effect.
</p>
<div class="autotoc"><ul>
<li>
<span class="label">9.2.3.1. </span><a class="xref" href="#boxes-adding-widgets" title="Adding widgets">Adding widgets</a>
</li>
<li>
<span class="label">9.2.3.2. </span><a class="xref" href="#boxes-command-line-options" title="Gtk::Application and command-line options">Gtk::Application and command-line options</a>
</li>
<li>
<span class="label">9.2.3.3. </span><a class="xref" href="#box-packing-example" title="Example">Example</a>
</li>
</ul></div>
<div class="division sect3">
<a name="boxes-adding-widgets"><!--boxes-adding-widgets--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">9.2.3.1. </span>Adding widgets</span></h5></div>
<div class="autotoc"><ul>
<li>
<span class="label">9.2.3.1.1. </span><a class="xref" href="#per-child-packing-options" title="Per-child packing options">Per-child packing options</a>
</li>
<li>
<span class="label">9.2.3.1.2. </span><a class="xref" href="#per-container-packing-options" title="Per-container packing options">Per-container packing options</a>
</li>
</ul></div>
<div class="division sect4">
<a name="per-child-packing-options"><!--per-child-packing-options--></a><div class="header"><h6 class="sect4 title"><span class="title"><span class="label">9.2.3.1.1. </span>Per-child packing options</span></h6></div>
<p class="para block block-first">
The <span class="methodname" dir="ltr">append()</span> method places widgets inside these
containers. It will start at the top and work its way down in a
<span class="classname" dir="ltr">Box</span> with vertical orientation, or pack left to right in
a <span class="classname" dir="ltr">Box</span> with horizontal orientation. If it's inconvenient
to add widgets in this order, use <span class="methodname" dir="ltr">insert_child_after()</span>
or <span class="methodname" dir="ltr">insert_child_at_start()</span>. We will use
<span class="methodname" dir="ltr">append()</span> in our examples.
</p>
<p class="para block">
There are several options governing how widgets are to be packed, and this can
be confusing at first. You can modify the packing by using <span class="methodname" dir="ltr">set_expand()</span>,
<span class="methodname" dir="ltr">set_hexpand()</span>, <span class="methodname" dir="ltr">set_vexpand()</span>,
<span class="methodname" dir="ltr">set_halign()</span>, <span class="methodname" dir="ltr">set_valign()</span>
and/or <span class="methodname" dir="ltr">set_margin()</span> on the child widgets. If you have
difficulties, then it is sometimes a good idea to play with the
<span class="application">glade</span> GUI designer to see what is possible.
You might even decide to use the <span class="classname" dir="ltr">Gtk::Builder</span>
API to load your GUI at runtime.
</p>
<p class="para block">
There are basically five
different styles, as shown in this picture:
</p>
<div class=" block figure block-indent">
<a name="figure-box-packing1"><!--figure-box-packing1--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 9-6</span> </span>Box Packing 1</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/box_packing1.png.en"></div>
  </div>
</div>
</div>
<p class="para block">
Each line contains one horizontal <span class="classname" dir="ltr">Box</span> with
several buttons. Each of the buttons on a line is packed into the
<span class="classname" dir="ltr">Box</span> with the same arguments to the
<span class="methodname" dir="ltr">set_hexpand()</span>, <span class="methodname" dir="ltr">set_halign()</span>,
<span class="methodname" dir="ltr">set_margin_start()</span> and <span class="methodname" dir="ltr">set_margin_end()</span>
methods.
</p>
<p class="para block"><a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Box.html" title="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Box.html">Reference</a></p>
</div>
<div class="division sect4">
<a name="per-container-packing-options"><!--per-container-packing-options--></a><div class="header"><h6 class="sect4 title"><span class="title"><span class="label">9.2.3.1.2. </span>Per-container packing options</span></h6></div>
<p class="para block block-first">
Here's the constructor for the <span class="classname" dir="ltr">Box</span> widget,
and methods that set per-container packing options:
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">Gtk::Box(Gtk::Orientation orientation = Gtk::Orientation::HORIZONTAL, int spacing = 0);
void set_orientation(Gtk::Orientation orientation);
void set_spacing(int spacing);
void set_homogeneous(bool homogeneous = true);</pre></div>
Passing <span class="literal" dir="ltr">true</span> to <span class="methodname" dir="ltr">set_homogeneous()</span> will
cause all of the contained widgets to be the same size.
<span class="parameter" dir="ltr">spacing</span> is a (minimum) number of pixels to leave between
each widget.
</p>
<p class="para block">
What's the difference between spacing (set when the box is created)
and margins (set separately for each child widget)? Spacing is added between
objects, and margins are added on one or more sides of a widget. The following
figure should make it clearer. The shown margins are the left and right margins
of each button in the row.
</p>
<div class=" block figure block-indent">
<a name="figure-box-packing2"><!--figure-box-packing2--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 9-7</span> </span>Box Packing 2</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/box_packing2.png.en"></div>
  </div>
</div>
</div>
</div>
</div>
<div class="division sect3">
<a name="boxes-command-line-options"><!--boxes-command-line-options--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">9.2.3.2. </span>Gtk::Application and command-line options</span></h5></div>
<p class="para block block-first">The following example program requires a command-line option.
The source code shows two ways of handling command-line options in combination
with <span class="classname" dir="ltr">Gtk::Application</span>.
</p>
<div class="block list itemizedlist"><ul class="itemizedlist">
<li class="li-first"><p class="para block block-first">
Handle the options in <span class="function">main()</span> and hide them from
<span class="classname" dir="ltr">Gtk::Application</span> by setting <span class="literal" dir="ltr">argc = 1</span>
in the call to <span class="methodname" dir="ltr">Gtk::Application::run()</span>.
</p></li>
<li>
<p class="para block block-first">
Give all command-line options to <span class="methodname" dir="ltr">Gtk::Application::run()</span>
and add the flag <span class="literal" dir="ltr">Gio::Application::Flags::HANDLES_COMMAND_LINE</span>
to <span class="methodname" dir="ltr">Gtk::Application::create()</span>.
Connect a signal handler to the <span class="literal" dir="ltr">command_line</span> signal, and
handle the command-line options in the signal handler.</p>

<p class="para block">You must set the optional parameter <span class="literal" dir="ltr">after = false</span> in
the call to <span class="literal" dir="ltr">signal_command_line().connect()</span>, because your signal
handler must be called before the default signal handler. You must also call
<span class="methodname" dir="ltr">Gio::Application::activate()</span> in the signal handler,
unless you want your application to exit without showing its main window.
(<span class="classname" dir="ltr">Gio::Application</span> is a base class of
<span class="classname" dir="ltr">Gtk::Application</span>.)
</p>
</li>
</ul></div>
</div>
<div class="division sect3">
<a name="box-packing-example"><!--box-packing-example--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">9.2.3.3. </span>Example</span></h5></div>
<p class="para block block-first">
Here is the source code for the example that produced the screenshots above. When you run this example, provide a number between 1 and 3 as a command-line option, to see different packing options in use.</p>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/box" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/box">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow(int which);
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_button_quit_clicked();

  //Child widgets:
  Gtk::Button m_button;
  Gtk::Box m_box1;
  Gtk::Box m_boxQuit;
  Gtk::Button m_buttonQuit;

  Gtk::Label m_Label1, m_Label2;

  Gtk::Separator m_separator1, m_separator2;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">packbox.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLE_PACKBOX_H
#define GTKMM_EXAMPLE_PACKBOX_H

#include &lt;gtkmm.h&gt;

class PackBox : public Gtk::Box
{
public:
  PackBox(bool homogeneous = false, int spacing = 0, bool expand = false,
    Gtk::Align align = Gtk::Align::FILL, int margin = 0);

protected:
  Gtk::Button m_buttons[4];
};

#endif //GTKMM_EXAMPLE_PACKBOX_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;gtkmm/application.h&gt;
#include &lt;iostream&gt;
#include &lt;cstdlib&gt;

#define GTK_APPLICATION_RECEIVES_COMMAND_LINE_ARGUMENTS 0

#if GTK_APPLICATION_RECEIVES_COMMAND_LINE_ARGUMENTS
namespace
{
int on_command_line(const Glib::RefPtr&lt;Gio::ApplicationCommandLine&gt;&amp; command_line,
                    Glib::RefPtr&lt;Gtk::Application&gt;&amp; app)
{
  int argc = 0;
  char** argv = command_line-&gt;get_arguments(argc);

  for (int i = 0; i &lt; argc; ++i)
    std::cout &lt;&lt; "argv[" &lt;&lt; i &lt;&lt; "] = " &lt;&lt; argv[i] &lt;&lt; std::endl;

  app-&gt;activate(); // Without activate() the window won't be shown.
  return EXIT_SUCCESS;
}
} // anonymous namespace
#endif


int main(int argc, char *argv[])
{
  if (argc != 2)
  {
    std::cerr &lt;&lt; "Usage: example &lt;num&gt;, where &lt;num&gt; is 1, 2, or 3." &lt;&lt; std::endl;
    return EXIT_FAILURE;
  }

  int argc1 = argc;

#if GTK_APPLICATION_RECEIVES_COMMAND_LINE_ARGUMENTS
  // The Gio::Application::Flags::HANDLES_COMMAND_LINE flag and the
  // on_command_line() signal handler are not necessary. This program is simpler
  // without them, and with argc = 1 in the call to Gtk::Application::make_window_and_run().
  // They are included to show a program with Gio::Application::Flags::HANDLES_COMMAND_LINE.
  // Gio::Application::Flags::NON_UNIQUE makes it possible to run several instances of
  // this application simultaneously.
  auto app = Gtk::Application::create(
    "org.gtkmm.example", Gio::Application::Flags::HANDLES_COMMAND_LINE | Gio::Application::Flags::NON_UNIQUE);

  // Note after = false.
  // Only one signal handler is invoked. This signal handler must run before
  // the default signal handler, or else it won't run at all.
  app-&gt;signal_command_line().connect(sigc::bind(sigc::ptr_fun(&amp;on_command_line), app), false);
#else
  // Gio::Application::Flags::NON_UNIQUE makes it possible to run several instances of
  // this application simultaneously.
  argc1 = 1; // Don't give the command line arguments to Gtk::Application.
  auto app = Gtk::Application::create("org.gtkmm.example", Gio::Application::Flags::NON_UNIQUE);
#endif

  // Shows the window and returns when it is closed.
  return app-&gt;make_window_and_run&lt;ExampleWindow&gt;(argc1, argv, std::atoi(argv[1]));
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include &lt;iostream&gt;
#include "examplewindow.h"
#include "packbox.h"

ExampleWindow::ExampleWindow(int which)
: m_box1(Gtk::Orientation::VERTICAL),
  m_buttonQuit("Quit")
{
  set_title("Gtk::Box example");

  m_separator1.set_margin_top(5);
  m_separator1.set_margin_bottom(5);
  m_separator2.set_margin_top(5);
  m_separator2.set_margin_bottom(5);

  switch(which)
  {
    case 1:
    {
      m_Label1.set_text("Gtk::Box(Gtk::Orientation::HORIZONTAL, 0); set_homogeneous(false);");

      // Align the label to the left side.
      m_Label1.set_halign(Gtk::Align::START);
      m_Label1.set_valign(Gtk::Align::START);

      // Pack the label into the vertical box (vbox box1).  Remember that
      // widgets added to a vbox will be packed one on top of the other in
      // order.
      m_box1.append(m_Label1);

      // Create a PackBox - homogeneous = false, spacing = 0,
      // expand = false, Gtk::Align::FILL, margin = 0
      // These are the default values.
      auto pPackBox = Gtk::make_managed&lt;PackBox&gt;();
      m_box1.append(*pPackBox);

      // Create a PackBox - homogeneous = false, spacing = 0,
      // expand = true, Gtk::Align::CENTER, margin = 0
      pPackBox = Gtk::make_managed&lt;PackBox&gt;(false, 0, true, Gtk::Align::CENTER);
      m_box1.append(*pPackBox);

      // Create a PackBox - homogeneous = false, spacing = 0,
      // expand = true, Gtk::Align::FILL, margin = 0
      pPackBox = Gtk::make_managed&lt;PackBox&gt;(false, 0, true);
      m_box1.append(*pPackBox);

      // pack the separator into the vbox.  Remember each of these
      // widgets are being packed into a vbox, so they'll be stacked
      // vertically.
      m_box1.append(m_separator1);

      // create another new label, and show it.
      m_Label2.set_text("Gtk::Box(Gtk::Orientation::HORIZONTAL, 0); set_homogeneous(true);");
      m_Label2.set_halign(Gtk::Align::START);
      m_Label2.set_valign(Gtk::Align::START);
      m_box1.append(m_Label2);

      // Args are: homogeneous, spacing, expand, align, margin
      pPackBox = Gtk::make_managed&lt;PackBox&gt;(true, 0, true, Gtk::Align::CENTER);
      m_box1.append(*pPackBox);

      // Args are: homogeneous, spacing, expand, align, margin
      pPackBox = Gtk::make_managed&lt;PackBox&gt;(true, 0, true);
      m_box1.append(*pPackBox);

      m_box1.append(m_separator2);

      break;
    }

    case 2:
    {
      m_Label1.set_text("Gtk::Box(Gtk::Orientation::HORIZONTAL, 10); set_homogeneous(false);");
      m_Label1.set_halign(Gtk::Align::START);
      m_Label1.set_valign(Gtk::Align::START);
      m_box1.append(m_Label1);

      auto pPackBox = Gtk::make_managed&lt;PackBox&gt;(false, 10, true, Gtk::Align::CENTER);
      m_box1.append(*pPackBox);

      pPackBox = Gtk::make_managed&lt;PackBox&gt;(false, 10, true);
      m_box1.append(*pPackBox);

      m_box1.append(m_separator1);

      m_Label2.set_text("Gtk::Box(Gtk::Orientation::HORIZONTAL, 0); set_homogeneous(false);");
      m_Label2.set_halign(Gtk::Align::START);
      m_Label2.set_valign(Gtk::Align::START);
      m_box1.append(m_Label2);

      pPackBox = Gtk::make_managed&lt;PackBox&gt;(false, 0, false, Gtk::Align::FILL, 10);
      m_box1.append(*pPackBox);

      pPackBox = Gtk::make_managed&lt;PackBox&gt;(false, 0, true, Gtk::Align::FILL, 10);
      m_box1.append(*pPackBox);

      m_box1.append(m_separator2);

      break;
    }

    case 3:
    {
      // This demonstrates the ability to use Gtk::Align::END to
      // right justify widgets.  First, we create a new box as before.
      auto pPackBox = Gtk::make_managed&lt;PackBox&gt;();

      // create the label that will be put at the end.
      m_Label1.set_text("end");

      // pack it using Gtk::Align::END, so it is put on the right side
      // of the PackBox.
      m_Label1.set_halign(Gtk::Align::END);
      m_Label1.set_hexpand(true);
      pPackBox-&gt;append(m_Label1);

      m_box1.append(*pPackBox);

      // This explicitly sets the separator to 700 pixels wide by 5 pixels
      // high.  This is so the hbox we created will also be 700 pixels wide,
      // and the "end" label will be separated from the other labels in the
      // hbox.  Otherwise, all the widgets in the hbox would be packed as
      // close together as possible.
      m_separator1.set_size_request(700, 5);

      // pack the separator into the vbox.
      m_box1.append(m_separator1);

      break;
    }

    default:
    {
      std::cerr &lt;&lt; "Unexpected command-line option." &lt;&lt; std::endl;
      break;
    }
  }

  // Connect the signal to hide the window:
  m_buttonQuit.signal_clicked().connect( sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_quit_clicked) );

  // pack the button into the quitbox.
  m_boxQuit.append(m_buttonQuit);
  m_buttonQuit.set_hexpand(true);
  m_buttonQuit.set_halign(Gtk::Align::CENTER);
  m_box1.append(m_boxQuit);

  // pack the vbox (box1) which now contains all our widgets, into the
  // main window.
  set_child(m_box1);
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_button_quit_clicked()
{
  hide();
}

</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">packbox.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "packbox.h"
#include &lt;map&gt;

namespace
{
  const std::map&lt;Gtk::Align, Glib::ustring&gt; align_string = {
    {Gtk::Align::FILL, "Gtk::Align::FILL"},
    {Gtk::Align::START, "Gtk::Align::START"},
    {Gtk::Align::END, "Gtk::Align::END"},
    {Gtk::Align::CENTER, "Gtk::Align::CENTER"},
    {Gtk::Align::BASELINE, "Gtk::Align::BASELINE"},
  };
}

PackBox::PackBox(bool homogeneous, int spacing, bool expand, Gtk::Align align, int margin)
: Gtk::Box(Gtk::Orientation::HORIZONTAL, spacing)
{
  set_homogeneous(homogeneous);

  m_buttons[0].set_label("box.append(button);");
  m_buttons[1].set_label("expand=" + Glib::ustring(expand ? "true" : "false"));
  m_buttons[2].set_label(align_string.at(align));
  m_buttons[3].set_label("margin=" + Glib::ustring::format(margin));

  for (auto&amp; button : m_buttons)
  {
    append(button);
    button.set_hexpand(expand);
    button.set_halign(align);
    button.set_margin_start(margin);
    button.set_margin_end(margin);
  }
}
</pre></div>
</div>
</div>
<div class="division sect2">
<a name="sec-grid"><!--sec-grid--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">9.2.4. </span>Grid</span></h4></div>
<p class="para block block-first">
A <span class="classname" dir="ltr">Grid</span> dynamically lays out child widgets in rows and
columns. The dimensions of the grid do not need to be specified in the constructor.
</p>
<p class="para block">
Child widgets can span multiple rows or columns, using
<span class="methodname" dir="ltr">attach()</span>, or added next to an existing widget inside
the grid with <span class="methodname" dir="ltr">attach_next_to()</span>. Individual rows and columns of the grid can be set to have uniform height or width with
<span class="methodname" dir="ltr">set_row_homogeneous()</span> and
<span class="methodname" dir="ltr">set_column_homogeneous()</span>.
</p>
<p class="para block">You can set the <span class="emphasis">margin</span> and <span class="emphasis">expand</span> properties of the
child <span class="classname" dir="ltr">Widget</span>s to control their spacing and their behaviour when the Grid is resized.
</p>
<p class="para block"><a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Grid.html" title="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Grid.html">Reference</a></p>
<div class="autotoc"><ul><li>
<span class="label">9.2.4.1. </span><a class="xref" href="#grid-example" title="Example">Example</a>
</li></ul></div>
<div class="division sect3">
<a name="grid-example"><!--grid-example--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">9.2.4.1. </span>Example</span></h5></div>
<p class="para block block-first">
This example creates a window with three buttons in a grid.
The first two buttons are in the upper row, from left to right. A
third button is attached underneath the first button, in a new lower row,
spanning two columns.
</p>
<div class=" block figure block-indent">
<a name="figure-grid"><!--figure-grid--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 9-8</span> </span>Grid</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/grid.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/grid" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/grid">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

private:
  // Signal handlers:
  void on_button_quit();
  void on_button_numbered(const Glib::ustring&amp; data);

  // Child widgets:
  Gtk::Grid m_grid;
  Gtk::Button m_button_1, m_button_2, m_button_quit;
};

#endif /* GTKMM_EXAMPLEWINDOW_H */
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;gtkmm/application.h&gt;

int main(int argc, char *argv[])
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  // Shows the window and returns when it is closed.
  return app-&gt;make_window_and_run&lt;ExampleWindow&gt;(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include &lt;iostream&gt;
#include "examplewindow.h"

ExampleWindow::ExampleWindow()
: m_button_1("button 1"),
  m_button_2("button 2"),
  m_button_quit("Quit")
{
  set_title("Gtk::Grid");

  m_grid.set_margin(12);
  set_child(m_grid);

  m_grid.attach(m_button_1, 0, 0);
  m_grid.attach(m_button_2, 1, 0);
  m_grid.attach_next_to(m_button_quit, m_button_1, Gtk::PositionType::BOTTOM, 2, 1);

  m_button_1.signal_clicked().connect(
    sigc::bind( sigc::mem_fun(*this, &amp;ExampleWindow::on_button_numbered), "button 1") );
  m_button_2.signal_clicked().connect(
    sigc::bind( sigc::mem_fun(*this, &amp;ExampleWindow::on_button_numbered), "button 2") );

  m_button_quit.signal_clicked().connect(sigc::mem_fun(*this,
    &amp;ExampleWindow::on_button_quit) );
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_button_quit()
{
  hide();
}

void
ExampleWindow::on_button_numbered(const Glib::ustring&amp; data)
{
  std::cout &lt;&lt; data &lt;&lt; " was pressed" &lt;&lt; std::endl;
}
</pre></div>
</div>
</div>
<div class="division sect2">
<a name="sec-notebook"><!--sec-notebook--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">9.2.5. </span>Notebook</span></h4></div>
<p class="para block block-first">
A <span class="classname" dir="ltr">Notebook</span> has a set of stacked
<span class="literal" dir="ltr">pages</span>, each of which contains widgets. Labelled
<span class="literal" dir="ltr">tabs</span> allow the user to select the pages.
<span class="classname" dir="ltr">Notebook</span>s allow several sets of widgets to be placed in a
small space, by only showing one page at a time. For instance, they are often
used in preferences dialogs.
</p>
<p class="para block">
Use the <span class="methodname" dir="ltr">append_page()</span>, <span class="methodname" dir="ltr">prepend_page()</span>
and <span class="methodname" dir="ltr">insert_page()</span> methods to add tabbed pages to the
<span class="literal" dir="ltr">Notebook</span>, supplying the child widget and the name for the
tab.
</p>
<p class="para block">
To discover the currently visible page, use the
<span class="methodname" dir="ltr">get_current_page()</span> method. This returns the page number,
and then calling <span class="methodname" dir="ltr">get_nth_page()</span> with that number will give
you a pointer to the actual child widget.
</p>
<p class="para block">
To programmatically change the selected page, use the
<span class="methodname" dir="ltr">set_current_page()</span> method.
</p>
<p class="para block"><a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Notebook.html" title="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Notebook.html">Reference</a></p>
<div class="autotoc"><ul><li>
<span class="label">9.2.5.1. </span><a class="xref" href="#notebook-example" title="Example">Example</a>
</li></ul></div>
<div class="division sect3">
<a name="notebook-example"><!--notebook-example--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">9.2.5.1. </span>Example</span></h5></div>
<div class=" block figure block-first block-indent">
<a name="figure-notebook"><!--figure-notebook--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 9-9</span> </span>Notebook</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/notebook.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/notebook/" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/notebook/">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_button_quit();
  void on_notebook_switch_page(Gtk::Widget* page, guint page_num);

  //Child widgets:
  Gtk::Box m_VBox;
  Gtk::Notebook m_Notebook;
  Gtk::Label m_Label1, m_Label2;

  Gtk::Box m_ButtonBox;
  Gtk::Button m_Button_Quit;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;gtkmm/application.h&gt;

int main(int argc, char *argv[])
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  //Shows the window and returns when it is closed.
  return app-&gt;make_window_and_run&lt;ExampleWindow&gt;(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include &lt;iostream&gt;
#include "examplewindow.h"

ExampleWindow::ExampleWindow()
: m_VBox(Gtk::Orientation::VERTICAL),
  m_Label1("Contents of tab 1"),
  m_Label2("Contents of tab 2"),
  m_Button_Quit("Quit")
{
  set_title("Gtk::Notebook example");
  set_default_size(400, 200);

  m_VBox.set_margin(10);
  set_child(m_VBox);

  //Add the Notebook, with the button underneath:
  m_Notebook.set_margin(10);
  m_Notebook.set_expand();
  m_VBox.append(m_Notebook);
  m_VBox.append(m_ButtonBox);

  m_ButtonBox.append(m_Button_Quit);
  m_Button_Quit.set_hexpand(true);
  m_Button_Quit.set_halign(Gtk::Align::CENTER);
  m_Button_Quit.signal_clicked().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_quit) );

  //Add the Notebook pages:
  m_Notebook.append_page(m_Label1, "First");
  m_Notebook.append_page(m_Label2, "Second");

  m_Notebook.signal_switch_page().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_notebook_switch_page) );
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_button_quit()
{
  hide();
}

void ExampleWindow::on_notebook_switch_page(Gtk::Widget* /* page */, guint page_num)
{
  std::cout &lt;&lt; "Switched to tab with index " &lt;&lt; page_num &lt;&lt; std::endl;

  //You can also use m_Notebook.get_current_page() to get this index.
}
</pre></div>
</div>
</div>
<div class="division sect2">
<a name="sec-assistant"><!--sec-assistant--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">9.2.6. </span>Assistant</span></h4></div>
<p class="para block block-first">
An <span class="classname" dir="ltr">Assistant</span> splits a complex operation into steps. Each step is a page, containing a header, a child widget and an action area. The Assistant's action area has navigation buttons which update automatically depending on the type of the page, set with <span class="methodname" dir="ltr">set_page_type()</span>.
</p>
<p class="para block">
Use the <span class="methodname" dir="ltr">append_page()</span>, <span class="methodname" dir="ltr">prepend_page</span> and <span class="methodname" dir="ltr">insert_page()</span> methods to add pages to the <span class="classname" dir="ltr">Assistant</span>, supplying the child widget for each page.
</p>
<p class="para block">
To determine the currently-visible page, use the <span class="methodname" dir="ltr">get_current_page()</span> method, and pass the result to <span class="methodname" dir="ltr">get_nth_page()</span>, which returns a pointer to the actual widget. To programmatically change the current page, use the <span class="methodname" dir="ltr">set_current_page()</span> method.
</p>
<p class="para block">
To set the title of a page, use the <span class="methodname" dir="ltr">set_page_title()</span> method.
</p>
<p class="para block">
To add widgets to the action area, use the <span class="methodname" dir="ltr">add_action_widget()</span> method. They will be packed alongside the default buttons. Use the <span class="methodname" dir="ltr">remove_action_widget()</span> method to remove widgets.
</p>
<p class="para block"><a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Assistant.html" title="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Assistant.html">Reference</a></p>
<div class="autotoc"><ul><li>
<span class="label">9.2.6.1. </span><a class="xref" href="#assistant-example" title="Example">Example</a>
</li></ul></div>
<div class="division sect3">
<a name="assistant-example"><!--assistant-example--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">9.2.6.1. </span>Example</span></h5></div>
<div class=" block figure block-first block-indent">
<a name="figure-assistant"><!--figure-assistant--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 9-10</span> </span>Assistant</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/assistant.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/assistant/" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/assistant/">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include "exampleassistant.h"
#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

private:
  // Signal handlers:
  void on_button_clicked();
  void on_assistant_apply();

  // Child widgets:
  Gtk::Grid m_grid;
  Gtk::Button m_button;
  Gtk::Label m_label1, m_label2;
  Gtk::CheckButton m_check;
  Gtk::Entry m_entry;
  ExampleAssistant m_assistant;
};

#endif /* GTKMM_EXAMPLEWINDOW_H */
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">exampleassistant.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEASSISTANT_H
#define GTKMM_EXAMPLEASSISTANT_H

#include &lt;gtkmm.h&gt;

class ExampleAssistant : public Gtk::Assistant
{
public:
  ExampleAssistant();
  virtual ~ExampleAssistant();

  void get_result(bool&amp; check_state, Glib::ustring&amp; entry_text);

private:
  // Signal handlers:
  void on_assistant_apply();
  void on_assistant_cancel();
  void on_assistant_close();
  void on_assistant_prepare(Gtk::Widget* widget);
  void on_entry_changed();

  // Member functions:
  void print_status();

  // Child widgets:
  Gtk::Box m_box;
  Gtk::Label m_label1, m_label2;
  Gtk::CheckButton m_check;
  Gtk::Entry m_entry;
};

#endif /* GTKMM_EXAMPLEASSISTANT_H */
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;gtkmm/application.h&gt;

int main(int argc, char *argv[])
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  // Shows the window and returns when it is closed.
  return app-&gt;make_window_and_run&lt;ExampleWindow&gt;(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include "exampleassistant.h"

ExampleWindow::ExampleWindow()
: m_button("Show the assistant"),
  m_label1("State of assistant checkbutton:", Gtk::Align::START, Gtk::Align::CENTER),
  m_label2("Contents of assistant entry:", Gtk::Align::START, Gtk::Align::CENTER)
{
  set_title("Gtk::Assistant example");

  m_grid.set_row_homogeneous(true);
  m_grid.set_column_spacing(5);
  m_grid.set_margin(12);

  m_grid.attach(m_button, 0, 0, 2, 1);
  m_button.set_hexpand(true);
  m_button.set_valign(Gtk::Align::CENTER);

  m_grid.attach(m_label1, 0, 1, 1, 1);

  m_grid.attach(m_label2, 0, 2, 1, 1);

  m_grid.attach(m_check, 1, 1, 1, 1);
  m_check.set_halign(Gtk::Align::START);

  m_grid.attach(m_entry, 1, 2, 1, 1);
  m_entry.set_hexpand(true);

  set_child(m_grid);

  m_button.signal_clicked().connect(sigc::mem_fun(*this,
    &amp;ExampleWindow::on_button_clicked));
  m_assistant.signal_apply().connect(sigc::mem_fun(*this,
    &amp;ExampleWindow::on_assistant_apply));

  m_check.set_sensitive(false);
  m_entry.set_sensitive(false);
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_assistant_apply()
{
  bool check_state;
  Glib::ustring entry_text;

  m_assistant.get_result(check_state, entry_text);
  m_check.set_active(check_state);
  m_entry.set_text(entry_text);
}

void ExampleWindow::on_button_clicked()
{
  m_assistant.show();
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">exampleassistant.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include &lt;iostream&gt;
#include "exampleassistant.h"

ExampleAssistant::ExampleAssistant()
: m_box(Gtk::Orientation::HORIZONTAL, 12),
  m_label1("Type text to allow the assistant to continue:"),
  m_label2("Confirmation page"),
  m_check("Optional extra information")
{
  set_title("Gtk::Assistant example");
  set_default_size(400, 200);

  m_box.append(m_label1);
  m_box.append(m_entry);
  m_label1.set_wrap();
  m_label1.set_valign(Gtk::Align::CENTER);
  m_entry.set_valign(Gtk::Align::CENTER);

  append_page(m_box);
  append_page(m_check);
  append_page(m_label2);

  set_page_title(*get_nth_page(0), "Page 1");
  set_page_title(*get_nth_page(1), "Page 2");
  set_page_title(*get_nth_page(2), "Confirmation");

  set_page_complete(m_check, true);
  set_page_complete(m_label2, true);

  set_page_type(m_box, Gtk::AssistantPage::Type::INTRO);
  set_page_type(m_label2, Gtk::AssistantPage::Type::CONFIRM);

  signal_apply().connect(sigc::mem_fun(*this,
    &amp;ExampleAssistant::on_assistant_apply));
  signal_cancel().connect(sigc::mem_fun(*this,
    &amp;ExampleAssistant::on_assistant_cancel));
  signal_close().connect(sigc::mem_fun(*this,
    &amp;ExampleAssistant::on_assistant_close));
  signal_prepare().connect(sigc::mem_fun(*this,
    &amp;ExampleAssistant::on_assistant_prepare));

  m_entry.signal_changed().connect(sigc::mem_fun(*this,
    &amp;ExampleAssistant::on_entry_changed));
}

ExampleAssistant::~ExampleAssistant()
{
}

void ExampleAssistant::get_result(bool&amp; check_state, Glib::ustring&amp; entry_text)
{
  check_state = m_check.get_active();
  entry_text = m_entry.get_text();
}

void ExampleAssistant::on_assistant_apply()
{
  std::cout &lt;&lt; "Apply was clicked";
  print_status();
}

void ExampleAssistant::on_assistant_cancel()
{
  std::cout &lt;&lt; "Cancel was clicked";
  print_status();
  hide();
}

void ExampleAssistant::on_assistant_close()
{
  std::cout &lt;&lt; "Assistant was closed";
  print_status();
  hide();
}

void ExampleAssistant::on_assistant_prepare(Gtk::Widget* /* widget */)
{
  set_title(Glib::ustring::compose("Gtk::Assistant example (Page %1 of %2)",
    get_current_page() + 1, get_n_pages()));
}

void ExampleAssistant::on_entry_changed()
{
  // The page is only complete if the entry contains text.
  if(m_entry.get_text_length())
    set_page_complete(m_box, true);
  else
    set_page_complete(m_box, false);
}

void ExampleAssistant::print_status()
{
  std::cout &lt;&lt; ", entry contents: \"" &lt;&lt; m_entry.get_text()
    &lt;&lt; "\", checkbutton status: " &lt;&lt; m_check.get_active() &lt;&lt; std::endl;
}
</pre></div>
</div>
</div>
<div class="division sect2">
<a name="sec-other-multi-item-containers"><!--sec-other-multi-item-containers--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">9.2.7. </span>Other Multi-item Containers</span></h4></div>
<p class="para block block-first">
There are other multi-item containers. See the reference documentation for a
complete list. Here are links to some example programs that show containers,
which are not mentioned elsewhere in this tutorial.
</p>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/actionbar" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/actionbar">Source Code, ActionBar</a></p>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/flowbox" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/flowbox">Source Code, FlowBox</a></p>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/iconview" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/iconview">Source Code, IconView</a></p>
</div>
</div>
</div>
<div class="division chapter">
<a name="chapter-treeview"><!--chapter-treeview--></a><div class="header"><h2 class="chapter title"><span class="title"><span class="label">10. </span>The TreeView widget</span></h2></div>
<p class="para block block-first">
The <span class="classname" dir="ltr">Gtk::TreeView</span> widget can contain lists or trees of
data, in columns.
</p>
<div class="autotoc"><ul>
<li>
<span class="label">10.1. </span><a class="xref" href="#sec-treeview-model" title="The Model">The Model</a>
</li>
<li>
<span class="label">10.2. </span><a class="xref" href="#sec-treeview" title="The View">The View</a>
</li>
<li>
<span class="label">10.3. </span><a class="xref" href="#sec-iterating-over-model-rows" title="Iterating over Model Rows">Iterating over Model Rows</a>
</li>
<li>
<span class="label">10.4. </span><a class="xref" href="#sec-treeview-selection" title="The Selection">The Selection</a>
</li>
<li>
<span class="label">10.5. </span><a class="xref" href="#sec-treeview-sort" title="Sorting">Sorting</a>
</li>
<li>
<span class="label">10.6. </span><a class="xref" href="#sec-treeview-draganddrop" title="Drag and Drop">Drag and Drop</a>
</li>
<li>
<span class="label">10.7. </span><a class="xref" href="#sec-treeview-contextmenu" title="Popup Context Menu">Popup Context Menu</a>
</li>
<li>
<span class="label">10.8. </span><a class="xref" href="#sec-treeview-examples" title="Examples">Examples</a>
</li>
</ul></div>
<div class="division sect1">
<a name="sec-treeview-model"><!--sec-treeview-model--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">10.1. </span>The Model</span></h3></div>
<p class="para block block-first">
Each <span class="classname" dir="ltr">Gtk::TreeView</span> has an associated
<span class="classname" dir="ltr">Gtk::TreeModel</span>, which contains the data displayed by the
<span class="classname" dir="ltr">TreeView</span>. Each <span class="classname" dir="ltr">Gtk::TreeModel</span> can
be used by more than one <span class="classname" dir="ltr">Gtk::TreeView</span>. For instance,
this allows the same underlying data to be displayed and edited in 2 different
ways at the same time. Or the 2 Views might display different columns from the
same Model data, in the same way that 2 SQL queries (or "views") might
show different fields from the same database table.
</p>
<p class="para block">
Although you can theoretically implement your own Model, you will normally use
either the <span class="classname" dir="ltr">ListStore</span> or <span class="classname" dir="ltr">TreeStore</span>
model classes.
</p>
<p class="para block"><a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1TreeModel.html" title="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1TreeModel.html">Reference</a></p>
<div class="autotoc"><ul>
<li>
<span class="label">10.1.1. </span><a class="xref" href="#treeview-model-liststore" title="ListStore, for rows">ListStore, for rows</a>
</li>
<li>
<span class="label">10.1.2. </span><a class="xref" href="#treeview-model-treestore" title="TreeStore, for a hierarchy">TreeStore, for a hierarchy</a>
</li>
<li>
<span class="label">10.1.3. </span><a class="xref" href="#treeview-model-columns" title="Model Columns">Model Columns</a>
</li>
<li>
<span class="label">10.1.4. </span><a class="xref" href="#treeview-adding-rows" title="Adding Rows">Adding Rows</a>
</li>
<li>
<span class="label">10.1.5. </span><a class="xref" href="#treeview-setting-values" title="Setting values">Setting values</a>
</li>
<li>
<span class="label">10.1.6. </span><a class="xref" href="#treeview-getting-values" title="Getting values">Getting values</a>
</li>
<li>
<span class="label">10.1.7. </span><a class="xref" href="#treeview-hidden-columns" title='"Hidden" Columns'>"Hidden" Columns</a>
</li>
</ul></div>
<div class="division sect2">
<a name="treeview-model-liststore"><!--treeview-model-liststore--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">10.1.1. </span>ListStore, for rows</span></h4></div>
<p class="para block block-first">
The <span class="classname" dir="ltr">ListStore</span> contains simple rows of data, and each row
has no children.
</p>
<div class=" block figure block-indent">
<a name="figure-treeview-liststore-model"><!--figure-treeview-liststore-model--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 10-1</span> </span>TreeView - ListStore</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/treeview_list.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1ListStore.html" title="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1ListStore.html">Reference</a></p>
</div>
<div class="division sect2">
<a name="treeview-model-treestore"><!--treeview-model-treestore--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">10.1.2. </span>TreeStore, for a hierarchy</span></h4></div>
<p class="para block block-first">
The <span class="classname" dir="ltr">TreeStore</span> contains rows of data, and each row may
have child rows.
</p>
<div class=" block figure block-indent">
<a name="figure-treeview-treestore-model"><!--figure-treeview-treestore-model--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 10-2</span> </span>TreeView - TreeStore</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/treeview_tree.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1TreeStore.html" title="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1TreeStore.html">Reference</a></p>
</div>
<div class="division sect2">
<a name="treeview-model-columns"><!--treeview-model-columns--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">10.1.3. </span>Model Columns</span></h4></div>
<p class="para block block-first">
The <span class="classname" dir="ltr">TreeModelColumnRecord</span> class is used to keep track
of the columns and their data types. You add
<span class="classname" dir="ltr">TreeModelColumn</span> instances to the
<span class="classname" dir="ltr">ColumnRecord</span> and then use those
<span class="classname" dir="ltr">TreeModelColumns</span> when getting and setting the data in
model rows. You will probably find it convenient to derive a new
<span class="classname" dir="ltr">TreeModelColumnRecord</span> which has your
<span class="classname" dir="ltr">TreeModelColumn</span> instances as member data.
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">class ModelColumns : public Gtk::TreeModelColumnRecord
{
public:

  ModelColumns()
    { add(m_col_text); add(m_col_number); }

  Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_col_text;
  Gtk::TreeModelColumn&lt;int&gt; m_col_number;
};

ModelColumns m_Columns;</pre></div>
<p class="para block">
You specify the <span class="classname" dir="ltr">ColumnRecord</span> when creating the Model,
like so:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">Glib::RefPtr&lt;Gtk::ListStore&gt; refListStore =
    Gtk::ListStore::create(m_Columns);</pre></div>
<p class="para block">
As a <span class="classname" dir="ltr">TreeModelColumnRecord</span> describes structure, not data,
it can be shared among multiple models, and this is preferable for efficiency.
However, the instance (such as <span class="varname" dir="ltr">m_Columns</span> here) should usually
not be static, because it often needs to be instantiated after
<span class="application">glibmm</span> has been initialized. The best solution is
to make it a lazily instantiated singleton, so that it will be constructed
on-demand, whenever the first model accesses it.
</p>
</div>
<div class="division sect2">
<a name="treeview-adding-rows"><!--treeview-adding-rows--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">10.1.4. </span>Adding Rows</span></h4></div>
<p class="para block block-first">
Add rows to the model with the <span class="methodname" dir="ltr">append()</span>,
<span class="methodname" dir="ltr">prepend()</span>, or <span class="methodname" dir="ltr">insert()</span> methods.
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">auto iter = m_refListStore-&gt;append();</pre></div>
<p class="para block">You can dereference the iterator to get the Row:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">auto row = *iter;</pre></div>
<div class="autotoc"><ul><li>
<span class="label">10.1.4.1. </span><a class="xref" href="#treeview-adding-child-rows" title="Adding child rows">Adding child rows</a>
</li></ul></div>
<div class="division sect3">
<a name="treeview-adding-child-rows"><!--treeview-adding-child-rows--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">10.1.4.1. </span>Adding child rows</span></h5></div>
<p class="para block block-first">
<span class="classname" dir="ltr">Gtk::TreeStore</span> models can have child items. Add them
with the <span class="methodname" dir="ltr">append()</span>, <span class="methodname" dir="ltr">prepend()</span>, or
<span class="methodname" dir="ltr">insert()</span> methods, like so:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">auto iter_child =
    m_refTreeStore-&gt;append(row.children());</pre></div>
</div>
</div>
<div class="division sect2">
<a name="treeview-setting-values"><!--treeview-setting-values--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">10.1.5. </span>Setting values</span></h4></div>
<p class="para block block-first">
You can use the <span class="methodname" dir="ltr">operator[]</span> overload to set the data for a
particular column in the row, specifying the
<span class="classname" dir="ltr">TreeModelColumn</span> used to create the model.
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">row[m_Columns.m_col_text] = "sometext";</pre></div>
</div>
<div class="division sect2">
<a name="treeview-getting-values"><!--treeview-getting-values--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">10.1.6. </span>Getting values</span></h4></div>
<p class="para block block-first">
You can use the <span class="methodname" dir="ltr">operator[]</span> overload to get the data in a
particular column in a row, specifying the
<span class="classname" dir="ltr">TreeModelColumn</span> used to create the model.
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">auto strText = row[m_Columns.m_col_text];
auto number = row[m_Columns.m_col_number];</pre></div>
<p class="para block">
The compiler will complain if you use an inappropriate type. For
instance, this would generate a compiler error:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">//compiler error - no conversion from ustring to int.
int number = row[m_Columns.m_col_text];</pre></div>
</div>
<div class="division sect2">
<a name="treeview-hidden-columns"><!--treeview-hidden-columns--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">10.1.7. </span>"Hidden" Columns</span></h4></div>
<p class="para block block-first">
You might want to associate extra data with each row. If so, just add
it as a Model column, but don't add it to the View.
</p>
</div>
</div>
<div class="division sect1">
<a name="sec-treeview"><!--sec-treeview--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">10.2. </span>The View</span></h3></div>
<p class="para block block-first">
The View is the actual widget (<span class="classname" dir="ltr">Gtk::TreeView</span>) that
displays the model (<span class="classname" dir="ltr">Gtk::TreeModel</span>) data and allows the
user to interact with it. The View can show all of the model's columns, or just
some, and it can show them in various ways.
</p>
<p class="para block"><a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1TreeView.html" title="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1TreeView.html">Reference</a></p>
<div class="autotoc"><ul>
<li>
<span class="label">10.2.1. </span><a class="xref" href="#sec-treeview-using-a-model" title="Using a Model">Using a Model</a>
</li>
<li>
<span class="label">10.2.2. </span><a class="xref" href="#treeview-adding-view-columns" title="Adding View Columns">Adding View Columns</a>
</li>
<li>
<span class="label">10.2.3. </span><a class="xref" href="#treeview-multiple-model-columns-per-view-column" title="More than one Model Column per View Column">More than one Model Column per View Column</a>
</li>
<li>
<span class="label">10.2.4. </span><a class="xref" href="#treeview-cellrenderer-details" title="Specifying CellRenderer details">Specifying CellRenderer details</a>
</li>
<li>
<span class="label">10.2.5. </span><a class="xref" href="#treeview-editable-cells" title="Editable Cells">Editable Cells</a>
</li>
</ul></div>
<div class="division sect2">
<a name="sec-treeview-using-a-model"><!--sec-treeview-using-a-model--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">10.2.1. </span>Using a Model</span></h4></div>
<p class="para block block-first">
You can specify a <span class="classname" dir="ltr">Gtk::TreeModel</span> when constructing the
<span class="classname" dir="ltr">Gtk::TreeView</span>, or you can use the
<span class="methodname" dir="ltr">set_model()</span> method, like so:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">m_TreeView.set_model(m_refListStore);</pre></div>
</div>
<div class="division sect2">
<a name="treeview-adding-view-columns"><!--treeview-adding-view-columns--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">10.2.2. </span>Adding View Columns</span></h4></div>
<p class="para block block-first">
You can use the <span class="methodname" dir="ltr">append_column()</span> method to  tell the View
that it should display certain Model columns, in a certain order, with a
certain column title.
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">m_TreeView.append_column("Messages", m_Columns.m_col_text);</pre></div>
<p class="para block">
When using this simple <span class="methodname" dir="ltr">append_column()</span> overload, the
<span class="classname" dir="ltr">TreeView</span> will display the model data with an appropriate
<span class="classname" dir="ltr">CellRenderer</span>. For instance, strings and numbers are
shown in a simple <span class="classname" dir="ltr">Gtk::Entry</span> widget, and booleans are
shown in a <span class="classname" dir="ltr">Gtk::CheckButton</span>. This is usually what you
need. For other column types you must either connect a callback that converts
your type into a string representation, with
<span class="methodname" dir="ltr">TreeViewColumn::set_cell_data_func()</span>, or derive a custom
<span class="classname" dir="ltr">CellRenderer</span>. Note that (unsigned) short is not
supported by default - You could use (unsigned) int or (unsigned) long as the
column type instead.
</p>
</div>
<div class="division sect2">
<a name="treeview-multiple-model-columns-per-view-column"><!--treeview-multiple-model-columns-per-view-column--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">10.2.3. </span>More than one Model Column per View Column</span></h4></div>
<p class="para block block-first">
To render more than one model column in a view column, you need to create the
<span class="classname" dir="ltr">TreeView::Column</span> widget manually, and use
<span class="methodname" dir="ltr">pack_start()</span> to add the model columns to it.
</p>
<p class="para block">
Then use <span class="methodname" dir="ltr">append_column()</span> to add the view Column to the
View. Notice that <span class="methodname" dir="ltr">Gtk::TreeView::append_column()</span> is overloaded
to accept either a prebuilt <span class="classname" dir="ltr">Gtk::TreeView::Column</span> widget, or
just the <span class="classname" dir="ltr">TreeModelColumn</span> from which it generates an
appropriate <span class="classname" dir="ltr">Gtk::TreeView::Column</span> widget.
</p>
<p class="para block">
Here is some example code, which has a pixbuf icon and a text name in the same column:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">auto pColumn = Gtk::make_managed&lt;Gtk::TreeView::Column&gt;("Icon Name");

// m_columns.icon and m_columns.iconname are columns in the model.
// pColumn is the column in the TreeView:
pColumn-&gt;pack_start(m_columns.icon, /* expand= */ false);
pColumn-&gt;pack_start(m_columns.iconname);

m_TreeView.append_column(*pColumn);</pre></div>
</div>
<div class="division sect2">
<a name="treeview-cellrenderer-details"><!--treeview-cellrenderer-details--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">10.2.4. </span>Specifying CellRenderer details</span></h4></div>
<p class="para block block-first">
The default <span class="classname" dir="ltr">CellRenderers</span> and their default behaviour
will normally suffice, but you might occasionally need finer control. For
instance, this example code from
<span class="filename" dir="ltr">gtkmm/demos/gtk-demo/example_treeview_treestore.cc</span>, appends a
<span class="classname" dir="ltr">Gtk::CellRenderer</span> widget and instructs it to render the
data from various model columns through various aspects of its appearance.
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">auto cols_count = m_TreeView.append_column_editable("Alex", m_columns.alex);
auto pColumn = m_TreeView.get_column(cols_count-1);
if(pColumn)
{
  auto pRenderer = static_cast&lt;Gtk::CellRendererToggle*&gt;(pColumn-&gt;get_first_cell());
  pColumn-&gt;add_attribute(pRenderer-&gt;property_visible(), m_columns.visible);
  pColumn-&gt;add_attribute(pRenderer-&gt;property_activatable(), m_columns.world);</pre></div>
<p class="para block">
    You can also connect to <span class="classname" dir="ltr">CellRenderer</span> signals to detect user
actions. For instance:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">auto pRenderer = Gtk::make_managed&lt;Gtk::CellRendererToggle&gt;();
pRenderer-&gt;signal_toggled().connect(
    sigc::bind( sigc::mem_fun(*this,
        &amp;Example_TreeView_TreeStore::on_cell_toggled), m_columns.dave)
);</pre></div>
</div>
<div class="division sect2">
<a name="treeview-editable-cells"><!--treeview-editable-cells--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">10.2.5. </span>Editable Cells</span></h4></div>
<div class="autotoc"><ul>
<li>
<span class="label">10.2.5.1. </span><a class="xref" href="#treeview-editable-cells-automatic" title="Automatically-stored editable cells.">Automatically-stored editable cells.</a>
</li>
<li>
<span class="label">10.2.5.2. </span><a class="xref" href="#treeview-editable-cells-custom" title="Implementing custom logic for editable cells.">Implementing custom logic for editable cells.</a>
</li>
</ul></div>
<div class="division sect3">
<a name="treeview-editable-cells-automatic"><!--treeview-editable-cells-automatic--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">10.2.5.1. </span>Automatically-stored editable cells.</span></h5></div>
<p class="para block block-first">
Cells in a <span class="classname" dir="ltr">TreeView</span> can be edited in-place by the user.
To allow this, use the <span class="classname" dir="ltr">Gtk::TreeView</span>
<span class="methodname" dir="ltr">insert_column_editable()</span> and
<span class="methodname" dir="ltr">append_column_editable()</span> methods instead of
<span class="methodname" dir="ltr">insert_column()</span> and <span class="methodname" dir="ltr">append_column()</span>.
When these cells are edited the new values will be stored immediately in the
Model. Note that these methods are templates which can only be instantiated for
simple column types such as <span class="classname" dir="ltr">Glib::ustring</span>, int, and
long.
</p>
</div>
<div class="division sect3">
<a name="treeview-editable-cells-custom"><!--treeview-editable-cells-custom--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">10.2.5.2. </span>Implementing custom logic for editable cells.</span></h5></div>
<p class="para block block-first">
However, you might not want the new values to be stored
immediately. For instance, maybe you want to restrict the input to
certain characters or ranges of values.
</p>
<p class="para block">
To achieve this, you should use the normal <span class="classname" dir="ltr">Gtk::TreeView</span>
<span class="methodname" dir="ltr">insert_column()</span> and <span class="methodname" dir="ltr">append_column()</span>
methods, then use <span class="methodname" dir="ltr">get_column_cell_renderer()</span> to get the
<span class="classname" dir="ltr">Gtk::CellRenderer</span> used by that column.
</p>
<p class="para block">
You should then cast that <span class="classname" dir="ltr">Gtk::CellRenderer*</span> to the
specific <span class="classname" dir="ltr">CellRenderer</span> that you expect, so you can use specific API.
</p>
<p class="para block">For instance, for a CellRendererText, you would set the cell's <span class="emphasis">editable</span> property to true, like
so:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">cell-&gt;property_editable() = true;</pre></div>
<p class="para block">
For a CellRendererToggle, you would set the <span class="emphasis">activatable</span>
property instead.
</p>
<p class="para block">You can then connect
to the appropriate "edited" signal. For instance, connect to
<span class="methodname" dir="ltr">Gtk::CellRendererText::signal_edited()</span>, or
<span class="methodname" dir="ltr">Gtk::CellRendererToggle::signal_toggled()</span>. If the column
contains more than one <span class="classname" dir="ltr">CellRenderer</span> then you will need
to use <span class="methodname" dir="ltr">Gtk::TreeView::get_column()</span> and then call
<span class="methodname" dir="ltr">get_cells()</span> on that view Column.
</p>
<p class="para block">
In your signal handler, you should examine the new value and then
store it in the Model if that is appropriate for your application.
</p>
</div>
</div>
</div>
<div class="division sect1">
<a name="sec-iterating-over-model-rows"><!--sec-iterating-over-model-rows--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">10.3. </span>Iterating over Model Rows</span></h3></div>
<p class="para block block-first">
<span class="classname" dir="ltr">Gtk::TreeModel</span> provides a C++ Standard Library-style container of its
children, via the <span class="methodname" dir="ltr">children()</span> method. You can use the
familiar <span class="methodname" dir="ltr">begin()</span> and <span class="methodname" dir="ltr">end()</span> methods
iterator incrementing, like so:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">auto children = refModel-&gt;children();
for (auto iter = children.begin(), end = children.end(); iter != end; ++iter)
{
  auto row = *iter;
  //Do something with the row - see above for set/get.
}</pre></div>
<p class="para block">
If you always want to iterate across the entire range, much more succinct syntax
is possible using C++'s range-based <span class="literal" dir="ltr">for</span> loop:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">for (auto row: refModel-&gt;children())
{
  //Do something with the row - see above for set/get.
}</pre></div>
<div class="autotoc"><ul><li>
<span class="label">10.3.1. </span><a class="xref" href="#treeview-row-children" title="Row children">Row children</a>
</li></ul></div>
<div class="division sect2">
<a name="treeview-row-children"><!--treeview-row-children--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">10.3.1. </span>Row children</span></h4></div>
<p class="para block block-first">
When using a <span class="classname" dir="ltr">Gtk::TreeStore</span>, the rows can have child
rows, which can have their own children in turn. Use
<span class="methodname" dir="ltr">Gtk::TreeModel::Row::children()</span> to get the container of child <span class="classname" dir="ltr">Row</span>s:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">Gtk::TreeModel::Children children = row.children();</pre></div>
</div>
</div>
<div class="division sect1">
<a name="sec-treeview-selection"><!--sec-treeview-selection--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">10.4. </span>The Selection</span></h3></div>
<p class="para block block-first">
To find out what rows the user has selected, get the
<span class="classname" dir="ltr">Gtk::TreeView::Selection</span> object from the
<span class="classname" dir="ltr">TreeView</span>, like so:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">auto refTreeSelection = m_TreeView.get_selection();</pre></div>
<div class="autotoc"><ul>
<li>
<span class="label">10.4.1. </span><a class="xref" href="#treeview-selection-mode" title="Single or multiple selection">Single or multiple selection</a>
</li>
<li>
<span class="label">10.4.2. </span><a class="xref" href="#treeview-selected-rows" title="The selected rows">The selected rows</a>
</li>
<li>
<span class="label">10.4.3. </span><a class="xref" href="#treeview-selection-changed-signal" title='The "changed" signal'>The "changed" signal</a>
</li>
<li>
<span class="label">10.4.4. </span><a class="xref" href="#treeview-selection-preventing" title="Preventing row selection">Preventing row selection</a>
</li>
<li>
<span class="label">10.4.5. </span><a class="xref" href="#treeview-selection-changing" title="Changing the selection">Changing the selection</a>
</li>
</ul></div>
<div class="division sect2">
<a name="treeview-selection-mode"><!--treeview-selection-mode--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">10.4.1. </span>Single or multiple selection</span></h4></div>
<p class="para block block-first">
By default, only single rows can be selected, but you can allow
multiple selection by setting the mode, like so:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">refTreeSelection-&gt;set_mode(Gtk::SELECTION_MULTIPLE);</pre></div>
</div>
<div class="division sect2">
<a name="treeview-selected-rows"><!--treeview-selected-rows--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">10.4.2. </span>The selected rows</span></h4></div>
<p class="para block block-first">
For single-selection, you can just call <span class="methodname" dir="ltr">get_selected()</span>,
like so:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">auto iter = refTreeSelection-&gt;get_selected();
if(iter) //If anything is selected
{
  auto row = *iter;
  //Do something with the row.
}</pre></div>
<p class="para block">
For multiple-selection, you need to call <span class="methodname" dir="ltr">get_selected_rows()</span>
or define a callback, and give it to
<span class="methodname" dir="ltr">selected_foreach()</span>,
<span class="methodname" dir="ltr">selected_foreach_path()</span>, or
<span class="methodname" dir="ltr">selected_foreach_iter()</span>, like so:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">refTreeSelection-&gt;selected_foreach_iter(
    sigc::mem_fun(*this, &amp;TheClass::selected_row_callback) );

void TheClass::selected_row_callback(
    const Gtk::TreeModel::const_iterator&amp; iter)
{
  auto row = *iter;
  //Do something with the row.
}</pre></div>
</div>
<div class="division sect2">
<a name="treeview-selection-changed-signal"><!--treeview-selection-changed-signal--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">10.4.3. </span>The "changed" signal</span></h4></div>
<p class="para block block-first">
To respond to the user clicking on a row or range of rows, connect to the
signal like so:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">refTreeSelection-&gt;signal_changed().connect(
    sigc::mem_fun(*this, &amp;Example_IconTheme::on_selection_changed)
);</pre></div>
</div>
<div class="division sect2">
<a name="treeview-selection-preventing"><!--treeview-selection-preventing--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">10.4.4. </span>Preventing row selection</span></h4></div>
<p class="para block block-first">
Maybe the user should not be able to select every item in your list or tree.
For instance, in the gtk-demo, you can select a demo to see the source code,
but it doesn't make any sense to select a demo category.
</p>
<p class="para block">
To control which rows can be selected, use the
<span class="methodname" dir="ltr">set_select_function()</span> method, providing a
<span class="classname" dir="ltr">sigc::slot</span> callback. For instance:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">m_refTreeSelection-&gt;set_select_function( sigc::mem_fun(*this,
    &amp;DemoWindow::select_function) );</pre></div>
<p class="para block">
and then
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">bool DemoWindow::select_function(
    const Glib::RefPtr&lt;Gtk::TreeModel&gt;&amp; model,
    const Gtk::TreeModel::Path&amp; path, bool)
{
  const auto iter = model-&gt;get_iter(path);
  return iter-&gt;children().empty(); // only allow leaf nodes to be selected
}</pre></div>
</div>
<div class="division sect2">
<a name="treeview-selection-changing"><!--treeview-selection-changing--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">10.4.5. </span>Changing the selection</span></h4></div>
<p class="para block block-first">
To change the selection, specify a
<span class="classname" dir="ltr">Gtk::TreeModel::iterator</span> or
<span class="classname" dir="ltr">Gtk::TreeModel::Row</span>, like so:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">auto row = m_refModel-&gt;children()[5]; //The sixth row.
if(row)
  refTreeSelection-&gt;select(row.get_iter());</pre></div>
<p class="para block">
or
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">auto iter = m_refModel-&gt;children().begin()
if(iter)
  refTreeSelection-&gt;select(iter);</pre></div>
</div>
</div>
<div class="division sect1">
<a name="sec-treeview-sort"><!--sec-treeview-sort--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">10.5. </span>Sorting</span></h3></div>
<p class="para block block-first">
The standard tree models (<span class="classname" dir="ltr">TreeStore</span> and <span class="classname" dir="ltr">ListStore</span>) derive from <span class="classname" dir="ltr">TreeSortable</span>, so they offer sorting functionality. For instance, call <span class="methodname" dir="ltr">set_sort_column()</span>, to sort the model by the specified column. Or supply a callback function to <span class="methodname" dir="ltr">set_sort_func()</span> to implement a more complicated sorting algorithm.
</p>
<p class="para block"><a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1TreeSortable.html" title="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1TreeSortable.html">TreeSortable Reference</a></p>
<div class="autotoc"><ul>
<li>
<span class="label">10.5.1. </span><a class="xref" href="#treeview-sort-headers" title="Sorting by clicking on columns">Sorting by clicking on columns</a>
</li>
<li>
<span class="label">10.5.2. </span><a class="xref" href="#treeview-sort-independent-views" title="Independently sorted views of the same model">Independently sorted views of the same model</a>
</li>
</ul></div>
<div class="division sect2">
<a name="treeview-sort-headers"><!--treeview-sort-headers--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">10.5.1. </span>Sorting by clicking on columns</span></h4></div>
<p class="para block block-first">
So that a user can click on a <span class="classname" dir="ltr">TreeView</span>'s column header to sort the <span class="classname" dir="ltr">TreeView</span>'s contents, call <span class="methodname" dir="ltr">Gtk::TreeView::Column::set_sort_column()</span>, supplying the model column on which model should be sorted when the header is clicked. For instance:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">auto pColumn = treeview.get_column(0);
if(pColumn)
  pColumn-&gt;set_sort_column(m_columns.m_col_id);</pre></div>
</div>
<div class="division sect2">
<a name="treeview-sort-independent-views"><!--treeview-sort-independent-views--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">10.5.2. </span>Independently sorted views of the same model</span></h4></div>
<p class="para block block-first">
The <span class="classname" dir="ltr">TreeView</span> already allows you to show the same <span class="classname" dir="ltr">TreeModel</span>
in two <span class="classname" dir="ltr">TreeView</span> widgets. If you need one of these TreeViews to sort the model
differently than the other then you should use a <span class="classname" dir="ltr">TreeModelSort</span> instead of just,
for instance, <span class="methodname" dir="ltr">Gtk::TreeViewColumn::set_sort_column()</span>.
<span class="classname" dir="ltr">TreeModelSort</span> is a model that contains another model, presenting a sorted version
of that model. For instance, you might add a sorted version of a model to a <span class="classname" dir="ltr">TreeView</span> like so:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">auto sorted_model = Gtk::TreeModelSort::create(model);
sorted_model-&gt;set_sort_column(columns.m_col_name, Gtk::SORT_ASCENDING);
treeview.set_model(sorted_model);</pre></div>
<p class="para block">Note, however, that the TreeView will provide iterators to the sorted model. You must convert them to iterators to the underlying child model in order to perform actions on that model. For instance:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">void ExampleWindow::on_button_delete()
{
  auto refTreeSelection = m_treeview.get_selection();
  if(refTreeSelection)
  {
    auto sorted_iter = m_refTreeSelection-&gt;get_selected();
    if(sorted_iter)
    {
      auto iter = m_refModelSort-&gt;convert_iter_to_child_iter(sorted_iter);
      m_refModel-&gt;erase(iter);
    }
  }
}</pre></div>
<p class="para block"><a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1TreeModelSort.html" title="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1TreeModelSort.html">TreeModelSort Reference</a></p>
</div>
</div>
<div class="division sect1">
<a name="sec-treeview-draganddrop"><!--sec-treeview-draganddrop--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">10.6. </span>Drag and Drop</span></h3></div>
<p class="para block block-first">
<span class="classname" dir="ltr">Gtk::TreeView</span> already implements simple drag-and-drop
when used with the <span class="classname" dir="ltr">Gtk::ListStore</span> or
<span class="classname" dir="ltr">Gtk::TreeStore</span> models. If necessary, it also allows you
to implement more complex behaviour when items are dragged and dropped, using
the normal <a class="link" href="#chapter-draganddrop" title="Drag and Drop">Drag and Drop</a> API.
</p>
<div class="autotoc"><ul><li>
<span class="label">10.6.1. </span><a class="xref" href="#treeview-reorderable-rows" title="Reorderable rows">Reorderable rows</a>
</li></ul></div>
<div class="division sect2">
<a name="treeview-reorderable-rows"><!--treeview-reorderable-rows--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">10.6.1. </span>Reorderable rows</span></h4></div>
<p class="para block block-first">
If you call <span class="methodname" dir="ltr">Gtk::TreeView::set_reorderable()</span> then your
TreeView's items can be moved within the treeview itself. This is demonstrated
in the <span class="classname" dir="ltr">TreeStore</span> example.
</p>
<p class="para block">However, this does not allow you any control of which items can be dragged, and where they can be dropped.
If you need that extra control then you might create a derived <span class="literal" dir="ltr">Gtk::TreeModel</span> from
<span class="literal" dir="ltr">Gtk::TreeStore</span> or <span class="literal" dir="ltr">Gtk::ListStore</span> and override the
<span class="literal" dir="ltr">Gtk::TreeDragSource::row_draggable_vfunc()</span> and
<span class="literal" dir="ltr">Gtk::TreeDragDest::row_drop_possible_vfunc()</span> virtual methods.
You can examine the <span class="literal" dir="ltr">Gtk::TreeModel::Path</span>s provided and allow or disallow dragging
or dropping by returning <span class="literal" dir="ltr">true</span> or <span class="literal" dir="ltr">false</span>.</p>
<p class="para block">This is demonstrated in the drag_and_drop example.</p>
</div>
</div>
<div class="division sect1">
<a name="sec-treeview-contextmenu"><!--sec-treeview-contextmenu--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">10.7. </span>Popup Context Menu</span></h3></div>
<p class="para block block-first">
Lots of people need to implement right-click context menus for
<span class="classname" dir="ltr">TreeView</span>'s so we will explain how to do that  here to
save you some time. Apart from one or two points, it's  much the same as a
normal context menu, as described in the <a class="link" href="#sec-menus-popup" title="Popup Menus">menus
    chapter</a>.
</p>
<div class="autotoc"><ul><li>
<span class="label">10.7.1. </span><a class="xref" href="#treeview-button-press-event" title="Handling button_press_event">Handling <span class="literal" dir="ltr">button_press_event</span></a>
</li></ul></div>
<div class="division sect2">
<a name="treeview-button-press-event"><!--treeview-button-press-event--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">10.7.1. </span>Handling <span class="literal" dir="ltr">button_press_event</span></span></h4></div>
<p class="para block block-first">
To detect a click of the right mouse button, you need to handle the
<span class="literal" dir="ltr">button_press_event</span> signal, and check exactly which button
was pressed. Because the <span class="classname" dir="ltr">TreeView</span> normally handles this
signal completely, you need to either override the default signal handler in a
derived <span class="classname" dir="ltr">TreeView</span> class, use <span class="methodname" dir="ltr">connect_notify()</span>
or use <span class="methodname" dir="ltr">connect(slot, /* after= */ false)</span>.
You probably also want to call the default handler before doing anything else,
so that the right-click will cause the row to be selected first.
</p>
<p class="para block">This is demonstrated in the Popup Context Menu example.</p>
</div>
</div>
<div class="division sect1">
<a name="sec-treeview-examples"><!--sec-treeview-examples--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">10.8. </span>Examples</span></h3></div>
<p class="para block block-first">Some <span class="classname" dir="ltr">TreeView</span> examples are shown here. There are
more examples in the <a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/treeview/" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/treeview/">treeview directory</a>
in <span class="application">gtkmm-documentation</span>'s examples.</p>
<p class="para block">If neither <span class="classname" dir="ltr">ListStore</span> nor <span class="classname" dir="ltr">TreeStore</span>
is suitable for your application, look at the
<a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/treeview/custom_treemodel" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/treeview/custom_treemodel">custom TreeModel</a>
example. It shows how you can make your own implementation of the <span class="classname" dir="ltr">TreeModel</span>
interface.</p>
<div class="autotoc"><ul>
<li>
<span class="label">10.8.1. </span><a class="xref" href="#liststore-example" title="ListStore">ListStore</a>
</li>
<li>
<span class="label">10.8.2. </span><a class="xref" href="#treestore-example" title="TreeStore">TreeStore</a>
</li>
<li>
<span class="label">10.8.3. </span><a class="xref" href="#sec-editable-cells-example" title="Editable Cells">Editable Cells</a>
</li>
<li>
<span class="label">10.8.4. </span><a class="xref" href="#treeview-dnd-example" title="Drag and Drop">Drag and Drop</a>
</li>
<li>
<span class="label">10.8.5. </span><a class="xref" href="#treeview-popup-menu-example" title="Popup Context Menu">Popup Context Menu</a>
</li>
</ul></div>
<div class="division sect2">
<a name="liststore-example"><!--liststore-example--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">10.8.1. </span>ListStore</span></h4></div>
<p class="para block block-first">
This example has a <span class="classname" dir="ltr">Gtk::TreeView</span> widget, with a
<span class="classname" dir="ltr">Gtk::ListStore</span> model.
</p>
<div class=" block figure block-indent">
<a name="figure-treeview-liststore"><!--figure-treeview-liststore--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 10-3</span> </span>TreeView - ListStore</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/treeview_list.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/treeview/list/" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/treeview/list/">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_button_quit();

  //Tree model columns:
  class ModelColumns : public Gtk::TreeModel::ColumnRecord
  {
  public:

    ModelColumns()
    { add(m_col_id); add(m_col_name); add(m_col_number); add(m_col_percentage);}

    Gtk::TreeModelColumn&lt;unsigned int&gt; m_col_id;
    Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_col_name;
    Gtk::TreeModelColumn&lt;short&gt; m_col_number;
    Gtk::TreeModelColumn&lt;int&gt; m_col_percentage;
  };

  ModelColumns m_Columns;

  //Child widgets:
  Gtk::Box m_VBox;

  Gtk::ScrolledWindow m_ScrolledWindow;
  Gtk::TreeView m_TreeView;
  Glib::RefPtr&lt;Gtk::ListStore&gt; m_refTreeModel;

  Gtk::Box m_ButtonBox;
  Gtk::Button m_Button_Quit;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;gtkmm/application.h&gt;

int main(int argc, char *argv[])
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  //Shows the window and returns when it is closed.
  return app-&gt;make_window_and_run&lt;ExampleWindow&gt;(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include &lt;iostream&gt;
#include "examplewindow.h"

ExampleWindow::ExampleWindow()
: m_VBox(Gtk::Orientation::VERTICAL),
  m_Button_Quit("Quit")
{
  set_title("Gtk::TreeView (ListStore) example");
  set_default_size(400, 200);

  m_VBox.set_margin(5);
  set_child(m_VBox);

  //Add the TreeView, inside a ScrolledWindow, with the button underneath:
  m_ScrolledWindow.set_child(m_TreeView);

  //Only show the scrollbars when they are necessary:
  m_ScrolledWindow.set_policy(Gtk::PolicyType::AUTOMATIC, Gtk::PolicyType::AUTOMATIC);
  m_ScrolledWindow.set_expand();

  m_VBox.append(m_ScrolledWindow);
  m_VBox.append(m_ButtonBox);

  m_ButtonBox.append(m_Button_Quit);
  m_ButtonBox.set_margin(5);
  m_Button_Quit.set_hexpand(true);
  m_Button_Quit.set_halign(Gtk::Align::END);
  m_Button_Quit.signal_clicked().connect( sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_quit) );

  //Create the Tree model:
  m_refTreeModel = Gtk::ListStore::create(m_Columns);
  m_TreeView.set_model(m_refTreeModel);

  //Fill the TreeView's model
  auto row = *(m_refTreeModel-&gt;append());
  row[m_Columns.m_col_id] = 1;
  row[m_Columns.m_col_name] = "Billy Bob";
  row[m_Columns.m_col_number] = 10;
  row[m_Columns.m_col_percentage] = 15;

  row = *(m_refTreeModel-&gt;append());
  row[m_Columns.m_col_id] = 2;
  row[m_Columns.m_col_name] = "Joey Jojo";
  row[m_Columns.m_col_number] = 20;
  row[m_Columns.m_col_percentage] = 40;

  row = *(m_refTreeModel-&gt;append());
  row[m_Columns.m_col_id] = 3;
  row[m_Columns.m_col_name] = "Rob McRoberts";
  row[m_Columns.m_col_number] = 30;
  row[m_Columns.m_col_percentage] = 70;

  //Add the TreeView's view columns:
  //This number will be shown with the default numeric formatting.
  m_TreeView.append_column("ID", m_Columns.m_col_id);
  m_TreeView.append_column("Name", m_Columns.m_col_name);

  m_TreeView.append_column_numeric("Formatted number", m_Columns.m_col_number,
          "%010d" /* 10 digits, using leading zeroes. */);

  //Display a progress bar instead of a decimal number:
  auto cell = Gtk::make_managed&lt;Gtk::CellRendererProgress&gt;();
  int cols_count = m_TreeView.append_column("Some percentage", *cell);
  auto pColumn = m_TreeView.get_column(cols_count - 1);
  if(pColumn)
  {
    pColumn-&gt;add_attribute(cell-&gt;property_value(), m_Columns.m_col_percentage);
  }

  //Make all the columns reorderable:
  //This is not necessary, but it's nice to show the feature.
  //You can use TreeView::set_column_drag_function() to more
  //finely control column drag and drop.
  for(guint i = 0; i &lt; 2; i++)
  {
    auto column = m_TreeView.get_column(i);
    column-&gt;set_reorderable();
  }
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_button_quit()
{
  hide();
}

</pre></div>
</div>
<div class="division sect2">
<a name="treestore-example"><!--treestore-example--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">10.8.2. </span>TreeStore</span></h4></div>
<p class="para block block-first">
This example is very similar to the <span class="classname" dir="ltr">ListStore</span> example,
but uses a <span class="classname" dir="ltr">Gtk::TreeStore</span> model instead, and adds
children to the rows.
</p>
<div class=" block figure block-indent">
<a name="figure-treeview-treestore"><!--figure-treeview-treestore--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 10-4</span> </span>TreeView - TreeStore</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/treeview_tree.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/treeview/tree/" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/treeview/tree/">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_button_quit();
  void on_treeview_row_activated(const Gtk::TreeModel::Path&amp; path, Gtk::TreeViewColumn* column);

  //Tree model columns:
  class ModelColumns : public Gtk::TreeModel::ColumnRecord
  {
  public:

    ModelColumns()
    { add(m_col_id); add(m_col_name); }

    Gtk::TreeModelColumn&lt;int&gt; m_col_id;
    Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_col_name;
  };

  ModelColumns m_Columns;

  //Child widgets:
  Gtk::Box m_VBox;

  Gtk::ScrolledWindow m_ScrolledWindow;
  Gtk::TreeView m_TreeView;
  Glib::RefPtr&lt;Gtk::TreeStore&gt; m_refTreeModel;

  Gtk::Box m_ButtonBox;
  Gtk::Button m_Button_Quit;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;gtkmm/application.h&gt;

int main(int argc, char *argv[])
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  //Shows the window and returns when it is closed.
  return app-&gt;make_window_and_run&lt;ExampleWindow&gt;(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include &lt;iostream&gt;
#include "examplewindow.h"

ExampleWindow::ExampleWindow()
: m_VBox(Gtk::Orientation::VERTICAL),
  m_Button_Quit("Quit")
{
  set_title("Gtk::TreeView (TreeStore) example");
  set_default_size(400, 200);

  m_VBox.set_margin(5);
  set_child(m_VBox);

  //Add the TreeView, inside a ScrolledWindow, with the button underneath:
  m_ScrolledWindow.set_child(m_TreeView);

  //Only show the scrollbars when they are necessary:
  m_ScrolledWindow.set_policy(Gtk::PolicyType::AUTOMATIC, Gtk::PolicyType::AUTOMATIC);
  m_ScrolledWindow.set_expand();

  m_VBox.append(m_ScrolledWindow);
  m_VBox.append(m_ButtonBox);

  m_ButtonBox.append(m_Button_Quit);
  m_ButtonBox.set_margin(5);
  m_Button_Quit.set_hexpand(true);
  m_Button_Quit.set_halign(Gtk::Align::END);
  m_Button_Quit.signal_clicked().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_quit) );

  //Create the Tree model:
  m_refTreeModel = Gtk::TreeStore::create(m_Columns);
  m_TreeView.set_model(m_refTreeModel);

  //All the items to be reordered with drag-and-drop:
  m_TreeView.set_reorderable();

  //Fill the TreeView's model
  auto row = *(m_refTreeModel-&gt;append());
  row[m_Columns.m_col_id] = 1;
  row[m_Columns.m_col_name] = "Billy Bob";

  auto childrow = *(m_refTreeModel-&gt;append(row.children()));
  childrow[m_Columns.m_col_id] = 11;
  childrow[m_Columns.m_col_name] = "Billy Bob Junior";

  childrow = *(m_refTreeModel-&gt;append(row.children()));
  childrow[m_Columns.m_col_id] = 12;
  childrow[m_Columns.m_col_name] = "Sue Bob";

  row = *(m_refTreeModel-&gt;append());
  row[m_Columns.m_col_id] = 2;
  row[m_Columns.m_col_name] = "Joey Jojo";


  row = *(m_refTreeModel-&gt;append());
  row[m_Columns.m_col_id] = 3;
  row[m_Columns.m_col_name] = "Rob McRoberts";

  childrow = *(m_refTreeModel-&gt;append(row.children()));
  childrow[m_Columns.m_col_id] = 31;
  childrow[m_Columns.m_col_name] = "Xavier McRoberts";

  //Add the TreeView's view columns:
  m_TreeView.append_column("ID", m_Columns.m_col_id);
  m_TreeView.append_column("Name", m_Columns.m_col_name);

  //Connect signal:
  m_TreeView.signal_row_activated().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_treeview_row_activated) );
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_button_quit()
{
  hide();
}

void ExampleWindow::on_treeview_row_activated(const Gtk::TreeModel::Path&amp; path,
        Gtk::TreeViewColumn* /* column */)
{
  const auto iter = m_refTreeModel-&gt;get_iter(path);
  if(iter)
  {
    const auto row = *iter;
    std::cout &lt;&lt; "Row activated: ID=" &lt;&lt; row[m_Columns.m_col_id] &lt;&lt; ", Name="
        &lt;&lt; row[m_Columns.m_col_name] &lt;&lt; std::endl;
  }
}

</pre></div>
</div>
<div class="division sect2">
<a name="sec-editable-cells-example"><!--sec-editable-cells-example--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">10.8.3. </span>Editable Cells</span></h4></div>
<p class="para block block-first">
This example is identical to the <span class="classname" dir="ltr">ListStore</span> example, but
it uses <span class="methodname" dir="ltr">TreeView::append_column_editable()</span> instead of
<span class="methodname" dir="ltr">TreeView::append_column()</span>.
</p>
<div class=" block figure block-indent">
<a name="figure-treeview-editablecells"><!--figure-treeview-editablecells--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 10-5</span> </span>TreeView - Editable Cells</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/treeview_editablecells.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/treeview/editable_cells/" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/treeview/editable_cells/">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_button_quit();

  void treeviewcolumn_validated_on_cell_data(Gtk::CellRenderer* renderer, const Gtk::TreeModel::const_iterator&amp; iter);
  void cellrenderer_validated_on_editing_started(Gtk::CellEditable* cell_editable, const Glib::ustring&amp; path);
  void cellrenderer_validated_on_edited(const Glib::ustring&amp; path_string, const Glib::ustring&amp; new_text);
  void on_message_response(int response_id, Gtk::MessageDialog* dialog);

  //Tree model columns:
  class ModelColumns : public Gtk::TreeModel::ColumnRecord
  {
  public:

    ModelColumns()
    { add(m_col_id); add(m_col_name); add(m_col_foo); add(m_col_number); add(m_col_number_validated); }

    Gtk::TreeModelColumn&lt;unsigned int&gt; m_col_id;
    Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_col_name;
    Gtk::TreeModelColumn&lt;bool&gt; m_col_foo;
    Gtk::TreeModelColumn&lt;int&gt; m_col_number;
    Gtk::TreeModelColumn&lt;int&gt; m_col_number_validated;
  };

  ModelColumns m_Columns;

  //Child widgets:
  Gtk::Box m_VBox;

  Gtk::ScrolledWindow m_ScrolledWindow;
  Gtk::TreeView m_TreeView;
  Glib::RefPtr&lt;Gtk::ListStore&gt; m_refTreeModel;

  Gtk::Box m_ButtonBox;
  Gtk::Button m_Button_Quit;

  //For the validated column:
  //You could also use a CellRendererSpin or a CellRendererProgress:
  Gtk::CellRendererText m_cellrenderer_validated;
  Gtk::TreeView::Column m_treeviewcolumn_validated;
  bool m_validate_retry;
  Glib::ustring m_invalid_text_for_retry;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;gtkmm/application.h&gt;

int main(int argc, char *argv[])
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  //Shows the window and returns when it is closed.
  return app-&gt;make_window_and_run&lt;ExampleWindow&gt;(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include "examplewindow.h"

using std::sprintf;
using std::strtol;

ExampleWindow::ExampleWindow()
: m_VBox(Gtk::Orientation::VERTICAL),
  m_Button_Quit("Quit"),
  m_validate_retry(false)
{
  set_title("Gtk::TreeView Editable Cells example");
  set_default_size(400, 200);

  m_VBox.set_margin(5);
  set_child(m_VBox);

  //Add the TreeView, inside a ScrolledWindow, with the button underneath:
  m_ScrolledWindow.set_child(m_TreeView);

  //Only show the scrollbars when they are necessary:
  m_ScrolledWindow.set_policy(Gtk::PolicyType::AUTOMATIC, Gtk::PolicyType::AUTOMATIC);
  m_ScrolledWindow.set_expand();

  m_VBox.append(m_ScrolledWindow);
  m_VBox.append(m_ButtonBox);

  m_ButtonBox.append(m_Button_Quit);
  m_ButtonBox.set_margin(5);
  m_Button_Quit.set_hexpand(true);
  m_Button_Quit.set_halign(Gtk::Align::END);
  m_Button_Quit.signal_clicked().connect( sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_quit) );

  //Create the Tree model:
  m_refTreeModel = Gtk::ListStore::create(m_Columns);
  m_TreeView.set_model(m_refTreeModel);

  //Fill the TreeView's model
  auto row = *(m_refTreeModel-&gt;append());
  row[m_Columns.m_col_id] = 1;
  row[m_Columns.m_col_name] = "Billy Bob";
  row[m_Columns.m_col_foo] = true;
  row[m_Columns.m_col_number] = 10;

  row = *(m_refTreeModel-&gt;append());
  row[m_Columns.m_col_id] = 2;
  row[m_Columns.m_col_name] = "Joey Jojo";
  row[m_Columns.m_col_foo] = true;
  row[m_Columns.m_col_number] = 20;

  row = *(m_refTreeModel-&gt;append());

  row[m_Columns.m_col_id] = 3;
  row[m_Columns.m_col_name] = "Rob McRoberts";
  row[m_Columns.m_col_foo] = false;
  row[m_Columns.m_col_number] = 30;

  //Add the TreeView's view columns:
  //We use the *_editable convenience methods for most of these,
  //because the default functionality is enough:
  m_TreeView.append_column_editable("ID", m_Columns.m_col_id);
  m_TreeView.append_column_editable("Name", m_Columns.m_col_name);
  m_TreeView.append_column_editable("foo", m_Columns.m_col_foo);
  m_TreeView.append_column_numeric_editable("foo", m_Columns.m_col_number,
          "%010d");


  //For this column, we create the CellRenderer ourselves, and connect our own
  //signal handlers, so that we can validate the data that the user enters, and
  //control how it is displayed.
  m_treeviewcolumn_validated.set_title("validated (&amp;lt;10)");
  m_treeviewcolumn_validated.pack_start(m_cellrenderer_validated);
  m_TreeView.append_column(m_treeviewcolumn_validated);

  //Tell the view column how to render the model values:
  m_treeviewcolumn_validated.set_cell_data_func(m_cellrenderer_validated,
          sigc::mem_fun(*this,
              &amp;ExampleWindow::treeviewcolumn_validated_on_cell_data) );

  //Make the CellRenderer editable, and handle its editing signals:
  m_cellrenderer_validated.property_editable() = true;

  m_cellrenderer_validated.signal_editing_started().connect(
          sigc::mem_fun(*this,
        &amp;ExampleWindow::cellrenderer_validated_on_editing_started) );

  m_cellrenderer_validated.signal_edited().connect( sigc::mem_fun(*this,
              &amp;ExampleWindow::cellrenderer_validated_on_edited) );

  //If this was a CellRendererSpin then you would have to set the adjustment:
  //m_cellrenderer_validated.property_adjustment() = m_spin_adjustment;
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_button_quit()
{
  hide();
}

void ExampleWindow::treeviewcolumn_validated_on_cell_data(
        Gtk::CellRenderer* /* renderer */,
        const Gtk::TreeModel::const_iterator&amp; iter)
{
  //Get the value from the model and show it appropriately in the view:
  if(iter)
  {
    const auto row = *iter;
    int model_value = row[m_Columns.m_col_number_validated];

    //This is just an example.
    //In this case, it would be easier to use append_column_editable() or
    //append_column_numeric_editable()
    char buffer[32];
    sprintf(buffer, "%d", model_value);

    auto view_text = buffer;
    m_cellrenderer_validated.property_text() = view_text;
  }
}

void ExampleWindow::cellrenderer_validated_on_editing_started(
        Gtk::CellEditable* cell_editable, const Glib::ustring&amp; /* path */)
{
  //Start editing with previously-entered (but invalid) text,
  //if we are allowing the user to correct some invalid data.
  if(m_validate_retry)
  {
    //This is the CellEditable inside the CellRenderer.
    auto celleditable_validated = cell_editable;

    //It's usually an Entry, at least for a CellRendererText:
    auto pEntry = dynamic_cast&lt;Gtk::Entry*&gt;(celleditable_validated);
    if(pEntry)
    {
      pEntry-&gt;set_text(m_invalid_text_for_retry);
      m_validate_retry = false;
      m_invalid_text_for_retry.clear();
    }
  }
}

void ExampleWindow::cellrenderer_validated_on_edited(
        const Glib::ustring&amp; path_string,
        const Glib::ustring&amp; new_text)
{
  Gtk::TreePath path(path_string);

  //Convert the inputed text to an integer, as needed by our model column:
  char* pchEnd = nullptr;
  int new_value = strtol(new_text.c_str(), &amp;pchEnd, 10);

  if(new_value &gt;= 10)
  {
    //Prevent entry of numbers higher than 10.

    //Tell the user:
    auto dialog = new Gtk::MessageDialog(*this,
            "The number must be less than 10. Please try again.",
            false, Gtk::MessageType::ERROR, Gtk::ButtonsType::OK, true /* modal */);
    dialog-&gt;signal_response().connect(sigc::bind(
      sigc::mem_fun(*this, &amp;ExampleWindow::on_message_response), dialog));

    dialog-&gt;show();

    //Start editing again, with the bad text, so that the user can correct it.
    //A real application should probably allow the user to revert to the
    //previous text.

    //Set the text to be used in the start_editing signal handler:
    m_invalid_text_for_retry = new_text;
    m_validate_retry = true;

    //Start editing again, when the message dialog has been closed:
    m_TreeView.set_cursor(path, m_treeviewcolumn_validated,
            m_cellrenderer_validated, true /* start_editing */);
  }
  else
  {
    //Get the row from the path:
    auto iter = m_refTreeModel-&gt;get_iter(path);
    if(iter)
    {
      auto row = *iter;

      //Put the new value in the model:
      row[m_Columns.m_col_number_validated] = new_value;
    }
  }
}

void ExampleWindow::on_message_response(int /* response_id */, Gtk::MessageDialog* dialog)
{
  delete dialog;
}
</pre></div>
</div>
<div class="division sect2">
<a name="treeview-dnd-example"><!--treeview-dnd-example--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">10.8.4. </span>Drag and Drop</span></h4></div>
<p class="para block block-first">
This example is much like the <span class="classname" dir="ltr">TreeStore</span> example, but has
2 extra columns to indicate whether the row can be dragged, and whether it can
receive drag-and-dropped rows. It uses a derived
<span class="classname" dir="ltr">Gtk::TreeStore</span> which overrides the virtual functions as
described in the <a class="link" href="#sec-treeview-draganddrop" title="Drag and Drop">TreeView Drag and
    Drop</a> section.
</p>
<div class=" block figure block-indent">
<a name="figure-treeview-draganddrop"><!--figure-treeview-draganddrop--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 10-6</span> </span>TreeView - Drag And Drop</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/treeview_draganddrop.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/treeview/drag_and_drop/" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/treeview/drag_and_drop/">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;
#include "treemodel_dnd.h"


class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_button_quit();


  //Child widgets:
  Gtk::Box m_VBox;

  Gtk::ScrolledWindow m_ScrolledWindow;
  Gtk::TreeView m_TreeView;
  Glib::RefPtr&lt;TreeModel_Dnd&gt; m_refTreeModel;

  Gtk::Box m_ButtonBox;
  Gtk::Button m_Button_Quit;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">treemodel_dnd.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLE_TREEMODEL_DND_H
#define GTKMM_EXAMPLE_TREEMODEL_DND_H

#include &lt;gtkmm.h&gt;

class TreeModel_Dnd : public Gtk::TreeStore
{
protected:
  TreeModel_Dnd();

public:

  //Tree model columns:
  class ModelColumns : public Gtk::TreeModel::ColumnRecord
  {
  public:

    ModelColumns()
    { add(m_col_id); add(m_col_name); add(m_col_draggable); add(m_col_receivesdrags); }

    Gtk::TreeModelColumn&lt;int&gt; m_col_id;
    Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_col_name;
    Gtk::TreeModelColumn&lt;bool&gt; m_col_draggable;
    Gtk::TreeModelColumn&lt;bool&gt; m_col_receivesdrags;
  };

  ModelColumns m_Columns;

  static Glib::RefPtr&lt;TreeModel_Dnd&gt; create();

protected:
  //Overridden virtual functions:
  bool row_draggable_vfunc(const Gtk::TreeModel::Path&amp; path) const override;
  bool row_drop_possible_vfunc(const Gtk::TreeModel::Path&amp; dest, const Glib::ValueBase&amp; value) const override;
};

#endif //GTKMM_EXAMPLE_TREEMODEL_DND_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">treemodel_dnd.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "treemodel_dnd.h"
#include &lt;iostream&gt;

TreeModel_Dnd::TreeModel_Dnd()
{
  //We can't just call Gtk::TreeModel(m_Columns) in the initializer list
  //because m_Columns does not exist when the base class constructor runs.
  //And we can't have a static m_Columns instance, because that would be
  //instantiated before the gtkmm type system.
  //So, we use this method, which should only be used just after creation:
  set_column_types(m_Columns);
}

Glib::RefPtr&lt;TreeModel_Dnd&gt; TreeModel_Dnd::create()
{
  return Glib::make_refptr_for_instance&lt;TreeModel_Dnd&gt;( new TreeModel_Dnd() );
}

bool
TreeModel_Dnd::row_draggable_vfunc(const Gtk::TreeModel::Path&amp; path) const
{
  // Make the value of the "draggable" column determine whether this row can
  // be dragged:

  const const_iterator iter = get_iter(path);
  if(iter)
  {
    ConstRow row = *iter;
    bool is_draggable = row[m_Columns.m_col_draggable];
    return is_draggable;
  }

  return Gtk::TreeStore::row_draggable_vfunc(path);
}

bool
TreeModel_Dnd::row_drop_possible_vfunc(const Gtk::TreeModel::Path&amp; dest,
        const Glib::ValueBase&amp; value) const
{
  //Make the value of the "receives drags" column determine whether a row can be
  //dragged into it:

  //dest is the path that the row would have after it has been dropped:
  //But in this case we are more interested in the parent row:
  auto dest_parent = dest;
  bool dest_is_not_top_level = dest_parent.up();
  if(!dest_is_not_top_level || dest_parent.empty())
  {
    //The user wants to move something to the top-level.
    //Let's always allow that.
  }
  else
  {
    //Get an iterator for the row at this path:
    const const_iterator iter_dest_parent = get_iter(dest_parent);
    if(iter_dest_parent)
    {
      ConstRow row = *iter_dest_parent;
      bool receives_drags = row[m_Columns.m_col_receivesdrags];
      return receives_drags;
    }
  }

  // You could also examine the row being dragged (via value)
  // if you must look at both rows to see whether a drop should be allowed.
  // You could use
  //   Glib::RefPtr&lt;const Gtk::TreeModel&gt; model_dragged_row;
  //   Gtk::TreeModel::Path path_dragged_row;
  //   Gtk::TreeModel::Path::get_row_drag_data(value,
  //     model_dragged_row, path_dragged_row);

  return Gtk::TreeStore::row_drop_possible_vfunc(dest, value);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;gtkmm/application.h&gt;

int main(int argc, char *argv[])
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  //Shows the window and returns when it is closed.
  return app-&gt;make_window_and_run&lt;ExampleWindow&gt;(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include &lt;iostream&gt;
#include "examplewindow.h"

ExampleWindow::ExampleWindow()
: m_VBox(Gtk::Orientation::VERTICAL),
  m_Button_Quit("_Quit", true)
{
  set_title("Gtk::TreeView (Drag and Drop) example");
  set_default_size(400, 200);

  m_VBox.set_margin(5);
  set_child(m_VBox);

  //Add the TreeView, inside a ScrolledWindow, with the button underneath:
  m_ScrolledWindow.set_child(m_TreeView);

  //Only show the scrollbars when they are necessary:
  m_ScrolledWindow.set_policy(Gtk::PolicyType::AUTOMATIC, Gtk::PolicyType::AUTOMATIC);
  m_ScrolledWindow.set_expand();

  m_VBox.append(m_ScrolledWindow);
  m_VBox.append(m_ButtonBox);

  m_ButtonBox.append(m_Button_Quit);
  m_ButtonBox.set_margin(5);
  m_Button_Quit.set_hexpand(true);
  m_Button_Quit.set_halign(Gtk::Align::END);
  m_Button_Quit.signal_clicked().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_quit) );

  //Create the Tree model:
  //Use our derived model, which overrides some Gtk::TreeDragDest and
  //Gtk::TreeDragSource virtual functions:
  //The columns are declared in the overridden TreeModel.
  m_refTreeModel = TreeModel_Dnd::create();
  m_TreeView.set_model(m_refTreeModel);

  //Enable Drag-and-Drop of TreeView rows:
  //See also the derived TreeModel's *_vfunc overrides.
  m_TreeView.enable_model_drag_source();
  m_TreeView.enable_model_drag_dest();

  //Fill the TreeView's model
  auto row = *(m_refTreeModel-&gt;append());
  row[m_refTreeModel-&gt;m_Columns.m_col_id] = 1;
  row[m_refTreeModel-&gt;m_Columns.m_col_name] = "Billy Bob";
  row[m_refTreeModel-&gt;m_Columns.m_col_draggable] = true;
  row[m_refTreeModel-&gt;m_Columns.m_col_receivesdrags] = true;

  auto childrow = *(m_refTreeModel-&gt;append(row.children()));
  childrow[m_refTreeModel-&gt;m_Columns.m_col_id] = 11;
  childrow[m_refTreeModel-&gt;m_Columns.m_col_name] = "Billy Bob Junior";
  childrow[m_refTreeModel-&gt;m_Columns.m_col_draggable] = true;
  childrow[m_refTreeModel-&gt;m_Columns.m_col_receivesdrags] = true;

  childrow = *(m_refTreeModel-&gt;append(row.children()));
  childrow[m_refTreeModel-&gt;m_Columns.m_col_id] = 12;
  childrow[m_refTreeModel-&gt;m_Columns.m_col_name] = "Sue Bob";
  childrow[m_refTreeModel-&gt;m_Columns.m_col_draggable] = true;
  childrow[m_refTreeModel-&gt;m_Columns.m_col_receivesdrags] = true;

  row = *(m_refTreeModel-&gt;append());
  row[m_refTreeModel-&gt;m_Columns.m_col_id] = 2;
  row[m_refTreeModel-&gt;m_Columns.m_col_name] = "Joey Jojo";
  row[m_refTreeModel-&gt;m_Columns.m_col_draggable] = true;
  row[m_refTreeModel-&gt;m_Columns.m_col_receivesdrags] = true;

  row = *(m_refTreeModel-&gt;append());
  row[m_refTreeModel-&gt;m_Columns.m_col_id] = 3;
  row[m_refTreeModel-&gt;m_Columns.m_col_name] = "Rob McRoberts";
  row[m_refTreeModel-&gt;m_Columns.m_col_draggable] = true;
  row[m_refTreeModel-&gt;m_Columns.m_col_receivesdrags] = true;

  childrow = *(m_refTreeModel-&gt;append(row.children()));
  childrow[m_refTreeModel-&gt;m_Columns.m_col_id] = 31;
  childrow[m_refTreeModel-&gt;m_Columns.m_col_name] = "Xavier McRoberts";
  childrow[m_refTreeModel-&gt;m_Columns.m_col_draggable] = true;
  childrow[m_refTreeModel-&gt;m_Columns.m_col_receivesdrags] = true;

  //Add the TreeView's view columns:
  m_TreeView.append_column("ID", m_refTreeModel-&gt;m_Columns.m_col_id);
  m_TreeView.append_column("Name", m_refTreeModel-&gt;m_Columns.m_col_name);
  m_TreeView.append_column_editable("Draggable",
          m_refTreeModel-&gt;m_Columns.m_col_draggable);
  m_TreeView.append_column_editable("Receives Drags",
          m_refTreeModel-&gt;m_Columns.m_col_receivesdrags);
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_button_quit()
{
  hide();
}

</pre></div>
</div>
<div class="division sect2">
<a name="treeview-popup-menu-example"><!--treeview-popup-menu-example--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">10.8.5. </span>Popup Context Menu</span></h4></div>
<p class="para block block-first">
This example is much like the <span class="classname" dir="ltr">ListStore</span> example, but
derives a custom <span class="classname" dir="ltr">TreeView</span> in order to override the
<span class="literal" dir="ltr">button_press_event</span>, and also to encapsulate the tree model
code in our derived class. See the <a class="link" href="#sec-treeview-contextmenu" title="Popup Context Menu">TreeView Popup Context Menu</a>
section.
</p>
<div class=" block figure block-indent">
<a name="figure-treeview-popup"><!--figure-treeview-popup--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 10-7</span> </span>TreeView - Popup Context Menu</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/treeview_popup.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/treeview/popup/" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/treeview/popup/">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;
#include "treeview_withpopup.h"

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_button_quit();



  //Child widgets:
  Gtk::Box m_VBox;

  Gtk::ScrolledWindow m_ScrolledWindow;
  TreeView_WithPopup m_TreeView;

  Gtk::Box m_ButtonBox;
  Gtk::Button m_Button_Quit;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">treeview_withpopup.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLE_TREEVIEW_WITHPOPUP_H
#define GTKMM_EXAMPLE_TREEVIEW_WITHPOPUP_H

#include &lt;gtkmm.h&gt;

class TreeView_WithPopup : public Gtk::TreeView
{
public:
  TreeView_WithPopup();
  virtual ~TreeView_WithPopup();

protected:
  // Signal handler for showing popup menu:
  void on_popup_button_pressed(int n_press, double x, double y);

  //Signal handler for popup menu items:
  void on_menu_file_popup_generic();


  //Tree model columns:
  class ModelColumns : public Gtk::TreeModel::ColumnRecord
  {
  public:

    ModelColumns()
    { add(m_col_id); add(m_col_name); }

    Gtk::TreeModelColumn&lt;unsigned int&gt; m_col_id;
    Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_col_name;
  };

  ModelColumns m_Columns;

  //The Tree model:
  Glib::RefPtr&lt;Gtk::ListStore&gt; m_refTreeModel;

  Gtk::PopoverMenu m_MenuPopup;
};

#endif //GTKMM_EXAMPLE_TREEVIEW_WITHPOPUP_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;gtkmm/application.h&gt;

int main(int argc, char *argv[])
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  //Shows the window and returns when it is closed.
  return app-&gt;make_window_and_run&lt;ExampleWindow&gt;(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include &lt;iostream&gt;
#include "examplewindow.h"

ExampleWindow::ExampleWindow()
: m_VBox(Gtk::Orientation::VERTICAL),
  m_Button_Quit("Quit")
{
  set_title("Gtk::TreeView (ListStore) example");
  set_default_size(400, 200);

  m_VBox.set_margin(5);
  set_child(m_VBox);

  //Add the TreeView, inside a ScrolledWindow, with the button underneath:
  m_ScrolledWindow.set_child(m_TreeView);

  //Only show the scrollbars when they are necessary:
  m_ScrolledWindow.set_policy(Gtk::PolicyType::AUTOMATIC, Gtk::PolicyType::AUTOMATIC);
  m_ScrolledWindow.set_expand();

  m_VBox.append(m_ScrolledWindow);
  m_VBox.append(m_ButtonBox);

  m_ButtonBox.append(m_Button_Quit);
  m_ButtonBox.set_margin(5);
  m_Button_Quit.set_hexpand(true);
  m_Button_Quit.set_halign(Gtk::Align::END);
  m_Button_Quit.signal_clicked().connect( sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_quit) );
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_button_quit()
{
  hide();
}

</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">treeview_withpopup.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "treeview_withpopup.h"
#include &lt;iostream&gt;

TreeView_WithPopup::TreeView_WithPopup()
{
  //Create the Tree model:
  m_refTreeModel = Gtk::ListStore::create(m_Columns);
  set_model(m_refTreeModel);

  //Fill the TreeView's model
  auto row = *(m_refTreeModel-&gt;append());
  row[m_Columns.m_col_id] = 1;
  row[m_Columns.m_col_name] = "right-click on this";

  row = *(m_refTreeModel-&gt;append());
  row[m_Columns.m_col_id] = 2;
  row[m_Columns.m_col_name] = "or this";

  row = *(m_refTreeModel-&gt;append());
  row[m_Columns.m_col_id] = 3;
  row[m_Columns.m_col_name] = "or this, for a popup context menu";

  //Add the TreeView's view columns:
  append_column("ID", m_Columns.m_col_id);
  append_column("Name", m_Columns.m_col_name);

  // Catch button press events:
  auto refGesture = Gtk::GestureClick::create();
  refGesture-&gt;set_button(GDK_BUTTON_SECONDARY);
  refGesture-&gt;signal_pressed().connect(
    sigc::mem_fun(*this, &amp;TreeView_WithPopup::on_popup_button_pressed));
  add_controller(refGesture);

  // Fill popup menu:
  auto gmenu = Gio::Menu::create();
  gmenu-&gt;append("_Edit", "popup.edit");
  gmenu-&gt;append("_Process", "popup.process");
  gmenu-&gt;append("_Remove", "popup.remove");

  m_MenuPopup.set_parent(*this);
  m_MenuPopup.set_menu_model(gmenu);
  m_MenuPopup.set_has_arrow(false);

  // Create actions:
  auto refActionGroup = Gio::SimpleActionGroup::create();

  refActionGroup-&gt;add_action("edit",
    sigc::mem_fun(*this, &amp;TreeView_WithPopup::on_menu_file_popup_generic));
  refActionGroup-&gt;add_action("process",
    sigc::mem_fun(*this, &amp;TreeView_WithPopup::on_menu_file_popup_generic));
  refActionGroup-&gt;add_action("remove",
    sigc::mem_fun(*this, &amp;TreeView_WithPopup::on_menu_file_popup_generic));

  insert_action_group("popup", refActionGroup);
}

TreeView_WithPopup::~TreeView_WithPopup()
{
}

void TreeView_WithPopup::on_popup_button_pressed(int /* n_press */, double x, double y)
{
  const Gdk::Rectangle rect(x, y, 1, 1);
  m_MenuPopup.set_pointing_to(rect);
  m_MenuPopup.popup();
}

void TreeView_WithPopup::on_menu_file_popup_generic()
{
  std::cout &lt;&lt; "A popup menu item was selected." &lt;&lt; std::endl;

  auto refSelection = get_selection();
  if(refSelection)
  {
    auto iter = refSelection-&gt;get_selected();
    if(iter)
    {
      int id = (*iter)[m_Columns.m_col_id];
      std::cout &lt;&lt; "  Selected ID=" &lt;&lt; id &lt;&lt; std::endl;
    }
  }
}
</pre></div>
</div>
</div>
</div>
<div class="division chapter">
<a name="chapter-combobox"><!--chapter-combobox--></a><div class="header"><h2 class="chapter title"><span class="title"><span class="label">11. </span>Combo Boxes</span></h2></div>
<p class="para block block-first">The <span class="classname" dir="ltr">ComboBox</span> widget offers a list (or tree) of choices in a dropdown menu. If appropriate, it can show extra information about each item, such as text, a picture, a check button, or a progress bar. The <span class="classname" dir="ltr">ComboBox</span> widget usually restricts the user to the available choices, but it can optionally have an <span class="classname" dir="ltr">Entry</span>, allowing the user to enter arbitrary text if none of the available choices are suitable.
</p>
<p class="para block">The list is provided via a <span class="classname" dir="ltr">TreeModel</span>, and columns from this model are added to the ComboBox's view with the <span class="methodname" dir="ltr">ComboBox::pack_start()</span> method. This provides flexibility and compile-time type-safety, but the <span class="classname" dir="ltr">ComboBoxText</span> class provides a simpler text-based specialization in case that flexibility is not required.
</p>
<p class="para block"><a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1ComboBox.html" title="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1ComboBox.html">Reference</a></p>
<div class="autotoc"><ul>
<li>
<span class="label">11.1. </span><a class="xref" href="#sec-combobox-model" title="The model">The model</a>
</li>
<li>
<span class="label">11.2. </span><a class="xref" href="#sec-combobox-get" title="The chosen item">The chosen item</a>
</li>
<li>
<span class="label">11.3. </span><a class="xref" href="#sec-combobox-changes" title="Responding to changes">Responding to changes</a>
</li>
<li>
<span class="label">11.4. </span><a class="xref" href="#combobox-example-full" title="Full Example">Full Example</a>
</li>
<li>
<span class="label">11.5. </span><a class="xref" href="#combobox-example-simple" title="Simple Text Example">Simple Text Example</a>
</li>
<li>
<span class="label">11.6. </span><a class="xref" href="#sec-comboboxentry" title="ComboBox with an Entry">ComboBox with an Entry</a>
</li>
</ul></div>
<div class="division sect1">
<a name="sec-combobox-model"><!--sec-combobox-model--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">11.1. </span>The model</span></h3></div>
<p class="para block block-first">The model for a ComboBox can be defined and filled exactly as for a <span class="classname" dir="ltr">TreeView</span>. For instance, you might derive a ComboBox class with one integer and one text column, like so:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">class ModelColumns : public Gtk::TreeModel::ColumnRecord
{
public:
  ModelColumns()
  { add(m_col_id); add(m_col_name); }

  Gtk::TreeModelColumn&lt;int&gt; m_col_id;
  Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_col_name;
};

ModelColumns m_columns;</pre></div>
<p class="para block">After appending rows to this model, you should provide the model to the <span class="classname" dir="ltr">ComboBox</span> with the <span class="methodname" dir="ltr">set_model()</span> method. Then use the <span class="methodname" dir="ltr">pack_start()</span> or <span class="methodname" dir="ltr">pack_end()</span> methods to specify what columns will be displayed in the ComboBox. As with the TreeView you may either use the default cell renderer by passing the <span class="classname" dir="ltr">TreeModelColumn</span> to the pack methods, or you may instantiate a specific <span class="classname" dir="ltr">CellRenderer</span> and specify a particular mapping with either <span class="methodname" dir="ltr">add_attribute()</span> or <span class="methodname" dir="ltr">set_cell_data_func()</span>. Note that these methods are in the <span class="classname" dir="ltr">CellLayout</span> base class.</p>
</div>
<div class="division sect1">
<a name="sec-combobox-get"><!--sec-combobox-get--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">11.2. </span>The chosen item</span></h3></div>
<p class="para block block-first">To discover what item, if any, the user has chosen from the ComboBox, call <span class="methodname" dir="ltr">ComboBox::get_active()</span>. This returns a <span class="classname" dir="ltr">TreeModel::iterator</span> that you can dereference to a <span class="classname" dir="ltr">Row</span> in order to read the values in your columns. For instance, you might read an integer ID value from the model, even though you have chosen only to show the human-readable description in the ComboBox. For instance:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">Gtk::TreeModel::iterator iter = m_Combo.get_active();
if(iter)
{
  auto row = *iter;

  //Get the data for the selected row, using our knowledge
  //of the tree model:
  auto id = row[m_Columns.m_col_id];
  set_something_id_chosen(id); //Your own function.
}
else
  set_nothing_chosen(); //Your own function.</pre></div>
</div>
<div class="division sect1">
<a name="sec-combobox-changes"><!--sec-combobox-changes--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">11.3. </span>Responding to changes</span></h3></div>
<p class="para block block-first">
You might need to react to every change of selection in the ComboBox, for instance to update other widgets. To do so, you should handle the <span class="literal" dir="ltr">changed</span> signal. For instance:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">m_combo.signal_changed().connect( sigc::mem_fun(*this,
      &amp;ExampleWindow::on_combo_changed) );</pre></div>
</div>
<div class="division sect1">
<a name="combobox-example-full"><!--combobox-example-full--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">11.4. </span>Full Example</span></h3></div>
<div class=" block figure block-first block-indent">
<a name="figure-combobox-complex"><!--figure-combobox-complex--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 11-1</span> </span>ComboBox</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/combobox_complex.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/combobox/complex" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/combobox/complex">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm/window.h&gt;
#include &lt;gtkmm/comboboxtext.h&gt;
#include &lt;gtkmm/liststore.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  void on_cell_data_extra(const Gtk::TreeModel::const_iterator&amp; iter);

  //Signal handlers:
  void on_combo_changed();


  //Tree model columns:
  class ModelColumns : public Gtk::TreeModel::ColumnRecord
  {
  public:

    ModelColumns()
    { add(m_col_id); add(m_col_name); add(m_col_extra);}

    Gtk::TreeModelColumn&lt;int&gt; m_col_id;
    Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_col_name;
    Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_col_extra;
  };

  ModelColumns m_Columns;

  //Child widgets:
  Gtk::ComboBox m_Combo;
  Gtk::CellRendererText m_cell;
  Glib::RefPtr&lt;Gtk::ListStore&gt; m_refTreeModel;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;gtkmm/application.h&gt;

int main(int argc, char *argv[])
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  //Shows the window and returns when it is closed.
  return app-&gt;make_window_and_run&lt;ExampleWindow&gt;(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;iostream&gt;

ExampleWindow::ExampleWindow()
{
  set_title("ComboBox example");

  //Create the Tree model:
  //m_refTreeModel = Gtk::TreeStore::create(m_Columns);
  m_refTreeModel = Gtk::ListStore::create(m_Columns);
  m_Combo.set_model(m_refTreeModel);

  //Fill the ComboBox's Tree Model:
  auto iter = m_refTreeModel-&gt;append();
  auto row = *iter;
  row[m_Columns.m_col_id] = 1;
  row[m_Columns.m_col_name] = "Billy Bob";
  row[m_Columns.m_col_extra] = "something";
  m_Combo.set_active(iter);
  /*
  auto childrow = *(m_refTreeModel-&gt;append(row.children()));
  childrow[m_Columns.m_col_id] = 11;
  childrow[m_Columns.m_col_name] = "Billy Bob Junior";

  childrow = *(m_refTreeModel-&gt;append(row.children()));
  childrow[m_Columns.m_col_id] = 12;
  childrow[m_Columns.m_col_name] = "Sue Bob";
  */

  row = *(m_refTreeModel-&gt;append());
  row[m_Columns.m_col_id] = 2;
  row[m_Columns.m_col_name] = "Joey Jojo";
  row[m_Columns.m_col_extra] = "yadda";


  row = *(m_refTreeModel-&gt;append());
  row[m_Columns.m_col_id] = 3;
  row[m_Columns.m_col_name] = "Rob McRoberts";
  row[m_Columns.m_col_extra] = "";

  /*
  childrow = *(m_refTreeModel-&gt;append(row.children()));
  childrow[m_Columns.m_col_id] = 31;
  childrow[m_Columns.m_col_name] = "Xavier McRoberts";
  */

  //Add the model columns to the Combo (which is a kind of view),
  //rendering them in the default way:
  m_Combo.pack_start(m_Columns.m_col_id);
  m_Combo.pack_start(m_Columns.m_col_name);

  //An example of adding a cell renderer manually,
  //instead of using pack_start(model_column, Gtk::PackOptions::EXPAND_WIDGET)
  //so we have more control:
  m_Combo.set_cell_data_func(m_cell,
    sigc::mem_fun(*this, &amp;ExampleWindow::on_cell_data_extra));
  m_Combo.pack_start(m_cell);

  //Add the ComboBox to the window.
  set_child(m_Combo);

  //Connect signal handler:
  m_Combo.signal_changed().connect( sigc::mem_fun(*this, &amp;ExampleWindow::on_combo_changed) );
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_cell_data_extra(const Gtk::TreeModel::const_iterator&amp; iter)
{
  auto row = *iter;
  const Glib::ustring extra = row[m_Columns.m_col_extra];

  //Some arbitrary logic just to show that this is where you can do such things:

  //Transform the value, deciding how to represent it as text:
  if(extra.empty())
    m_cell.property_text() = "(none)";
  else
    m_cell.property_text() = "-" + extra + "-";

  //Change other cell renderer properties too:
  m_cell.property_foreground() = (extra == "yadda" ? "red" : "green");
}

void ExampleWindow::on_combo_changed()
{
  const auto iter = m_Combo.get_active();
  if(iter)
  {
    const auto row = *iter;
    if(row)
    {
      //Get the data for the selected row, using our knowledge of the tree
      //model:
      int id = row[m_Columns.m_col_id];
      Glib::ustring name = row[m_Columns.m_col_name];

      std::cout &lt;&lt; " ID=" &lt;&lt; id &lt;&lt; ", name=" &lt;&lt; name &lt;&lt; std::endl;
    }
  }
  else
    std::cout &lt;&lt; "invalid iter" &lt;&lt; std::endl;
}

</pre></div>
</div>
<div class="division sect1">
<a name="combobox-example-simple"><!--combobox-example-simple--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">11.5. </span>Simple Text Example</span></h3></div>
<div class=" block figure block-first block-indent">
<a name="figure-combobox-text"><!--figure-combobox-text--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 11-2</span> </span>ComboBoxText</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/combobox_text.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/combobox/text" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/combobox/text">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm/window.h&gt;
#include &lt;gtkmm/comboboxtext.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_combo_changed();

  //Child widgets:
  Gtk::ComboBoxText m_Combo;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;gtkmm/application.h&gt;

int main(int argc, char *argv[])
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  //Shows the window and returns when it is closed.
  return app-&gt;make_window_and_run&lt;ExampleWindow&gt;(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;iostream&gt;

ExampleWindow::ExampleWindow()
{
  set_title("ComboBoxText example");

  //Fill the combo:
  m_Combo.append("something");
  m_Combo.append("something else");
  m_Combo.append("something or other");
  m_Combo.set_active(1);

  set_child(m_Combo);

  //Connect signal handler:
  m_Combo.signal_changed().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_combo_changed) );
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_combo_changed()
{
  Glib::ustring text = m_Combo.get_active_text();
  if(!(text.empty()))
    std::cout &lt;&lt; "Combo changed: " &lt;&lt; text &lt;&lt; std::endl;
}

</pre></div>
</div>
<div class="division sect1">
<a name="sec-comboboxentry"><!--sec-comboboxentry--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">11.6. </span>ComboBox with an Entry</span></h3></div>
<p class="para block block-first">A <span class="classname" dir="ltr">ComboBox</span> may contain an <span class="classname" dir="ltr">Entry</span> widget for entering of arbitrary text, by specifying <span class="literal" dir="ltr">true</span> for the constructor's <span class="literal" dir="ltr">has_entry</span> parameter.</p>
<div class="autotoc"><ul>
<li>
<span class="label">11.6.1. </span><a class="xref" href="#sec-comboboxentry-text-column" title="The text column">The text column</a>
</li>
<li>
<span class="label">11.6.2. </span><a class="xref" href="#sec-comboboxentry-model" title="The entry">The entry</a>
</li>
<li>
<span class="label">11.6.3. </span><a class="xref" href="#sec-comboboxentry-changes" title="Responding to changes">Responding to changes</a>
</li>
<li>
<span class="label">11.6.4. </span><a class="xref" href="#comboboxentry-example-full" title="Full Example">Full Example</a>
</li>
<li>
<span class="label">11.6.5. </span><a class="xref" href="#comboboxentry-example-simple" title="Simple Text Example">Simple Text Example</a>
</li>
</ul></div>
<div class="division sect2">
<a name="sec-comboboxentry-text-column"><!--sec-comboboxentry-text-column--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">11.6.1. </span>The text column</span></h4></div>
<p class="para block block-first">So that the <span class="classname" dir="ltr">Entry</span> can interact with the drop-down list of choices, you must specify which of your model columns is the text column, with <span class="methodname" dir="ltr">set_entry_text_column()</span>. For instance:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">m_combo.set_entry_text_column(m_columns.m_col_name);</pre></div>
<p class="para block">
When you select a choice from the drop-down menu, the value from this column will be placed in the <span class="classname" dir="ltr">Entry</span>.
</p>
</div>
<div class="division sect2">
<a name="sec-comboboxentry-model"><!--sec-comboboxentry-model--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">11.6.2. </span>The entry</span></h4></div>
<p class="para block block-first">Because the user may enter arbitrary text, an active model row isn't enough to tell us what text the user has entered. Therefore, you should retrieve the <span class="classname" dir="ltr">Entry</span> widget with the <span class="methodname" dir="ltr">ComboBox::get_entry()</span> method and call <span class="methodname" dir="ltr">get_text()</span> on that.
</p>
</div>
<div class="division sect2">
<a name="sec-comboboxentry-changes"><!--sec-comboboxentry-changes--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">11.6.3. </span>Responding to changes</span></h4></div>
<p class="para block block-first">
When the user enters arbitrary text, it may not be enough to connect to the
<span class="literal" dir="ltr">changed</span> signal, which is emitted for every typed character.
It is not emitted when the user presses the <span class="keycap">Enter</span> key. Pressing the <span class="keycap">Enter</span> key or
moving the keyboard focus to another widget may signal that the user has finished
entering text. To be notified of these events, connect to the
<span class="classname" dir="ltr">Entry</span>'s <span class="literal" dir="ltr">activate</span> and
<span class="literal" dir="ltr">focus_out_event</span> signals, like so
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">auto entry = m_Combo.get_entry();
if (entry)
{
  // Alternatively you can connect to m_Combo.signal_changed().
  entry-&gt;signal_changed().connect(sigc::mem_fun(*this,
    &amp;ExampleWindow::on_entry_changed) );

  entry-&gt;signal_activate().connect(sigc::mem_fun(*this,
    &amp;ExampleWindow::on_entry_activate) );

  entry-&gt;signal_focus_out_event().connect(sigc::mem_fun(*this,
    &amp;ExampleWindow::on_entry_focus_out_event) );
}</pre></div>
The <span class="literal" dir="ltr">changed</span> signals of <span class="classname" dir="ltr">ComboBox</span> and
<span class="classname" dir="ltr">Entry</span> are both emitted for every change. It doesn't matter
which one you connect to. But only <span class="classname" dir="ltr">Entry</span>'s
<span class="literal" dir="ltr">focus_out_event</span> signal is useful here.
</p>
<p class="para block">
X events are described in more detail in the
<a class="link" href="#sec-xeventsignals" title="X Event signals">X Event signals</a> section in the appendix.
</p>
</div>
<div class="division sect2">
<a name="comboboxentry-example-full"><!--comboboxentry-example-full--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">11.6.4. </span>Full Example</span></h4></div>
<div class=" block figure block-first block-indent">
<a name="figure-comboboxentry-complex"><!--figure-comboboxentry-complex--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 11-3</span> </span>ComboBox with Entry</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/comboboxentry_complex.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/combobox/entry_complex" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/combobox/entry_complex">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm/window.h&gt;
#include &lt;gtkmm/combobox.h&gt;
#include &lt;gtkmm/liststore.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_combo_changed();
  void on_entry_changed();
  void on_entry_has_focus_changed();

  //Signal connection:
  sigc::connection m_ConnectionHasFocusChanged;
  bool m_entry_had_focus {false};

  //Tree model columns:
  class ModelColumns : public Gtk::TreeModel::ColumnRecord
  {
  public:

    ModelColumns()
    { add(m_col_id); add(m_col_name); }

    Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_col_id; //The data to choose - this must be text.
    Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_col_name;
  };

  ModelColumns m_Columns;

  //Child widgets:
  Gtk::ComboBox m_Combo;
  Glib::RefPtr&lt;Gtk::ListStore&gt; m_refTreeModel;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;gtkmm/application.h&gt;

int main(int argc, char *argv[])
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  //Shows the window and returns when it is closed.
  return app-&gt;make_window_and_run&lt;ExampleWindow&gt;(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;iostream&gt;

ExampleWindow::ExampleWindow()
: m_Combo(true /* has_entry */)
{
  set_title("ComboBox example");

  //Create the Tree model:
  //m_refTreeModel = Gtk::TreeStore::create(m_Columns);
  m_refTreeModel = Gtk::ListStore::create(m_Columns);
  m_Combo.set_model(m_refTreeModel);

  //Fill the ComboBox's Tree Model:
  auto row = *(m_refTreeModel-&gt;append());
  row[m_Columns.m_col_id] = "1";
  row[m_Columns.m_col_name] = "Billy Bob";
  /*
  auto childrow = *(m_refTreeModel-&gt;append(row.children()));
  childrow[m_Columns.m_col_id] = 11;
  childrow[m_Columns.m_col_name] = "Billy Bob Junior";

  childrow = *(m_refTreeModel-&gt;append(row.children()));
  childrow[m_Columns.m_col_id] = 12;
  childrow[m_Columns.m_col_name] = "Sue Bob";
  */

  row = *(m_refTreeModel-&gt;append());
  row[m_Columns.m_col_id] = "2";
  row[m_Columns.m_col_name] = "Joey Jojo";

  row = *(m_refTreeModel-&gt;append());
  row[m_Columns.m_col_id] = "3";
  row[m_Columns.m_col_name] = "Rob McRoberts";

  /*
  childrow = *(m_refTreeModel-&gt;append(row.children()));
  childrow[m_Columns.m_col_id] = 31;
  childrow[m_Columns.m_col_name] = "Xavier McRoberts";
  */

  //Add the model columns to the Combo (which is a kind of view),
  //rendering them in the default way:
  //This is automatically rendered when we use set_entry_text_column().
  //m_Combo.pack_start(m_Columns.m_col_id, Gtk::PackOptions::EXPAND_WIDGET);
  m_Combo.pack_start(m_Columns.m_col_name);

  m_Combo.set_entry_text_column(m_Columns.m_col_id);
  m_Combo.set_active(1);

  //Add the ComboBox to the window.
  set_child(m_Combo);

  //Connect signal handlers:
  m_Combo.signal_changed().connect(sigc::mem_fun(*this, &amp;ExampleWindow::on_combo_changed));

  auto entry = m_Combo.get_entry();
  if (entry)
  {
    entry-&gt;signal_changed().connect(sigc::mem_fun(*this,
      &amp;ExampleWindow::on_entry_changed) );
    m_ConnectionHasFocusChanged = entry-&gt;property_has_focus().signal_changed().
      connect(sigc::mem_fun(*this, &amp;ExampleWindow::on_entry_has_focus_changed));
  }
  else
    std::cout &lt;&lt; "No Entry ???" &lt;&lt; std::endl;
}

ExampleWindow::~ExampleWindow()
{
  // The has_focus changed signal may be emitted while m_Combo is being destructed.
  // The signal handler can generate critical messages, if it's called when
  // m_Combo has been partly destructed.
  m_ConnectionHasFocusChanged.disconnect();
}

void ExampleWindow::on_combo_changed()
{
  auto entry = m_Combo.get_entry();
  if (entry)
  {
    std::cout &lt;&lt; "on_combo_changed(): Row=" &lt;&lt; m_Combo.get_active_row_number()
      &lt;&lt; ", ID=" &lt;&lt; entry-&gt;get_text() &lt;&lt; std::endl;
  }
}

void ExampleWindow::on_entry_changed()
{
  auto entry = m_Combo.get_entry();
  if (entry)
  {
    std::cout &lt;&lt; "on_entry_changed(): Row=" &lt;&lt; m_Combo.get_active_row_number()
      &lt;&lt; ", ID=" &lt;&lt; entry-&gt;get_text() &lt;&lt; std::endl;
  }
}

void ExampleWindow::on_entry_has_focus_changed()
{
  auto entry = m_Combo.get_entry();
  if (entry)
  {
    const bool entry_has_focus = entry-&gt;has_focus();
    if (m_entry_had_focus &amp;&amp; !entry_has_focus)
    {
      // entry-&gt;has_focus() has changed from true to false; entry has lost focus.
      std::cout &lt;&lt; "on_entry_has_focus_changed() to not focused: Row="
        &lt;&lt; m_Combo.get_active_row_number() &lt;&lt; ", ID=" &lt;&lt; entry-&gt;get_text() &lt;&lt; std::endl;
    }
    m_entry_had_focus = entry_has_focus;
  }
}
</pre></div>
</div>
<div class="division sect2">
<a name="comboboxentry-example-simple"><!--comboboxentry-example-simple--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">11.6.5. </span>Simple Text Example</span></h4></div>
<div class=" block figure block-first block-indent">
<a name="figure-comboboxentry-text"><!--figure-comboboxentry-text--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 11-4</span> </span>ComboBoxText with Entry</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/comboboxentry_text.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/combobox/entry_text" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/combobox/entry_text">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm/window.h&gt;
#include &lt;gtkmm/comboboxtext.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_combo_changed();
  void on_entry_changed();
  void on_entry_has_focus_changed();

  //Signal connection:
  sigc::connection m_ConnectionHasFocusChanged;
  bool m_entry_had_focus {false};

  //Child widgets:
  Gtk::ComboBoxText m_Combo;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;gtkmm/application.h&gt;

int main(int argc, char *argv[])
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  //Shows the window and returns when it is closed.
  return app-&gt;make_window_and_run&lt;ExampleWindow&gt;(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;iostream&gt;

ExampleWindow::ExampleWindow()
: m_Combo(true /* has_entry */)
{
  set_title("ComboBoxText example");

  //Fill the combo:
  m_Combo.append("something");
  m_Combo.append("something else");
  m_Combo.append("something or other");
  m_Combo.set_active(0);

  set_child(m_Combo);

  //Connect signal handlers:
  m_Combo.signal_changed().connect(sigc::mem_fun(*this,
    &amp;ExampleWindow::on_combo_changed) );

  auto entry = m_Combo.get_entry();
  if (entry)
  {
    entry-&gt;signal_changed().connect(sigc::mem_fun(*this,
      &amp;ExampleWindow::on_entry_changed));
    m_ConnectionHasFocusChanged = entry-&gt;property_has_focus().signal_changed().
      connect(sigc::mem_fun(*this, &amp;ExampleWindow::on_entry_has_focus_changed));
  }
  else
    std::cout &lt;&lt; "No Entry ???" &lt;&lt; std::endl;

  m_Combo.property_has_frame() = false;
}

ExampleWindow::~ExampleWindow()
{
  // The has_focus changed signal may be emitted while m_Combo is being destructed.
  // The signal handler can generate critical messages, if it's called when
  // m_Combo has been partly destructed.
  m_ConnectionHasFocusChanged.disconnect();
}

void ExampleWindow::on_combo_changed()
{
  std::cout &lt;&lt; "on_combo_changed(): Row=" &lt;&lt; m_Combo.get_active_row_number()
    &lt;&lt; ", Text=" &lt;&lt; m_Combo.get_active_text() &lt;&lt; std::endl;
}

void ExampleWindow::on_entry_changed()
{
  std::cout &lt;&lt; "on_entry_changed(): Row=" &lt;&lt; m_Combo.get_active_row_number()
    &lt;&lt; ", Text=" &lt;&lt; m_Combo.get_active_text() &lt;&lt; std::endl;
}

void ExampleWindow::on_entry_has_focus_changed()
{
  auto entry = m_Combo.get_entry();
  if (entry)
  {
    const bool entry_has_focus = entry-&gt;has_focus();
    if (m_entry_had_focus &amp;&amp; !entry_has_focus)
    {
      // entry-&gt;has_focus() has changed from true to false; entry has lost focus.
      std::cout &lt;&lt; "on_entry_has_focus_changed() to not focused: Row="
        &lt;&lt; m_Combo.get_active_row_number() &lt;&lt; ", ID=" &lt;&lt; entry-&gt;get_text() &lt;&lt; std::endl;
    }
    m_entry_had_focus = entry_has_focus;
  }
}
</pre></div>
</div>
</div>
</div>
<div class="division chapter">
<a name="chapter-textview"><!--chapter-textview--></a><div class="header"><h2 class="chapter title"><span class="title"><span class="label">12. </span>TextView</span></h2></div>
<p class="para block block-first">
The <span class="classname" dir="ltr">TextView</span> widget can be used to display and edit
large amounts of formatted text. Like the <span class="classname" dir="ltr">TreeView</span>, it
has a model/view design. In this case the <span class="classname" dir="ltr">TextBuffer</span> is
the model.
</p>
<div class="autotoc"><ul>
<li>
<span class="label">12.1. </span><a class="xref" href="#sec-textview-buffer" title="The Buffer">The Buffer</a>
</li>
<li>
<span class="label">12.2. </span><a class="xref" href="#sec-widgets-and-childanchors" title="Widgets and ChildAnchors">Widgets and ChildAnchors</a>
</li>
<li>
<span class="label">12.3. </span><a class="xref" href="#sec-textview-examples" title="Examples">Examples</a>
</li>
</ul></div>
<div class="division sect1">
<a name="sec-textview-buffer"><!--sec-textview-buffer--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">12.1. </span>The Buffer</span></h3></div>
<p class="para block block-first">
<span class="classname" dir="ltr">Gtk::TextBuffer</span> is a model containing the data for the
<span class="classname" dir="ltr">Gtk::TextView</span>, like the
<span class="classname" dir="ltr">Gtk::TreeModel</span> used by <span class="classname" dir="ltr">Gtk::TreeView</span>.
This allows two or more <span class="classname" dir="ltr">Gtk::TextView</span>s to share the same
<span class="classname" dir="ltr">TextBuffer</span>, and allows those TextBuffers to be displayed
slightly differently. Or you could maintain several
<span class="classname" dir="ltr">Gtk::TextBuffer</span>s and choose to display each one at different
times in the same <span class="classname" dir="ltr">Gtk::TextView</span> widget.
</p>
<p class="para block">
The <span class="classname" dir="ltr">TextView</span> creates its own default
<span class="classname" dir="ltr">TextBuffer</span>, which you can access via the
<span class="methodname" dir="ltr">get_buffer()</span> method.
</p>
<p class="para block"><a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1TextBuffer.html" title="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1TextBuffer.html">Reference</a></p>
<div class="autotoc"><ul>
<li>
<span class="label">12.1.1. </span><a class="xref" href="#textview-iterators" title="Iterators">Iterators</a>
</li>
<li>
<span class="label">12.1.2. </span><a class="xref" href="#textview-formatting" title="Tags and Formatting">Tags and Formatting</a>
</li>
<li>
<span class="label">12.1.3. </span><a class="xref" href="#textview-marks" title="Marks">Marks</a>
</li>
<li>
<span class="label">12.1.4. </span><a class="xref" href="#textview-view" title="The View">The View</a>
</li>
</ul></div>
<div class="division sect2">
<a name="textview-iterators"><!--textview-iterators--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">12.1.1. </span>Iterators</span></h4></div>
<p class="para block block-first">
A <span class="classname" dir="ltr">Gtk::TextBuffer::iterator</span> and a <span class="classname" dir="ltr">Gtk::TextBuffer::const_iterator</span>
represent a position between two characters in the text buffer. Whenever the buffer
is modified in a way that affects the number of characters in the buffer, all outstanding
iterators become invalid. Because of this, iterators can't be used to preserve positions
across buffer modifications. To preserve a position, use <span class="classname" dir="ltr">Gtk::TextBuffer::Mark</span>.
</p>
<p class="para block"><a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1TextIter.html" title="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1TextIter.html">Reference</a></p>
</div>
<div class="division sect2">
<a name="textview-formatting"><!--textview-formatting--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">12.1.2. </span>Tags and Formatting</span></h4></div>
<div class="autotoc"><ul>
<li>
<span class="label">12.1.2.1. </span><a class="xref" href="#textview-formatting-tags" title="Tags">Tags</a>
</li>
<li>
<span class="label">12.1.2.2. </span><a class="xref" href="#textview-formatting-tagtable" title="TagTable">TagTable</a>
</li>
<li>
<span class="label">12.1.2.3. </span><a class="xref" href="#textview-formatting-applying-tags" title="Applying Tags">Applying Tags</a>
</li>
</ul></div>
<div class="division sect3">
<a name="textview-formatting-tags"><!--textview-formatting-tags--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">12.1.2.1. </span>Tags</span></h5></div>
<p class="para block block-first">
To specify that some text in the buffer should have specific formatting, you must define a tag to hold that formatting information, and then apply that tag to the region of text. For instance, to define the tag and its properties:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">auto refTagMatch = Gtk::TextBuffer::Tag::create();
refTagMatch-&gt;property_background() = "orange";</pre></div>
<p class="para block">
You can specify a name for the <span class="classname" dir="ltr">Tag</span> when using the
<span class="methodname" dir="ltr">create()</span> method, but it is not necessary.
</p>
<p class="para block">
The <span class="classname" dir="ltr">Tag</span> class has many other properties.
</p>
<p class="para block"><a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1TextTag.html" title="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1TextTag.html">Reference</a></p>
</div>
<div class="division sect3">
<a name="textview-formatting-tagtable"><!--textview-formatting-tagtable--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">12.1.2.2. </span>TagTable</span></h5></div>
<p class="para block block-first">
Each <span class="classname" dir="ltr">Gtk::TextBuffer</span> uses a
<span class="classname" dir="ltr">Gtk::TextBuffer::TagTable</span>, which contains the
<span class="classname" dir="ltr">Tag</span>s for that buffer. 2 or more
<span class="classname" dir="ltr">TextBuffer</span>s may share the same
<span class="classname" dir="ltr">TagTable</span>. When you create <span class="classname" dir="ltr">Tag</span>s
you should add them to the <span class="classname" dir="ltr">TagTable</span>. For instance:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">auto refTagTable = Gtk::TextBuffer::TagTable::create();
refTagTable-&gt;add(refTagMatch);
//Hopefully a future version of <span class="application">gtkmm</span> will have a set_tag_table() method,
//for use after creation of the buffer.
auto refBuffer = Gtk::TextBuffer::create(refTagTable);</pre></div>
<p class="para block">
You can also use <span class="methodname" dir="ltr">get_tag_table()</span> to get, and maybe modify,
the <span class="classname" dir="ltr">TextBuffer</span>'s default <span class="classname" dir="ltr">TagTable</span>
instead of creating one explicitly.
</p>
<p class="para block"><a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1TextTagTable.html" title="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1TextTagTable.html">Reference</a></p>
</div>
<div class="division sect3">
<a name="textview-formatting-applying-tags"><!--textview-formatting-applying-tags--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">12.1.2.3. </span>Applying Tags</span></h5></div>
<p class="para block block-first">
If you have created a <span class="classname" dir="ltr">Tag</span> and added it to the
<span class="classname" dir="ltr">TagTable</span>, you may apply that tag to part of the
<span class="classname" dir="ltr">TextBuffer</span> so that some of the text is displayed with that
formatting. You define the start and end of the range of text by specifying
<span class="classname" dir="ltr">Gtk::TextBuffer::iterator</span>s. For instance:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">refBuffer-&gt;apply_tag(refTagMatch, iterRangeStart, iterRangeStop);</pre></div>
<p class="para block">
Or you could specify the tag when first inserting the text:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">refBuffer-&gt;insert_with_tag(iter, "Some text", refTagMatch);</pre></div>
<p class="para block">
You can apply more than one <span class="classname" dir="ltr">Tag</span> to the same text, by
using <span class="methodname" dir="ltr">apply_tag()</span> more than once, or by using
<span class="methodname" dir="ltr">insert_with_tags()</span>. The <span class="classname" dir="ltr">Tag</span>s might
specify different values for the same properties, but you can resolve these
conflicts by using <span class="methodname" dir="ltr">Tag::set_priority()</span>.
</p>
</div>
</div>
<div class="division sect2">
<a name="textview-marks"><!--textview-marks--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">12.1.3. </span>Marks</span></h4></div>
<p class="para block block-first">
<span class="classname" dir="ltr">TextBuffer</span> iterators are generally invalidated when the
text changes, but you can use a <span class="classname" dir="ltr">Gtk::TextBuffer::Mark</span> to
remember a position in these situations. For instance,
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">auto refMark = refBuffer-&gt;create_mark(iter);</pre></div>
<p class="para block">
You can then use the <span class="methodname" dir="ltr">get_iter()</span> method later to create an
iterator for the <span class="classname" dir="ltr">Mark</span>'s new position.
</p>
<p class="para block">
There are two built-in <span class="classname" dir="ltr">Mark</span>s - <span class="literal" dir="ltr">insert</span>
and <span class="literal" dir="ltr">selection_bound</span>, which you can access with
<span class="classname" dir="ltr">TextBuffer</span>'s <span class="methodname" dir="ltr">get_insert()</span> and
<span class="methodname" dir="ltr">get_selection_bound()</span> methods.
</p>
<p class="para block"><a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1TextMark.html" title="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1TextMark.html">Reference</a></p>
</div>
<div class="division sect2">
<a name="textview-view"><!--textview-view--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">12.1.4. </span>The View</span></h4></div>
<p class="para block block-first">
As mentioned above, each <span class="classname" dir="ltr">TextView</span> has a
<span class="classname" dir="ltr">TextBuffer</span>, and one or more
<span class="classname" dir="ltr">TextView</span>s can share the same
<span class="classname" dir="ltr">TextBuffer</span>.
</p>
<p class="para block">
Like the <span class="classname" dir="ltr">TreeView</span>, you should probably put your
<span class="classname" dir="ltr">TextView</span> inside a <span class="classname" dir="ltr">ScrolledWindow</span>
to allow the user to see and move around the whole text area with
scrollbars.
</p>
<p class="para block"><a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1TextView.html" title="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1TextView.html">Reference</a></p>
<div class="autotoc"><ul>
<li>
<span class="label">12.1.4.1. </span><a class="xref" href="#textview-default-formatting" title="Default formatting">Default formatting</a>
</li>
<li>
<span class="label">12.1.4.2. </span><a class="xref" href="#textview-scrolling" title="Scrolling">Scrolling</a>
</li>
</ul></div>
<div class="division sect3">
<a name="textview-default-formatting"><!--textview-default-formatting--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">12.1.4.1. </span>Default formatting</span></h5></div>
<p class="para block block-first">
<span class="classname" dir="ltr">TextView</span> has various methods which allow you to change
the presentation of the buffer for this particular view. Some of these may be
overridden by the <span class="classname" dir="ltr">Gtk::TextTag</span>s in the buffer, if they
specify the same things. For instance, <span class="methodname" dir="ltr">set_left_margin()</span>,
<span class="methodname" dir="ltr">set_right_margin()</span>, <span class="methodname" dir="ltr">set_indent()</span>,
etc.
</p>
</div>
<div class="division sect3">
<a name="textview-scrolling"><!--textview-scrolling--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">12.1.4.2. </span>Scrolling</span></h5></div>
<p class="para block block-first">
<span class="classname" dir="ltr">Gtk::TextView</span> has various
<span class="methodname" dir="ltr">scroll_to()</span> methods. These allow you to ensure that a
particular part of the text buffer is visible. For instance, your application's
Find feature might use <span class="methodname" dir="ltr">Gtk::TextView::scroll_to()</span> to
show the found text.
</p>
</div>
</div>
</div>
<div class="division sect1">
<a name="sec-widgets-and-childanchors"><!--sec-widgets-and-childanchors--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">12.2. </span>Widgets and ChildAnchors</span></h3></div>
<p class="para block block-first">
You can embed widgets, such as <span class="classname" dir="ltr">Gtk::Button</span>s, in the
text. Each such child widget needs a <span class="classname" dir="ltr">ChildAnchor</span>.
ChildAnchors are associated with <span class="classname" dir="ltr">iterators</span>. For
instance, to create a child anchor at a particular position, use
<span class="methodname" dir="ltr">Gtk::TextBuffer::create_child_anchor()</span>:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">auto refAnchor = refBuffer-&gt;create_child_anchor(iter);</pre></div>
<p class="para block">
Then, to add a widget at that position, use
<span class="methodname" dir="ltr">Gtk::TextView::add_child_at_anchor()</span>:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">m_TextView.add_child_at_anchor(m_Button, refAnchor);</pre></div>
<p class="para block"><a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1TextChildAnchor.html" title="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1TextChildAnchor.html">Reference</a></p>
</div>
<div class="division sect1">
<a name="sec-textview-examples"><!--sec-textview-examples--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">12.3. </span>Examples</span></h3></div>
<div class="autotoc"><ul><li>
<span class="label">12.3.1. </span><a class="xref" href="#textview-example-simple" title="Simple Example">Simple Example</a>
</li></ul></div>
<div class="division sect2">
<a name="textview-example-simple"><!--textview-example-simple--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">12.3.1. </span>Simple Example</span></h4></div>
<div class=" block figure block-first block-indent">
<a name="figure-textview"><!--figure-textview--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 12-1</span> </span>TextView</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/textview.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/textview/" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/textview/">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:

  void fill_buffers();

  //Signal handlers:
  void on_button_quit();
  void on_button_buffer1();
  void on_button_buffer2();

  //Child widgets:
  Gtk::Box m_VBox;

  Gtk::ScrolledWindow m_ScrolledWindow;
  Gtk::TextView m_TextView;

  Glib::RefPtr&lt;Gtk::TextBuffer&gt; m_refTextBuffer1, m_refTextBuffer2;

  Gtk::Box m_ButtonBox;
  Gtk::Button m_Button_Quit, m_Button_Buffer1, m_Button_Buffer2;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;gtkmm/application.h&gt;

int main(int argc, char *argv[])
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  //Shows the window and returns when it is closed.
  return app-&gt;make_window_and_run&lt;ExampleWindow&gt;(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"

ExampleWindow::ExampleWindow()
: m_VBox(Gtk::Orientation::VERTICAL),
  m_Button_Quit("_Quit", true),
  m_Button_Buffer1("Use buffer 1"),
  m_Button_Buffer2("Use buffer 2")
{
  set_title("Gtk::TextView example");
  set_default_size(400, 200);

  m_VBox.set_margin(5);
  set_child(m_VBox);

  //Add the TreeView, inside a ScrolledWindow, with the button underneath:
  m_ScrolledWindow.set_child(m_TextView);

  //Only show the scrollbars when they are necessary:
  m_ScrolledWindow.set_policy(Gtk::PolicyType::AUTOMATIC, Gtk::PolicyType::AUTOMATIC);
  m_ScrolledWindow.set_expand();

  m_VBox.append(m_ScrolledWindow);

  //append buttons:
  m_VBox.append(m_ButtonBox);

  m_Button_Buffer1.set_hexpand(true);
  m_Button_Buffer1.set_halign(Gtk::Align::END);
  m_ButtonBox.append(m_Button_Buffer1);
  m_ButtonBox.append(m_Button_Buffer2);
  m_ButtonBox.append(m_Button_Quit);
  m_ButtonBox.set_margin(5);
  m_ButtonBox.set_spacing(5);

  //Connect signals:
  m_Button_Quit.signal_clicked().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_quit) );
  m_Button_Buffer1.signal_clicked().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_buffer1) );
  m_Button_Buffer2.signal_clicked().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_buffer2) );

  fill_buffers();
  on_button_buffer1();
}

void ExampleWindow::fill_buffers()
{
  m_refTextBuffer1 = Gtk::TextBuffer::create();
  m_refTextBuffer1-&gt;set_text("This is the text from TextBuffer #1.");

  m_refTextBuffer2 = Gtk::TextBuffer::create();
  m_refTextBuffer2-&gt;set_text(
          "This is some alternative text, from TextBuffer #2.");

}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_button_quit()
{
  hide();
}

void ExampleWindow::on_button_buffer1()
{
  m_TextView.set_buffer(m_refTextBuffer1);
}

void ExampleWindow::on_button_buffer2()
{
  m_TextView.set_buffer(m_refTextBuffer2);
}

</pre></div>
</div>
</div>
</div>
<div class="division chapter">
<a name="chapter-menus-and-toolbars"><!--chapter-menus-and-toolbars--></a><div class="header"><h2 class="chapter title"><span class="title"><span class="label">13. </span>Menus and Toolbars</span></h2></div>
<p class="para block block-first">
There are specific APIs for menus and toolbars, but you should usually deal
with them together, creating <span class="classname" dir="ltr">Gio::SimpleAction</span>s that
you can refer to in both menus and toolbars. In this way you can handle
activation of the action instead of responding to the menu and toolbar items
separately. And you can enable or disable both the menu and toolbar item via
the action. <span class="classname" dir="ltr">Gtk::Builder</span> can create menus and toolbars.
</p>
<p class="para block">
This involves the use of the <span class="classname" dir="ltr">Gio::SimpleActionGroup</span>,
<span class="classname" dir="ltr">Gio::SimpleAction</span> and <span class="classname" dir="ltr">Gtk::Builder</span>
classes, all of which should be instantiated via their <span class="methodname" dir="ltr">create()</span>
methods, which return <span class="classname" dir="ltr">RefPtr</span>s.
</p>
<div class="autotoc"><ul>
<li>
<span class="label">13.1. </span><a class="xref" href="#sec-actions" title="Actions">Actions</a>
</li>
<li>
<span class="label">13.2. </span><a class="xref" href="#sec-menubar-and-toolbar" title="Menubar and Toolbar">Menubar and Toolbar</a>
</li>
<li>
<span class="label">13.3. </span><a class="xref" href="#sec-menus-popup" title="Popup Menus">Popup Menus</a>
</li>
<li>
<span class="label">13.4. </span><a class="xref" href="#sec-gio-resource" title="Gio::Resource and glib-compile-resources">Gio::Resource and glib-compile-resources</a>
</li>
<li>
<span class="label">13.5. </span><a class="xref" href="#sec-menus-examples" title="Examples">Examples</a>
</li>
</ul></div>
<div class="division sect1">
<a name="sec-actions"><!--sec-actions--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">13.1. </span>Actions</span></h3></div>
<p class="para block block-first">
First create the <span class="classname" dir="ltr">Gio::SimpleAction</span>s and add them to a
<span class="classname" dir="ltr">Gio::SimpleActionGroup</span>, with
<span class="methodname" dir="ltr">Gio::ActionMap::add_action()</span>.
(<span class="classname" dir="ltr">Gio::ActionMap</span> is a base class of
<span class="classname" dir="ltr">Gio::SimpleActionGroup</span>.) Then add the action group to
your window with <span class="methodname" dir="ltr">Gtk::Widget::insert_action_group()</span>.
</p>
<p class="para block">
The arguments to <span class="methodname" dir="ltr">add_action()</span> specify the action's
name, which is used in the menu items and toolbar buttons. You can also specify
a signal handler when calling <span class="methodname" dir="ltr">add_action()</span>. This signal
handler will be called when the action is activated via either a menu item or
a toolbar button.
</p>
<p class="para block">For instance:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">m_refActionGroup = Gio::SimpleActionGroup::create();

m_refActionGroup-&gt;add_action("new", sigc::mem_fun(*this, &amp;ExampleWindow::on_action_file_new));
m_refActionGroup-&gt;add_action("open", sigc::mem_fun(*this, &amp;ExampleWindow::on_action_file_open));
m_refActionGroup-&gt;add_action("quit", sigc::mem_fun(*this, &amp;ExampleWindow::on_action_file_quit));

insert_action_group("example", m_refActionGroup);
</pre></div>
<p class="para block">
If you use an <span class="classname" dir="ltr">Gtk::ApplicationWindow</span>, you don't have to
create your own action group. <span class="classname" dir="ltr">Gio::ActionGroup</span> and
<span class="classname" dir="ltr">Gio::ActionMap</span> are base classes of
<span class="classname" dir="ltr">Gtk::ApplicationWindow</span>.
</p>
</div>
<div class="division sect1">
<a name="sec-menubar-and-toolbar"><!--sec-menubar-and-toolbar--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">13.2. </span>Menubar and Toolbar</span></h3></div>
<p class="para block block-first">
Next you should create a <span class="classname" dir="ltr">Gtk::Builder</span>. At this point is
also a good idea to tell the application to respond to keyboard shortcuts,
by using <span class="methodname" dir="ltr">Gtk::Application::set_accel_for_action()</span>.
</p>
<p class="para block">For instance,
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">m_refBuilder = Gtk::Builder::create();

app-&gt;set_accel_for_action("example.new", "&lt;Primary&gt;n");
app-&gt;set_accel_for_action("example.quit", "&lt;Primary&gt;q");
app-&gt;set_accel_for_action("example.copy", "&lt;Primary&gt;c");
app-&gt;set_accel_for_action("example.paste", "&lt;Primary&gt;v");
</pre></div>
<p class="para block">
If your main window is derived from <span class="classname" dir="ltr">ApplicationWindow</span> and
you instantiate your menubar with <span class="methodname" dir="ltr">Gtk::Application::set_menubar()</span>,
then you don't have to call <span class="methodname" dir="ltr">set_accel_for_action()</span>.
See <a class="link" href="#menu-example-main" title="Application Menu and Main Menu example">Application Menu and Main Menu example</a>
for an example.
</p>
<p class="para block">
Then, you can define the actual visible layout of the menus and toolbars, and
add the UI layout to the <span class="classname" dir="ltr">Builder</span>. This "ui
string" uses an XML format, in which you should mention the names of the
actions that you have already created. For instance:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">Glib::ustring ui_info =
  "&lt;interface&gt;"
  "  &lt;menu id='menubar'&gt;"
  "    &lt;submenu&gt;"
  "      &lt;attribute name='label' translatable='yes'&gt;_File&lt;/attribute&gt;"
  "      &lt;section&gt;"
  "        &lt;item&gt;"
  "          &lt;attribute name='label' translatable='yes'&gt;_New&lt;/attribute&gt;"
  "          &lt;attribute name='action'&gt;example.new&lt;/attribute&gt;"
  "          &lt;attribute name='accel'&gt;&amp;lt;Primary&amp;gt;n&lt;/attribute&gt;"
  "        &lt;/item&gt;"
  "      &lt;/section&gt;"
  "      &lt;section&gt;"
  "        &lt;item&gt;"
  "          &lt;attribute name='label' translatable='yes'&gt;_Quit&lt;/attribute&gt;"
  "          &lt;attribute name='action'&gt;example.quit&lt;/attribute&gt;"
  "          &lt;attribute name='accel'&gt;&amp;lt;Primary&amp;gt;q&lt;/attribute&gt;"
  "        &lt;/item&gt;"
  "      &lt;/section&gt;"
  "    &lt;/submenu&gt;"
  "    &lt;submenu&gt;"
  "      &lt;attribute name='label' translatable='yes'&gt;_Edit&lt;/attribute&gt;"
  "      &lt;item&gt;"
  "        &lt;attribute name='label' translatable='yes'&gt;_Copy&lt;/attribute&gt;"
  "        &lt;attribute name='action'&gt;example.copy&lt;/attribute&gt;"
  "        &lt;attribute name='accel'&gt;&amp;lt;Primary&amp;gt;c&lt;/attribute&gt;"
  "      &lt;/item&gt;"
  "      &lt;item&gt;"
  "        &lt;attribute name='label' translatable='yes'&gt;_Paste&lt;/attribute&gt;"
  "        &lt;attribute name='action'&gt;example.paste&lt;/attribute&gt;"
  "        &lt;attribute name='accel'&gt;&amp;lt;Primary&amp;gt;v&lt;/attribute&gt;"
  "      &lt;/item&gt;"
  "    &lt;/submenu&gt;"
  "  &lt;/menu&gt;"
  "&lt;/interface&gt;";

m_refBuilder-&gt;add_from_string(ui_info);
m_refBuilder-&gt;add_from_resource("/toolbar/toolbar.glade");
</pre></div>
<p class="para block">This is where we specify the names of the menu items as they will be seen
by users in the menu. Therefore, this is where you should make strings
translatable, by adding <span class="literal" dir="ltr">translatable='yes'</span>.
</p>
<p class="para block">
To instantiate a <span class="classname" dir="ltr">Gtk::MenuBar</span> and
<span class="classname" dir="ltr">Gtk::Toolbar</span> which you can actually show, you should use
the <span class="methodname" dir="ltr">Builder::get_object()</span> and
<span class="methodname" dir="ltr">Builder::get_widget()</span> methods, and then add the widgets
to a container. For instance:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">auto gmenu = m_refBuilder-&gt;get_object&lt;Gio::Menu&gt;("menubar");
auto pMenuBar = Gtk::make_managed&lt;Gtk::MenuBar&gt;(gmenu);
m_Box.append(*pMenuBar);

auto toolbar = m_refBuilder-&gt;get_widget&lt;Gtk::Toolbar&gt;("toolbar");
m_Box.append(*toolbar);
</pre></div>
</div>
<div class="division sect1">
<a name="sec-menus-popup"><!--sec-menus-popup--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">13.3. </span>Popup Menus</span></h3></div>
<p class="para block block-first">
<span class="classname" dir="ltr">Menus</span> are normally just added to a window, but they can
also be displayed temporarily as the result of a mouse button click. For
instance, a context menu might be displayed when the user clicks their right
mouse button.
</p>
<p class="para block">For instance:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">Glib::ustring ui_info =
  "&lt;interface&gt;"
  "  &lt;menu id='menu-examplepopup'&gt;"
  "    &lt;section&gt;"
  "      &lt;item&gt;"
  "        &lt;attribute name='label' translatable='yes'&gt;Edit&lt;/attribute&gt;"
  "        &lt;attribute name='action'&gt;examplepopup.edit&lt;/attribute&gt;"
  "      &lt;/item&gt;"
  "      &lt;item&gt;"
  "        &lt;attribute name='label' translatable='yes'&gt;Process&lt;/attribute&gt;"
  "        &lt;attribute name='action'&gt;examplepopup.process&lt;/attribute&gt;"
  "      &lt;/item&gt;"
  "      &lt;item&gt;"
  "        &lt;attribute name='label' translatable='yes'&gt;Remove&lt;/attribute&gt;"
  "        &lt;attribute name='action'&gt;examplepopup.remove&lt;/attribute&gt;"
  "      &lt;/item&gt;"
  "    &lt;/section&gt;"
  "  &lt;/menu&gt;"
  "&lt;/interface&gt;";

m_refBuilder-&gt;add_from_string(ui_info);

auto gmenu = m_refBuilder-&gt;get_object&lt;Gio::Menu&gt;("menu-examplepopup");
m_pMenuPopup = std::make_unique&lt;Gtk::Menu&gt;(gmenu);
</pre></div>
<p class="para block">
To show the popup menu, use <span class="classname" dir="ltr">Gtk::Menu</span>'s
<span class="methodname" dir="ltr">popup()</span> method, providing the button identifier and the
time of activation, as provided by the <span class="literal" dir="ltr">button_press_event</span>
signal, which you will need to handle anyway. For instance:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">bool ExampleWindow::on_button_press_event(GdkEventButton* event)
{
  if( (event-&gt;type == GDK_BUTTON_PRESS) &amp;&amp; (event-&gt;button == 3) )
  {
    if(!m_pMenuPopup-&gt;get_attach_widget())
      m_pMenuPopup-&gt;attach_to_widget(*this);

    m_pMenuPopup-&gt;popup(event-&gt;button, event-&gt;time);
    return true; //It has been handled.
  }
  else
    return false;
}
</pre></div>
</div>
<div class="division sect1">
<a name="sec-gio-resource"><!--sec-gio-resource--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">13.4. </span>Gio::Resource and glib-compile-resources</span></h3></div>
<p class="para block block-first">
Applications and libraries often contain binary or textual data that is
really part of the application, rather than user data. For instance
<span class="classname" dir="ltr">Gtk::Builder</span> <span class="filename" dir="ltr">.glade</span> files,
splashscreen images, <span class="classname" dir="ltr">Gio::Menu</span> markup xml, CSS files,
icons, etc. These are often shipped as files in <span class="filename" dir="ltr">$datadir/appname</span>,
or manually included as literal strings in the code.
</p>
<p class="para block">
The <span class="classname" dir="ltr">Gio::Resource</span> API and the <span class="application">glib-compile-resources</span>
program provide a convenient and efficient alternative to this, which has some nice properties. You
maintain the files as normal files, so it's easy to edit them, but during the build the files
are combined into a binary bundle that is linked into the executable. This means that loading
the resource files is efficient (as they are already in memory, shared with other instances) and
simple (no need to check for things like I/O errors or locate the files in the filesystem). It
also makes it easier to create relocatable applications.
</p>
<p class="para block">
Resource bundles are created by the <a class="ulink" href="https://developer.gnome.org/gio/stable/glib-compile-resources.html" title="https://developer.gnome.org/gio/stable/glib-compile-resources.html">glib-compile-resources</a>
program which takes an xml file that describes the bundle, and a set of files that the xml references.
These are combined into a binary resource bundle.
</p>
<p class="para block"><a class="ulink" href="http://developer.gnome.org/glibmm/unstable/classGio_1_1Resource.html" title="http://developer.gnome.org/glibmm/unstable/classGio_1_1Resource.html">Gio::Resource Reference</a></p>
<p class="para block">
An example:
<div dir="ltr" class=" block programlisting block-indent block-first"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;gresources&gt;
  &lt;gresource prefix="/toolbar"&gt;
    &lt;file preprocess="xml-stripblanks"&gt;toolbar.glade&lt;/file&gt;
    &lt;file&gt;rain.png&lt;/file&gt;
  &lt;/gresource&gt;
&lt;/gresources&gt;
</pre></div>
This will create a resource bundle with the files
<div class="block list itemizedlist"><ul class="itemizedlist">
<li class="li-first"><span class="para"><span class="filename" dir="ltr">/toolbar/toolbar.glade</span></span></li>
<li><span class="para"><span class="filename" dir="ltr">/toolbar/rain.png</span></span></li>
</ul></div>
</p>
<p class="para block">
You can then use <span class="application">glib-compile-resources</span> to compile the xml to a binary bundle
that you can load with <span class="methodname" dir="ltr">Gio::Resource::create_from_file()</span>.
However, it's more common to use the <span class="parameter" dir="ltr">--generate-source</span>
argument to create a C source file to link directly into your application. E.g.
<div dir="ltr" class=" block screen block-indent"><pre class="screen">$ glib-compile-resources --target=resources.c --generate-source toolbar.gresource.xml</pre></div>
</p>
<p class="para block">
Once a <span class="classname" dir="ltr">Gio::Resource</span> has been created and registered all the data
in it can be accessed globally in the process by using API calls like
<span class="methodname" dir="ltr">Gio::Resource::open_stream_from_global_resources()</span>
to stream the data or <span class="methodname" dir="ltr">Gio::Resource::lookup_data_in_global_resources()</span>
to get a direct pointer to the data. You can also use URIs like <span class="uri" dir="ltr">resource:///toolbar/rain.png</span>
with <span class="classname" dir="ltr">Gio::File</span> to access the resource data.
</p>
<p class="para block">
Often you don't need a <span class="classname" dir="ltr">Gio::Resource</span> instance,
because resource data can be loaded with methods such as
<span class="methodname" dir="ltr">Gdk::Pixbuf::create_from_resource()</span>,
<span class="methodname" dir="ltr">Gtk::Builder::add_from_resource()</span> and
<span class="methodname" dir="ltr">Gtk::Image::set_from_resource()</span>.
</p>
</div>
<div class="division sect1">
<a name="sec-menus-examples"><!--sec-menus-examples--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">13.5. </span>Examples</span></h3></div>
<div class="autotoc"><ul>
<li>
<span class="label">13.5.1. </span><a class="xref" href="#menu-example-main" title="Application Menu and Main Menu example">Application Menu and Main Menu example</a>
</li>
<li>
<span class="label">13.5.2. </span><a class="xref" href="#menu-example-main2" title="Main Menu example">Main Menu example</a>
</li>
<li>
<span class="label">13.5.3. </span><a class="xref" href="#menu-example-popup" title="Popup Menu example">Popup Menu example</a>
</li>
</ul></div>
<div class="division sect2">
<a name="menu-example-main"><!--menu-example-main--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">13.5.1. </span>Application Menu and Main Menu example</span></h4></div>
<p class="para block block-first">
This program contains an application menu, a menubar and a toolbar.
Classes are derived from <span class="classname" dir="ltr">Gtk::Application</span> and
<span class="classname" dir="ltr">Gtk::ApplicationWindow</span>.
</p>
<div class=" block figure block-indent">
<a name="figure-menus-mainmenu"><!--figure-menus-mainmenu--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 13-1</span> </span>App and Main Menu</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/main_menu.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/menus/main_menu/" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/menus/main_menu/">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::ApplicationWindow
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_menu_others();

  void on_menu_choices(const Glib::ustring&amp; parameter);
  void on_menu_choices_other(int parameter);
  void on_menu_toggle();

  //Child widgets:
  Gtk::Box m_Box;

  Glib::RefPtr&lt;Gtk::Builder&gt; m_refBuilder;

  //Two sets of choices:
  Glib::RefPtr&lt;Gio::SimpleAction&gt; m_refChoice;
  Glib::RefPtr&lt;Gio::SimpleAction&gt; m_refChoiceOther;

  Glib::RefPtr&lt;Gio::SimpleAction&gt; m_refToggle;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">exampleapplication.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEAPPLICATION_H
#define GTKMM_EXAMPLEAPPLICATION_H

#include &lt;gtkmm.h&gt;

class ExampleApplication : public Gtk::Application
{
protected:
  ExampleApplication();

public:
  static Glib::RefPtr&lt;ExampleApplication&gt; create();

protected:
  //Overrides of default signal handlers:
  void on_startup() override;
  void on_activate() override;

private:
  void create_window();

  void on_window_hide(Gtk::Window* window);
  void on_menu_file_new_generic();
  void on_menu_file_quit();
  void on_menu_help_about();

  Glib::RefPtr&lt;Gtk::Builder&gt; m_refBuilder;
};

#endif /* GTKMM_EXAMPLEAPPLICATION_H */
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "exampleapplication.h"

int main(int argc, char* argv[])
{
  auto application = ExampleApplication::create();

  // Start the application, showing the initial window,
  // and opening extra windows for any files that it is asked to open,
  // for instance as a command-line parameter.
  // run() will return when the last window has been closed by the user.
  const int status = application-&gt;run(argc, argv);
  return status;
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;iostream&gt;

ExampleWindow::ExampleWindow()
: Gtk::ApplicationWindow(),
  m_Box(Gtk::Orientation::VERTICAL)
{
  set_title("Main menu example");
  set_default_size(300, 100);

  // ExampleApplication displays the menubar. Other stuff, such as a toolbar,
  // is put into the box.
  set_child(m_Box);

  // Create actions for menus and toolbars.
  // We can use add_action() because Gtk::ApplicationWindow derives from Gio::ActionMap.
  // This Action Map uses a "win." prefix for the actions.
  // Therefore, for instance, "win.copy", is used in ExampleApplication::on_startup()
  // to layout the menu.

  //Edit menu:
  add_action("copy", sigc::mem_fun(*this, &amp;ExampleWindow::on_menu_others));
  add_action("paste", sigc::mem_fun(*this, &amp;ExampleWindow::on_menu_others));
  add_action("something", sigc::mem_fun(*this, &amp;ExampleWindow::on_menu_others));

  //Choices menus, to demonstrate Radio items,
  //using our convenience methods for string and int radio values:
  m_refChoice = add_action_radio_string("choice",
    sigc::mem_fun(*this, &amp;ExampleWindow::on_menu_choices), "a");

  m_refChoiceOther = add_action_radio_integer("choiceother",
    sigc::mem_fun(*this, &amp;ExampleWindow::on_menu_choices_other), 1);

  m_refToggle = add_action_bool("sometoggle",
    sigc::mem_fun(*this, &amp;ExampleWindow::on_menu_toggle), false);

  //Help menu:
  add_action("about", sigc::mem_fun(*this, &amp;ExampleWindow::on_menu_others));

  //Create the toolbar and add it to a container widget:

  m_refBuilder = Gtk::Builder::create();

  Glib::ustring ui_info =
    "&lt;!-- Generated with glade 3.18.3 and then changed manually --&gt;"
    "&lt;interface&gt;"
    "  &lt;object class='GtkBox' id='toolbar'&gt;"
    "    &lt;property name='can_focus'&gt;False&lt;/property&gt;"
    "    &lt;child&gt;"
    "      &lt;object class='GtkButton' id='toolbutton_new'&gt;"
    "        &lt;property name='can_focus'&gt;False&lt;/property&gt;"
    "        &lt;property name='tooltip_text' translatable='yes'&gt;New Standard&lt;/property&gt;"
    "        &lt;property name='action_name'&gt;app.newstandard&lt;/property&gt;"
    "        &lt;property name='icon_name'&gt;document-new&lt;/property&gt;"
    "        &lt;property name='hexpand'&gt;False&lt;/property&gt;"
    "        &lt;property name='vexpand'&gt;False&lt;/property&gt;"
    "      &lt;/object&gt;"
    "    &lt;/child&gt;"
    "    &lt;child&gt;"
    "      &lt;object class='GtkButton' id='toolbutton_quit'&gt;"
    "        &lt;property name='can_focus'&gt;False&lt;/property&gt;"
    "        &lt;property name='tooltip_text' translatable='yes'&gt;Quit&lt;/property&gt;"
    "        &lt;property name='action_name'&gt;app.quit&lt;/property&gt;"
    "        &lt;property name='icon_name'&gt;application-exit&lt;/property&gt;"
    "        &lt;property name='hexpand'&gt;False&lt;/property&gt;"
    "        &lt;property name='vexpand'&gt;False&lt;/property&gt;"
    "      &lt;/object&gt;"
    "    &lt;/child&gt;"
    "  &lt;/object&gt;"
    "&lt;/interface&gt;";

  try
  {
    m_refBuilder-&gt;add_from_string(ui_info);
  }
  catch (const Glib::Error&amp; ex)
  {
    std::cerr &lt;&lt; "Building toolbar failed: " &lt;&lt;  ex.what();
  }

  auto toolbar = m_refBuilder-&gt;get_widget&lt;Gtk::Box&gt;("toolbar");
  if (!toolbar)
    g_warning("toolbar not found");
  else
    m_Box.append(*toolbar);
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_menu_others()
{
  std::cout &lt;&lt; "A menu item was selected." &lt;&lt; std::endl;
}

void ExampleWindow::on_menu_choices(const Glib::ustring&amp; parameter)
{
  //The radio action's state does not change automatically:
  m_refChoice-&gt;change_state(parameter);

  Glib::ustring message;
  if (parameter == "a")
    message = "Choice a was selected.";
  else
    message = "Choice b was selected.";

  std::cout &lt;&lt; message &lt;&lt; std::endl;
}

void ExampleWindow::on_menu_choices_other(int parameter)
{
  //The radio action's state does not change automatically:
  m_refChoiceOther-&gt;change_state(parameter);

  Glib::ustring message;
  if (parameter == 1)
    message = "Choice 1 was selected.";
  else
    message = "Choice 2 was selected.";

  std::cout &lt;&lt; message &lt;&lt; std::endl;
}

void ExampleWindow::on_menu_toggle()
{
  bool active = false;
  m_refToggle-&gt;get_state(active);

  //The toggle action's state does not change automatically:
  active = !active;
  m_refToggle-&gt;change_state(active);

  Glib::ustring message;
  if (active)
    message = "Toggle is active.";
  else
    message = "Toggle is not active.";

  std::cout &lt;&lt; message &lt;&lt; std::endl;
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">exampleapplication.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "exampleapplication.h"
#include "examplewindow.h"
#include &lt;iostream&gt;

ExampleApplication::ExampleApplication()
: Gtk::Application("org.gtkmm.example.main_menu")
{
  Glib::set_application_name("Main Menu Example");
}

Glib::RefPtr&lt;ExampleApplication&gt; ExampleApplication::create()
{
  return Glib::make_refptr_for_instance&lt;ExampleApplication&gt;(new ExampleApplication());
}

void ExampleApplication::on_startup()
{
  //Call the base class's implementation:
  Gtk::Application::on_startup();

  //Create actions for menus and toolbars.
  //We can use add_action() because Gtk::Application derives from Gio::ActionMap.

  //File|New sub menu:
  add_action("newstandard",
    sigc::mem_fun(*this, &amp;ExampleApplication::on_menu_file_new_generic));

  add_action("newfoo",
    sigc::mem_fun(*this, &amp;ExampleApplication::on_menu_file_new_generic));

  add_action("newgoo",
    sigc::mem_fun(*this, &amp;ExampleApplication::on_menu_file_new_generic));

  //File menu:
  add_action("quit", sigc::mem_fun(*this, &amp;ExampleApplication::on_menu_file_quit));

  //Help menu:
  add_action("about", sigc::mem_fun(*this, &amp;ExampleApplication::on_menu_help_about));

  m_refBuilder = Gtk::Builder::create();

  //Layout the actions in a menubar and a menu:
  Glib::ustring ui_info =
    "&lt;interface&gt;"
    "  &lt;!-- menubar --&gt;"
    "  &lt;menu id='menu-example'&gt;"
    "    &lt;submenu&gt;"
    "      &lt;attribute name='label' translatable='yes'&gt;_File&lt;/attribute&gt;"
    "      &lt;section&gt;"
    "        &lt;item&gt;"
    "          &lt;attribute name='label' translatable='yes'&gt;New _Standard&lt;/attribute&gt;"
    "          &lt;attribute name='action'&gt;app.newstandard&lt;/attribute&gt;"
    "          &lt;attribute name='accel'&gt;&amp;lt;Primary&amp;gt;n&lt;/attribute&gt;"
    "        &lt;/item&gt;"
    "        &lt;item&gt;"
    "          &lt;attribute name='label' translatable='yes'&gt;New _Foo&lt;/attribute&gt;"
    "          &lt;attribute name='action'&gt;app.newfoo&lt;/attribute&gt;"
    "        &lt;/item&gt;"
    "        &lt;item&gt;"
    "          &lt;attribute name='label' translatable='yes'&gt;New _Goo&lt;/attribute&gt;"
    "          &lt;attribute name='action'&gt;app.newgoo&lt;/attribute&gt;"
    "        &lt;/item&gt;"
    "      &lt;/section&gt;"
    "      &lt;section&gt;"
    "        &lt;item&gt;"
    "          &lt;attribute name='label' translatable='yes'&gt;_Quit&lt;/attribute&gt;"
    "          &lt;attribute name='action'&gt;app.quit&lt;/attribute&gt;"
    "          &lt;attribute name='accel'&gt;&amp;lt;Primary&amp;gt;q&lt;/attribute&gt;"
    "        &lt;/item&gt;"
    "      &lt;/section&gt;"
    "    &lt;/submenu&gt;"
    "    &lt;submenu&gt;"
    "      &lt;attribute name='label' translatable='yes'&gt;_Edit&lt;/attribute&gt;"
    "      &lt;section&gt;"
    "        &lt;item&gt;"
    "          &lt;attribute name='label' translatable='yes'&gt;_Copy&lt;/attribute&gt;"
    "          &lt;attribute name='action'&gt;win.copy&lt;/attribute&gt;"
    "          &lt;attribute name='accel'&gt;&amp;lt;Primary&amp;gt;c&lt;/attribute&gt;"
    "        &lt;/item&gt;"
    "        &lt;item&gt;"
    "          &lt;attribute name='label' translatable='yes'&gt;_Paste&lt;/attribute&gt;"
    "          &lt;attribute name='action'&gt;win.paste&lt;/attribute&gt;"
    "          &lt;attribute name='accel'&gt;&amp;lt;Primary&amp;gt;v&lt;/attribute&gt;"
    "        &lt;/item&gt;"
    "        &lt;item&gt;"
    "          &lt;attribute name='label' translatable='yes'&gt;_Something&lt;/attribute&gt;"
    "          &lt;attribute name='action'&gt;win.something&lt;/attribute&gt;"
    "        &lt;/item&gt;"
    "      &lt;/section&gt;"
    "    &lt;/submenu&gt;"
    "    &lt;submenu&gt;"
    "      &lt;attribute name='label' translatable='yes'&gt;_Choices&lt;/attribute&gt;"
    "      &lt;section&gt;"
    "        &lt;item&gt;"
    "          &lt;attribute name='label' translatable='yes'&gt;Choice _A&lt;/attribute&gt;"
    "          &lt;attribute name='action'&gt;win.choice&lt;/attribute&gt;"
    "          &lt;attribute name='target'&gt;a&lt;/attribute&gt;"
    "        &lt;/item&gt;"
    "        &lt;item&gt;"
    "          &lt;attribute name='label' translatable='yes'&gt;Choice _B&lt;/attribute&gt;"
    "          &lt;attribute name='action'&gt;win.choice&lt;/attribute&gt;"
    "          &lt;attribute name='target'&gt;b&lt;/attribute&gt;"
    "        &lt;/item&gt;"
    "      &lt;/section&gt;"
    "    &lt;/submenu&gt;"
    "    &lt;submenu&gt;"
    "      &lt;attribute name='label' translatable='yes'&gt;_Other Choices&lt;/attribute&gt;"
    "      &lt;section&gt;"
    "        &lt;item&gt;"
    "          &lt;attribute name='label' translatable='yes'&gt;Choice 1&lt;/attribute&gt;"
    "          &lt;attribute name='action'&gt;win.choiceother&lt;/attribute&gt;"
    "          &lt;attribute name='target' type='i'&gt;1&lt;/attribute&gt;"
    "        &lt;/item&gt;"
    "        &lt;item&gt;"
    "          &lt;attribute name='label' translatable='yes'&gt;Choice 2&lt;/attribute&gt;"
    "          &lt;attribute name='action'&gt;win.choiceother&lt;/attribute&gt;"
    "          &lt;attribute name='target' type='i'&gt;2&lt;/attribute&gt;"
    "        &lt;/item&gt;"
    "      &lt;/section&gt;"
    "      &lt;section&gt;"
    "        &lt;item&gt;"
    "          &lt;attribute name='label' translatable='yes'&gt;Some Toggle&lt;/attribute&gt;"
    "          &lt;attribute name='action'&gt;win.sometoggle&lt;/attribute&gt;"
    "        &lt;/item&gt;"
    "      &lt;/section&gt;"
    "    &lt;/submenu&gt;"
    "    &lt;submenu&gt;"
    "      &lt;attribute name='label' translatable='yes'&gt;_Help&lt;/attribute&gt;"
    "      &lt;section&gt;"
    "        &lt;item&gt;"
    "          &lt;attribute name='label' translatable='yes'&gt;_About Window&lt;/attribute&gt;"
    "          &lt;attribute name='action'&gt;win.about&lt;/attribute&gt;"
    "        &lt;/item&gt;"
    "        &lt;item&gt;"
    "          &lt;attribute name='label' translatable='yes'&gt;_About App&lt;/attribute&gt;"
    "          &lt;attribute name='action'&gt;app.about&lt;/attribute&gt;"
    "        &lt;/item&gt;"
    "      &lt;/section&gt;"
    "    &lt;/submenu&gt;"
    "  &lt;/menu&gt;"
    "&lt;/interface&gt;";

  try
  {
    m_refBuilder-&gt;add_from_string(ui_info);
  }
  catch (const Glib::Error&amp; ex)
  {
    std::cerr &lt;&lt; "Building menus failed: " &lt;&lt; ex.what();
  }

  //Get the menubar and the app menu, and add them to the application:
  auto object = m_refBuilder-&gt;get_object("menu-example");
  auto gmenu = std::dynamic_pointer_cast&lt;Gio::Menu&gt;(object);
  if (!gmenu)
  {
    g_warning("GMenu not found");
  }
  else
  {
    set_menubar(gmenu);
  }
}

void ExampleApplication::on_activate()
{
  //std::cout &lt;&lt; "debug1: " &lt;&lt; G_STRFUNC &lt;&lt; std::endl;
  // The application has been started, so let's show a window.
  // A real application might want to reuse this window in on_open(),
  // when asked to open a file, if no changes have been made yet.
  create_window();
}

void ExampleApplication::create_window()
{
  auto win = new ExampleWindow();

  //Make sure that the application runs for as long this window is still open:
  add_window(*win);

  //Delete the window when it is hidden.
  //That's enough for this simple example.
  win-&gt;signal_hide().connect(sigc::bind(
    sigc::mem_fun(*this, &amp;ExampleApplication::on_window_hide), win));

  win-&gt;set_show_menubar();
  win-&gt;show();
}

void ExampleApplication::on_window_hide(Gtk::Window* window)
{
  delete window;
}

void ExampleApplication::on_menu_file_new_generic()
{
  std::cout &lt;&lt; "A File|New menu item was selected." &lt;&lt; std::endl;
}

void ExampleApplication::on_menu_file_quit()
{
  std::cout &lt;&lt; G_STRFUNC &lt;&lt; std::endl;
  quit(); // Not really necessary, when Gtk::Widget::hide() is called.

  // Gio::Application::quit() will make Gio::Application::run() return,
  // but it's a crude way of ending the program. The window is not removed
  // from the application. Neither the window's nor the application's
  // destructors will be called, because there will be remaining reference
  // counts in both of them. If we want the destructors to be called, we
  // must remove the window from the application. One way of doing this
  // is to hide the window.
  std::vector&lt;Gtk::Window*&gt; windows = get_windows();
  if (windows.size() &gt; 0)
    windows[0]-&gt;hide(); // In this simple case, we know there is only one window.
}

void ExampleApplication::on_menu_help_about()
{
  std::cout &lt;&lt; "Help|About App was selected." &lt;&lt; std::endl;
}
</pre></div>
</div>
<div class="division sect2">
<a name="menu-example-main2"><!--menu-example-main2--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">13.5.2. </span>Main Menu example</span></h4></div>
<p class="para block block-first">
This program contains a menubar and a toolbar.
A class is derived from <span class="classname" dir="ltr">Gtk::Window</span>.
</p>
<div class=" block figure block-indent">
<a name="figure-menus-mainmenu2"><!--figure-menus-mainmenu2--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 13-2</span> </span>Main Menu</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/menus_and_toolbars.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/menus_and_toolbars" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/menus_and_toolbars">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow(const Glib::RefPtr&lt;Gtk::Application&gt;&amp; app);
  virtual ~ExampleWindow();

private:
  //Signal handlers:
  void on_action_file_new();
  void on_action_file_quit();
  void on_action_others();
  void on_action_toggle();

  //Child widgets:
  Gtk::Box m_Box;

  Glib::RefPtr&lt;Gtk::Builder&gt; m_refBuilder;
  Glib::RefPtr&lt;Gio::SimpleActionGroup&gt; m_refActionGroup;
  Glib::RefPtr&lt;Gio::SimpleAction&gt; m_refActionRain;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include &lt;gtkmm.h&gt;
#include "examplewindow.h"

int main(int argc, char* argv[])
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  //Shows the window and returns when it is closed.
  return app-&gt;make_window_and_run&lt;ExampleWindow&gt;(argc, argv, app);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;gtkmm.h&gt;
#include &lt;iostream&gt;

ExampleWindow::ExampleWindow(const Glib::RefPtr&lt;Gtk::Application&gt;&amp; app)
: m_Box(Gtk::Orientation::VERTICAL)
{
  set_title("main_menu example");
  set_default_size(200, 200);

  set_child(m_Box); //We can put a MenuBar at the top of the box and other stuff below it.

  //Define the actions:
  m_refActionGroup = Gio::SimpleActionGroup::create();

  m_refActionGroup-&gt;add_action("new",
    sigc::mem_fun(*this, &amp;ExampleWindow::on_action_file_new) );
  m_refActionGroup-&gt;add_action("open",
    sigc::mem_fun(*this, &amp;ExampleWindow::on_action_others) );

  m_refActionRain = m_refActionGroup-&gt;add_action_bool("rain",
    sigc::mem_fun(*this, &amp;ExampleWindow::on_action_toggle), false);

  m_refActionGroup-&gt;add_action("quit",
    sigc::mem_fun(*this, &amp;ExampleWindow::on_action_file_quit) );

  m_refActionGroup-&gt;add_action("cut",
    sigc::mem_fun(*this, &amp;ExampleWindow::on_action_others) );
  m_refActionGroup-&gt;add_action("copy",
    sigc::mem_fun(*this, &amp;ExampleWindow::on_action_others) );
  m_refActionGroup-&gt;add_action("paste",
    sigc::mem_fun(*this, &amp;ExampleWindow::on_action_others) );

  insert_action_group("example", m_refActionGroup);

  //Define how the actions are presented in the menus and toolbars:
  m_refBuilder = Gtk::Builder::create();

  //Layout the actions in a menubar and toolbar:
  const char* ui_info =
    "&lt;interface&gt;"
    "  &lt;menu id='menubar'&gt;"
    "    &lt;submenu&gt;"
    "      &lt;attribute name='label' translatable='yes'&gt;_File&lt;/attribute&gt;"
    "      &lt;section&gt;"
    "        &lt;item&gt;"
    "          &lt;attribute name='label' translatable='yes'&gt;_New&lt;/attribute&gt;"
    "          &lt;attribute name='action'&gt;example.new&lt;/attribute&gt;"
    "          &lt;attribute name='accel'&gt;&amp;lt;Primary&amp;gt;n&lt;/attribute&gt;"
    "        &lt;/item&gt;"
    "        &lt;item&gt;"
    "          &lt;attribute name='label' translatable='yes'&gt;_Open&lt;/attribute&gt;"
    "          &lt;attribute name='action'&gt;example.open&lt;/attribute&gt;"
    "          &lt;attribute name='accel'&gt;&amp;lt;Primary&amp;gt;o&lt;/attribute&gt;"
    "        &lt;/item&gt;"
    "      &lt;/section&gt;"
    "      &lt;section&gt;"
    "        &lt;item&gt;"
    "          &lt;attribute name='label' translatable='yes'&gt;Rain&lt;/attribute&gt;"
    "          &lt;attribute name='action'&gt;example.rain&lt;/attribute&gt;"
    "        &lt;/item&gt;"
    "      &lt;/section&gt;"
    "      &lt;section&gt;"
    "        &lt;item&gt;"
    "          &lt;attribute name='label' translatable='yes'&gt;_Quit&lt;/attribute&gt;"
    "          &lt;attribute name='action'&gt;example.quit&lt;/attribute&gt;"
    "          &lt;attribute name='accel'&gt;&amp;lt;Primary&amp;gt;q&lt;/attribute&gt;"
    "        &lt;/item&gt;"
    "      &lt;/section&gt;"
    "    &lt;/submenu&gt;"
    "    &lt;submenu&gt;"
    "      &lt;attribute name='label' translatable='yes'&gt;_Edit&lt;/attribute&gt;"
    "      &lt;item&gt;"
    "        &lt;attribute name='label' translatable='yes'&gt;_Cut&lt;/attribute&gt;"
    "        &lt;attribute name='action'&gt;example.cut&lt;/attribute&gt;"
    "        &lt;attribute name='accel'&gt;&amp;lt;Primary&amp;gt;x&lt;/attribute&gt;"
    "      &lt;/item&gt;"
    "      &lt;item&gt;"
    "        &lt;attribute name='label' translatable='yes'&gt;_Copy&lt;/attribute&gt;"
    "        &lt;attribute name='action'&gt;example.copy&lt;/attribute&gt;"
    "        &lt;attribute name='accel'&gt;&amp;lt;Primary&amp;gt;c&lt;/attribute&gt;"
    "      &lt;/item&gt;"
    "      &lt;item&gt;"
    "        &lt;attribute name='label' translatable='yes'&gt;_Paste&lt;/attribute&gt;"
    "        &lt;attribute name='action'&gt;example.paste&lt;/attribute&gt;"
    "        &lt;attribute name='accel'&gt;&amp;lt;Primary&amp;gt;v&lt;/attribute&gt;"
    "      &lt;/item&gt;"
    "    &lt;/submenu&gt;"
    "  &lt;/menu&gt;"
    "&lt;/interface&gt;";

  // When the menubar is a child of a Gtk::Window, keyboard accelerators are not
  // automatically fetched from the Gio::Menu.
  // See the examples/book/menus/main_menu example for an alternative way of
  // adding the menubar when using Gtk::ApplicationWindow.
  app-&gt;set_accel_for_action("example.new", "&lt;Primary&gt;n");
  app-&gt;set_accel_for_action("example.open", "&lt;Primary&gt;o");
  app-&gt;set_accel_for_action("example.quit", "&lt;Primary&gt;q");
  app-&gt;set_accel_for_action("example.cut", "&lt;Primary&gt;x");
  app-&gt;set_accel_for_action("example.copy", "&lt;Primary&gt;c");
  app-&gt;set_accel_for_action("example.paste", "&lt;Primary&gt;v");

  try
  {
    m_refBuilder-&gt;add_from_string(ui_info);
    m_refBuilder-&gt;add_from_resource("/toolbar/toolbar.glade");
  }
  catch(const Glib::Error&amp; ex)
  {
    std::cerr &lt;&lt; "Building menus and toolbar failed: " &lt;&lt;  ex.what();
  }

  //Get the menubar:
  auto object = m_refBuilder-&gt;get_object("menubar");
  auto gmenu = std::dynamic_pointer_cast&lt;Gio::Menu&gt;(object);
  if (!gmenu)
    g_warning("GMenu not found");
  else
  {
    auto pMenuBar = Gtk::make_managed&lt;Gtk::PopoverMenuBar&gt;(gmenu);

    //Add the PopoverMenuBar to the window:
    m_Box.append(*pMenuBar);
  }

  //Get the toolbar and add it to a container widget:
  auto toolbar = m_refBuilder-&gt;get_widget&lt;Gtk::Box&gt;("toolbar");
  if (!toolbar)
    g_warning("toolbar not found");
  else
    m_Box.append(*toolbar);
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_action_file_quit()
{
  hide(); //Closes the main window to stop the app-&gt;make_window_and_run().
}

void ExampleWindow::on_action_file_new()
{
   std::cout &lt;&lt; "A File|New menu item was selected." &lt;&lt; std::endl;
}

void ExampleWindow::on_action_others()
{
  std::cout &lt;&lt; "A menu item was selected." &lt;&lt; std::endl;
}

void ExampleWindow::on_action_toggle()
{
  std::cout &lt;&lt; "The toggle menu item was selected." &lt;&lt; std::endl;

  bool active = false;
  m_refActionRain-&gt;get_state(active);

  //The toggle action's state does not change automatically:
  active = !active;
  m_refActionRain-&gt;change_state(active);

  Glib::ustring message;
  if(active)
    message = "Toggle is active.";
  else
    message = "Toggle is not active";

  std::cout &lt;&lt; message &lt;&lt; std::endl;
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">toolbar.gresource.xml</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;gresources&gt;
  &lt;gresource prefix="/toolbar"&gt;
    &lt;file preprocess="xml-stripblanks"&gt;toolbar.glade&lt;/file&gt;
    &lt;file&gt;rain.png&lt;/file&gt;
  &lt;/gresource&gt;
&lt;/gresources&gt;
</pre></div>
</div>
<div class="division sect2">
<a name="menu-example-popup"><!--menu-example-popup--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">13.5.3. </span>Popup Menu example</span></h4></div>
<div class=" block figure block-first block-indent">
<a name="figure-menus-popup"><!--figure-menus-popup--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 13-3</span> </span>Popup Menu</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/menu_popup.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/menus/popup/" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/menus/popup/">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

#include &lt;memory&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow(const Glib::RefPtr&lt;Gtk::Application&gt;&amp; app);
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_label_pressed(int n_press, double x, double y);

  void on_menu_file_popup_generic();

  //Child widgets:
  Gtk::Box m_Box;
  Gtk::Label m_Label;
  Gtk::PopoverMenu m_MenuPopup;

  Glib::RefPtr&lt;Gtk::Builder&gt; m_refBuilder;
  Glib::RefPtr&lt;Gtk::GestureClick&gt; m_refGesture;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;gtkmm/application.h&gt;

int main(int argc, char *argv[])
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  //Shows the window and returns when it is closed.
  return app-&gt;make_window_and_run&lt;ExampleWindow&gt;(argc, argv, app);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;iostream&gt;

ExampleWindow::ExampleWindow(const Glib::RefPtr&lt;Gtk::Application&gt;&amp; app)
: m_Box(Gtk::Orientation::VERTICAL),
  m_Label("Right-click to see the popup menu.")
{
  set_title("popup example");
  set_default_size(200, 200);

  set_child(m_Box);

  // Catch button_press events:
  m_Box.append(m_Label);
  m_Label.set_expand();
  m_refGesture = Gtk::GestureClick::create();
  m_refGesture-&gt;set_button(GDK_BUTTON_SECONDARY);
  m_refGesture-&gt;signal_pressed().connect(
    sigc::mem_fun(*this, &amp;ExampleWindow::on_label_pressed));
  m_Label.add_controller(m_refGesture);

  //Create actions:
  auto refActionGroup = Gio::SimpleActionGroup::create();

  //File|New sub menu:
  //These menu actions would normally already exist for a main menu, because a
  //context menu should not normally contain menu items that are only available
  //via a context menu.

  refActionGroup-&gt;add_action("edit",
    sigc::mem_fun(*this, &amp;ExampleWindow::on_menu_file_popup_generic));

  refActionGroup-&gt;add_action("process",
    sigc::mem_fun(*this, &amp;ExampleWindow::on_menu_file_popup_generic));

  refActionGroup-&gt;add_action("remove",
    sigc::mem_fun(*this, &amp;ExampleWindow::on_menu_file_popup_generic));

  insert_action_group("examplepopup", refActionGroup);

  // Set accelerator keys:
  app-&gt;set_accel_for_action("examplepopup.edit", "&lt;Primary&gt;e");
  app-&gt;set_accel_for_action("examplepopup.process", "&lt;Primary&gt;p");
  app-&gt;set_accel_for_action("examplepopup.remove", "&lt;Primary&gt;r");

  m_refBuilder = Gtk::Builder::create();

  //Layout the actions in a menubar and toolbar:
  Glib::ustring ui_info =
    "&lt;interface&gt;"
    "  &lt;menu id='menu-examplepopup'&gt;"
    "    &lt;section&gt;"
    "      &lt;item&gt;"
    "        &lt;attribute name='label' translatable='yes'&gt;Edit&lt;/attribute&gt;"
    "        &lt;attribute name='action'&gt;examplepopup.edit&lt;/attribute&gt;"
    "      &lt;/item&gt;"
    "      &lt;item&gt;"
    "        &lt;attribute name='label' translatable='yes'&gt;Process&lt;/attribute&gt;"
    "        &lt;attribute name='action'&gt;examplepopup.process&lt;/attribute&gt;"
    "      &lt;/item&gt;"
    "      &lt;item&gt;"
    "        &lt;attribute name='label' translatable='yes'&gt;Remove&lt;/attribute&gt;"
    "        &lt;attribute name='action'&gt;examplepopup.remove&lt;/attribute&gt;"
    "      &lt;/item&gt;"
    "    &lt;/section&gt;"
    "  &lt;/menu&gt;"
    "&lt;/interface&gt;";

  try
  {
    m_refBuilder-&gt;add_from_string(ui_info);
  }
  catch(const Glib::Error&amp; ex)
  {
    std::cerr &lt;&lt; "building menus failed: " &lt;&lt;  ex.what();
  }

  //Get the menu:
  auto object =
    m_refBuilder-&gt;get_object("menu-examplepopup");
  auto gmenu =
    std::dynamic_pointer_cast&lt;Gio::Menu&gt;(object);
  if(!gmenu)
    g_warning("GMenu not found");

  m_MenuPopup.set_parent(m_Label);
  m_MenuPopup.set_menu_model(gmenu);
  m_MenuPopup.set_has_arrow(false);
}

ExampleWindow::~ExampleWindow()
{
  m_MenuPopup.unparent();
}

void ExampleWindow::on_menu_file_popup_generic()
{
   std::cout &lt;&lt; "A popup menu item was selected." &lt;&lt; std::endl;
}

void ExampleWindow::on_label_pressed(int /* n_press */, double x, double y)
{
  const Gdk::Rectangle rect(x, y, 1, 1);
  m_MenuPopup.set_pointing_to(rect);
  m_MenuPopup.popup();
}
</pre></div>
</div>
</div>
</div>
<div class="division chapter">
<a name="chapter-adjustment"><!--chapter-adjustment--></a><div class="header"><h2 class="chapter title"><span class="title"><span class="label">14. </span>Adjustments</span></h2></div>
<p class="para block block-first">
<span class="application">gtkmm</span> has various widgets that can be visually adjusted using the mouse or
the keyboard, such as the <span class="classname" dir="ltr">Range</span> widgets (described in
the <a class="link" href="#chapter-range-widgets" title="Range Widgets">Range Widgets</a> section). There are
also a few widgets that display some adjustable part of a larger area, such as
the <span class="classname" dir="ltr">Viewport</span> widget. These widgets have
<span class="classname" dir="ltr">Gtk::Adjustment</span> objects that express this common part of
their API.
</p>
<p class="para block">
So that applications can react to changes, for instance when a user moves a
scrollbar, <span class="classname" dir="ltr">Gtk::Adjustment</span> has a
<span class="literal" dir="ltr">value_changed</span> signal. You can then use the
<span class="methodname" dir="ltr">get_value()</span> method to discover the new value.
</p>
<div class="autotoc"><ul>
<li>
<span class="label">14.1. </span><a class="xref" href="#sec-creating-adjustment" title="Creating an Adjustment">Creating an Adjustment</a>
</li>
<li>
<span class="label">14.2. </span><a class="xref" href="#sec-adjustments-easy" title="Using Adjustments the Easy Way">Using Adjustments the Easy Way</a>
</li>
<li>
<span class="label">14.3. </span><a class="xref" href="#sec-adjustment-internals" title="Adjustment Internals">Adjustment Internals</a>
</li>
</ul></div>
<div class="division sect1">
<a name="sec-creating-adjustment"><!--sec-creating-adjustment--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">14.1. </span>Creating an Adjustment</span></h3></div>
<p class="para block block-first">
The <span class="classname" dir="ltr">Gtk::Adjustment</span> is created by its
<span class="methodname" dir="ltr">create()</span> method which is as follows:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">Glib::RefPtr&lt;Gtk::Adjustment&gt; Gtk::Adjustment::create(
  double value,
  double lower,
  double upper,
  double step_increment = 1,
  double page_increment = 10,
  double page_size = 0);</pre></div>
<p class="para block">
The <span class="parameter" dir="ltr">value</span> argument is the initial value of the
adjustment, usually corresponding to the topmost or leftmost position of an
adjustable widget. The <span class="parameter" dir="ltr">lower</span> and
<span class="parameter" dir="ltr">upper</span> arguments specify the possible range of values
which the adjustment can hold. The
<span class="parameter" dir="ltr">step_increment</span> argument specifies the smaller of
the two increments by which the user can change the value, while the
<span class="parameter" dir="ltr">page_increment</span> is the larger one. The
<span class="parameter" dir="ltr">page_size</span> argument usually corresponds somehow to
the visible area of a panning widget. The <span class="parameter" dir="ltr">upper</span> argument
is used to represent the bottommost or rightmost coordinate in a panning
widget's child.

</p>
</div>
<div class="division sect1">
<a name="sec-adjustments-easy"><!--sec-adjustments-easy--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">14.2. </span>Using Adjustments the Easy Way</span></h3></div>
<p class="para block block-first">
The adjustable widgets can be roughly divided into those which use and
require specific units for these values, and those which treat them as
arbitrary numbers.
</p>
<p class="para block">
The group which treats the values as arbitrary numbers includes the
<span class="classname" dir="ltr">Range</span> widgets (<span class="classname" dir="ltr">Scrollbar</span> and
<span class="classname" dir="ltr">Scale</span>), the <span class="classname" dir="ltr">ScaleButton</span> widget,
and the <span class="classname" dir="ltr">SpinButton</span> widget. These widgets  are typically
"adjusted" directly by the user with the mouse or keyboard. They will treat the
<span class="parameter" dir="ltr">lower</span> and <span class="parameter" dir="ltr">upper</span> values of an
adjustment as a range within which the user can manipulate the adjustment's
<span class="parameter" dir="ltr">value</span>. By default, they will only modify the
<span class="parameter" dir="ltr">value</span> of an adjustment.
</p>
<p class="para block">
The other group includes the <span class="classname" dir="ltr">Viewport</span> widget and the
<span class="classname" dir="ltr">ScrolledWindow</span> widget. All of these widgets use pixel
values for their adjustments. These are also typically adjusted indirectly
using scrollbars. While all widgets which use adjustments can either create
their own adjustments or use ones you supply, you'll generally want to let this
particular category of widgets create its own adjustments.
</p>
<p class="para block">
If you share an adjustment object between a Scrollbar and a TextView
widget, manipulating the scrollbar will automagically adjust the TextView
widget. You can set it up like this:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">// creates its own adjustments
Gtk::TextView textview;
// uses the newly-created adjustment for the scrollbar as well
Gtk::Scrollbar vscrollbar (textview.get_vadjustment(), Gtk::ORIENTATION_VERTICAL);</pre></div>
</div>
<div class="division sect1">
<a name="sec-adjustment-internals"><!--sec-adjustment-internals--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">14.3. </span>Adjustment Internals</span></h3></div>
<p class="para block block-first">
OK, you say, that's nice, but what if I want to create my own handlers to
respond when the user adjusts a <span class="classname" dir="ltr">Range</span> widget or a
<span class="classname" dir="ltr">SpinButton</span>. To access the value of a
<span class="classname" dir="ltr">Gtk::Adjustment</span>, you can use the
<span class="methodname" dir="ltr">get_value()</span> and <span class="methodname" dir="ltr">set_value()</span> methods:
</p>
<p class="para block">
As mentioned earlier, <span class="classname" dir="ltr">Gtk::Adjustment</span> can emit signals.
This is, of course, how updates happen automatically when you share an
<span class="classname" dir="ltr">Adjustment</span> object between a
<span class="classname" dir="ltr">Scrollbar</span> and another adjustable widget; all adjustable
widgets connect signal handlers to their adjustment's
<span class="literal" dir="ltr">value_changed</span> signal, as can your program.
</p>
<p class="para block">
So, for example, if you have a <span class="classname" dir="ltr">Scale</span> widget, and you
want to change the rotation of a picture whenever its value changes, you would
create a signal handler like this:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">void cb_rotate_picture (MyPicture* picture)
{
  picture-&gt;set_rotation(adj-&gt;get_value());
...</pre></div>
<p class="para block">
and connect it to the scale widget's adjustment like this:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">adj-&gt;signal_value_changed().connect(sigc::bind&lt;MyPicture*&gt;(sigc::mem_fun(*this,
    &amp;cb_rotate_picture), picture));</pre></div>
<p class="para block">
What if a widget reconfigures the <span class="parameter" dir="ltr">upper</span> or
<span class="parameter" dir="ltr">lower</span> fields of its <span class="classname" dir="ltr">Adjustment</span>,
such as when a user adds more text to a text widget?  In this case, it emits
the <span class="literal" dir="ltr">changed</span> signal.
</p>
<p class="para block">
<span class="classname" dir="ltr">Range</span> widgets typically connect a handler to this
signal, which changes their appearance to reflect the change - for example, the
size of the slider in a scrollbar will grow or shrink in inverse proportion to
the difference between the <span class="parameter" dir="ltr">lower</span> and
<span class="parameter" dir="ltr">upper</span> values of its
<span class="classname" dir="ltr">Adjustment</span>.
</p>
<p class="para block">
You probably won't ever need to attach a handler to this signal, unless you're
writing a new type of range widget.
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">adjustment-&gt;signal_changed();</pre></div>
</div>
</div>
<div class="division chapter">
<a name="chapter-dialogs"><!--chapter-dialogs--></a><div class="header"><h2 class="chapter title"><span class="title"><span class="label">15. </span>Dialogs</span></h2></div>
<p class="para block block-first">
Dialogs are used as secondary windows, to provide specific information or to
ask questions. <span class="classname" dir="ltr">Gtk::Dialog</span> windows contain a few pre-packed
widgets to ensure consistency, and a <span class="methodname" dir="ltr">run()</span> method which
blocks until the user dismisses the dialog.
</p>
<p class="para block">
There are several derived <span class="classname" dir="ltr">Dialog</span> classes which you might
find useful. <span class="classname" dir="ltr">Gtk::MessageDialog</span> is used for most simple
notifications. But at other times you might need to derive your own dialog
class to provide more complex functionality.
</p>
<p class="para block">
To pack widgets into a custom dialog, you should pack them into the
<span class="classname" dir="ltr">Gtk::Box</span>, available via
<span class="methodname" dir="ltr">get_content_area()</span>. To just add a <span class="classname" dir="ltr">Button</span>
to the bottom of the <span class="classname" dir="ltr">Dialog</span>, you could use the
<span class="methodname" dir="ltr">add_button()</span> method.
</p>
<p class="para block">
The <span class="methodname" dir="ltr">run()</span> method returns an <span class="literal" dir="ltr">int</span>. This
may be a value from the <span class="literal" dir="ltr">Gtk::ResponseType</span> if the user
closed the dialog by clicking a standard button, or it could be the custom
response value that you specified when using <span class="methodname" dir="ltr">add_button()</span>.
</p>
<p class="para block"><a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Dialog.html" title="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Dialog.html">Reference</a></p>
<div class="autotoc"><ul>
<li>
<span class="label">15.1. </span><a class="xref" href="#sec-dialogs-messagedialog" title="MessageDialog">MessageDialog</a>
</li>
<li>
<span class="label">15.2. </span><a class="xref" href="#sec-dialogs-filechooserdialog" title="FileChooserDialog">FileChooserDialog</a>
</li>
<li>
<span class="label">15.3. </span><a class="xref" href="#sec-color-selection-dialog" title="ColorChooserDialog">ColorChooserDialog</a>
</li>
<li>
<span class="label">15.4. </span><a class="xref" href="#sec-font-chooser-dialog" title="FontChooserDialog">FontChooserDialog</a>
</li>
<li>
<span class="label">15.5. </span><a class="xref" href="#sec-about-dialog" title="Non-modal AboutDialog">Non-modal AboutDialog</a>
</li>
</ul></div>
<div class="division sect1">
<a name="sec-dialogs-messagedialog"><!--sec-dialogs-messagedialog--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">15.1. </span>MessageDialog</span></h3></div>
<p class="para block block-first">
<span class="classname" dir="ltr">MessageDialog</span> is a convenience class, used to create
simple, standard message dialogs, with a message, an icon, and buttons for user
response. You can specify the type of message and the text in the constructor,
as well as specifying standard buttons via the
<span class="literal" dir="ltr">Gtk::ButtonsType</span> enum.
</p>
<p class="para block"><a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1MessageDialog.html" title="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1MessageDialog.html">Reference</a></p>
<div class="autotoc"><ul><li>
<span class="label">15.1.1. </span><a class="xref" href="#messagedialog-example" title="Example">Example</a>
</li></ul></div>
<div class="division sect2">
<a name="messagedialog-example"><!--messagedialog-example--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">15.1.1. </span>Example</span></h4></div>
<div class=" block figure block-first block-indent">
<a name="figure-dialogs-messagedialog"><!--figure-dialogs-messagedialog--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 15-1</span> </span>MessageDialog</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/dialogs_messagedialog.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/dialogs/messagedialog" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/dialogs/messagedialog">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;
#include &lt;memory&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_button_info_clicked();
  void on_button_question_clicked();
  void on_question_dialog_response(int response_id);

  //Child widgets:
  Gtk::Box m_ButtonBox;
  Gtk::Button m_Button_Info, m_Button_Question;

  std::unique_ptr&lt;Gtk::MessageDialog&gt; m_pDialog;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;gtkmm/application.h&gt;

int main(int argc, char *argv[])
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  //Shows the window and returns when it is closed.
  return app-&gt;make_window_and_run&lt;ExampleWindow&gt;(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;gtkmm/messagedialog.h&gt;
#include &lt;iostream&gt;


ExampleWindow::ExampleWindow()
: m_ButtonBox(Gtk::Orientation::VERTICAL),
  m_Button_Info("Show Info MessageDialog"),
  m_Button_Question("Show Question MessageDialog")
{
  set_title("Gtk::MessageDialog example");

  set_child(m_ButtonBox);

  m_ButtonBox.append(m_Button_Info);
  m_Button_Info.set_expand(true);
  m_Button_Info.signal_clicked().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_info_clicked) );

  m_ButtonBox.append(m_Button_Question);
  m_Button_Question.set_expand(true);
  m_Button_Question.signal_clicked().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_question_clicked) );
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_button_info_clicked()
{
  m_pDialog.reset(new Gtk::MessageDialog(*this, "This is an INFO MessageDialog"));
  m_pDialog-&gt;set_secondary_text(
          "And this is the secondary text that explains things.");
  m_pDialog-&gt;set_modal(true);
  m_pDialog-&gt;set_hide_on_close(true);
  m_pDialog-&gt;signal_response().connect(
    sigc::hide(sigc::mem_fun(*m_pDialog, &amp;Gtk::Widget::hide)));

  m_pDialog-&gt;show();
}

void ExampleWindow::on_button_question_clicked()
{
  m_pDialog.reset(new Gtk::MessageDialog(*this, "This is a QUESTION MessageDialog",
          false /* use_markup */, Gtk::MessageType::QUESTION,
          Gtk::ButtonsType::OK_CANCEL, true /* modal */));
  m_pDialog-&gt;set_secondary_text(
          "And this is the secondary text that explains things.");
  m_pDialog-&gt;set_hide_on_close(true);
  m_pDialog-&gt;signal_response().connect(
    sigc::mem_fun(*this, &amp;ExampleWindow::on_question_dialog_response));

  m_pDialog-&gt;show();
}

void ExampleWindow::on_question_dialog_response(int response_id)
{
  m_pDialog-&gt;hide();

  //Handle the response:
  switch (response_id)
  {
    case Gtk::ResponseType::OK:
    {
      std::cout &lt;&lt; "OK clicked." &lt;&lt; std::endl;
      break;
    }
    case Gtk::ResponseType::CANCEL:
    {
      std::cout &lt;&lt; "Cancel clicked." &lt;&lt; std::endl;
      break;
    }
    default:
    {
      std::cout &lt;&lt; "Unexpected button clicked." &lt;&lt; std::endl;
      break;
    }
  }
}
</pre></div>
</div>
</div>
<div class="division sect1">
<a name="sec-dialogs-filechooserdialog"><!--sec-dialogs-filechooserdialog--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">15.2. </span>FileChooserDialog</span></h3></div>
<p class="para block block-first">
The <span class="classname" dir="ltr">FileChooserDialog</span> is suitable for use with
"Open" or "Save" menu items.
</p>
<p class="para block">
Most of the useful member methods for this class are actually in the
<span class="classname" dir="ltr">Gtk::FileChooser</span> base class.
</p>
<p class="para block"><a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1FileChooserDialog.html" title="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1FileChooserDialog.html">Reference</a></p>
<div class="autotoc"><ul><li>
<span class="label">15.2.1. </span><a class="xref" href="#filechooserdialog-example" title="Example">Example</a>
</li></ul></div>
<div class="division sect2">
<a name="filechooserdialog-example"><!--filechooserdialog-example--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">15.2.1. </span>Example</span></h4></div>
<div class=" block figure block-first block-indent">
<a name="figure-dialogs-filechooser"><!--figure-dialogs-filechooser--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 15-2</span> </span>FileChooser</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/dialogs_filechooser.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/dialogs/filechooserdialog" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/dialogs/filechooserdialog">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_button_file_clicked();
  void on_button_folder_clicked();
  void on_file_dialog_response(int response_id, Gtk::FileChooserDialog* dialog);
  void on_folder_dialog_response(int response_id, Gtk::FileChooserDialog* dialog);

  //Child widgets:
  Gtk::Box m_ButtonBox;
  Gtk::Button m_Button_File, m_Button_Folder;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;gtkmm/application.h&gt;

int main(int argc, char *argv[])
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  //Shows the window and returns when it is closed.
  return app-&gt;make_window_and_run&lt;ExampleWindow&gt;(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;iostream&gt;


ExampleWindow::ExampleWindow()
: m_ButtonBox(Gtk::Orientation::VERTICAL),
  m_Button_File("Choose File"),
  m_Button_Folder("Choose Folder")
{
  set_title("Gtk::FileSelection example");

  set_child(m_ButtonBox);

  m_ButtonBox.append(m_Button_File);
  m_Button_File.set_expand(true);
  m_Button_File.signal_clicked().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_file_clicked) );

  m_ButtonBox.append(m_Button_Folder);
  m_Button_Folder.set_expand(true);
  m_Button_Folder.signal_clicked().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_folder_clicked) );
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_button_file_clicked()
{
  auto dialog = new Gtk::FileChooserDialog("Please choose a file",
          Gtk::FileChooser::Action::OPEN);
  dialog-&gt;set_transient_for(*this);
  dialog-&gt;set_modal(true);
  dialog-&gt;signal_response().connect(sigc::bind(
    sigc::mem_fun(*this, &amp;ExampleWindow::on_file_dialog_response), dialog));

  //Add response buttons to the dialog:
  dialog-&gt;add_button("_Cancel", Gtk::ResponseType::CANCEL);
  dialog-&gt;add_button("_Open", Gtk::ResponseType::OK);

  //Add filters, so that only certain file types can be selected:

  auto filter_text = Gtk::FileFilter::create();
  filter_text-&gt;set_name("Text files");
  filter_text-&gt;add_mime_type("text/plain");
  dialog-&gt;add_filter(filter_text);

  auto filter_cpp = Gtk::FileFilter::create();
  filter_cpp-&gt;set_name("C/C++ files");
  filter_cpp-&gt;add_mime_type("text/x-c");
  filter_cpp-&gt;add_mime_type("text/x-c++");
  filter_cpp-&gt;add_mime_type("text/x-c-header");
  dialog-&gt;add_filter(filter_cpp);

  auto filter_any = Gtk::FileFilter::create();
  filter_any-&gt;set_name("Any files");
  filter_any-&gt;add_pattern("*");
  dialog-&gt;add_filter(filter_any);

  //Show the dialog and wait for a user response:
  dialog-&gt;show();
}

void ExampleWindow::on_file_dialog_response(int response_id, Gtk::FileChooserDialog* dialog)
{
  //Handle the response:
  switch (response_id)
  {
    case Gtk::ResponseType::OK:
    {
      std::cout &lt;&lt; "Open clicked." &lt;&lt; std::endl;

      //Notice that this is a std::string, not a Glib::ustring.
      auto filename = dialog-&gt;get_file()-&gt;get_path();
      std::cout &lt;&lt; "File selected: " &lt;&lt;  filename &lt;&lt; std::endl;
      break;
    }
    case Gtk::ResponseType::CANCEL:
    {
      std::cout &lt;&lt; "Cancel clicked." &lt;&lt; std::endl;
      break;
    }
    default:
    {
      std::cout &lt;&lt; "Unexpected button clicked." &lt;&lt; std::endl;
      break;
    }
  }
  delete dialog;
}

void ExampleWindow::on_button_folder_clicked()
{
  auto dialog = new Gtk::FileChooserDialog("Please choose a folder",
          Gtk::FileChooser::Action::SELECT_FOLDER);
  dialog-&gt;set_transient_for(*this);
  dialog-&gt;set_modal(true);
  dialog-&gt;signal_response().connect(sigc::bind(
    sigc::mem_fun(*this, &amp;ExampleWindow::on_folder_dialog_response), dialog));

  //Add response buttons to the dialog:
  dialog-&gt;add_button("_Cancel", Gtk::ResponseType::CANCEL);
  dialog-&gt;add_button("Select", Gtk::ResponseType::OK);

  //Show the dialog and wait for a user response:
  dialog-&gt;show();
}

void ExampleWindow::on_folder_dialog_response(int response_id, Gtk::FileChooserDialog* dialog)
{
  //Handle the response:
  switch (response_id)
  {
    case Gtk::ResponseType::OK:
    {
      std::cout &lt;&lt; "Select clicked." &lt;&lt; std::endl;
      std::cout &lt;&lt; "Folder selected: " &lt;&lt; dialog-&gt;get_file()-&gt;get_path() &lt;&lt; std::endl;
      break;
    }
    case Gtk::ResponseType::CANCEL:
    {
      std::cout &lt;&lt; "Cancel clicked." &lt;&lt; std::endl;
      break;
    }
    default:
    {
      std::cout &lt;&lt; "Unexpected button clicked." &lt;&lt; std::endl;
      break;
    }
  }
  delete dialog;
}
</pre></div>
</div>
</div>
<div class="division sect1">
<a name="sec-color-selection-dialog"><!--sec-color-selection-dialog--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">15.3. </span>ColorChooserDialog</span></h3></div>
<p class="para block block-first">
The <span class="classname" dir="ltr">ColorChooserDialog</span> allows the user to choose a
color. The <span class="classname" dir="ltr">ColorButton</span> opens a color selection dialog
when it is clicked.
</p>
<p class="para block"><a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1ColorChooserDialog.html" title="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1ColorChooserDialog.html">Reference</a></p>
<div class="autotoc"><ul><li>
<span class="label">15.3.1. </span><a class="xref" href="#colorchooserdialog-example" title="Example">Example</a>
</li></ul></div>
<div class="division sect2">
<a name="colorchooserdialog-example"><!--colorchooserdialog-example--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">15.3.1. </span>Example</span></h4></div>
<div class=" block figure block-first block-indent">
<a name="figure-dialogs-colorchooserdialog"><!--figure-dialogs-colorchooserdialog--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 15-3</span> </span>ColorChooserDialog</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/dialogs_colorchooserdialog.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/dialogs/colorchooserdialog" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/dialogs/colorchooserdialog">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;
#include &lt;memory&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_color_button_color_set();
  void on_button_dialog_clicked();
  void on_dialog_response(int response_id);

  //Draw function:
  void on_drawing_area_draw(const Cairo::RefPtr&lt;Cairo::Context&gt;&amp; cr, int width, int height);

  //Child widgets:
  Gtk::Box m_VBox;
  Gtk::ColorButton m_ColorButton;
  Gtk::Button m_Button_Dialog;
  Gtk::DrawingArea m_DrawingArea; //To show the color.

  std::unique_ptr&lt;Gtk::ColorChooserDialog&gt; m_pDialog;
  Gdk::RGBA m_Color;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;gtkmm/application.h&gt;

int main(int argc, char *argv[])
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  //Shows the window and returns when it is closed.
  return app-&gt;make_window_and_run&lt;ExampleWindow&gt;(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;iostream&gt;

ExampleWindow::ExampleWindow()
: m_VBox(Gtk::Orientation::VERTICAL, 5),
  m_Button_Dialog("Choose Color")
{
  set_title("Gtk::ColorChooserDialog example");
  set_default_size(200, 200);

  set_child(m_VBox);

  m_VBox.append(m_ColorButton);
  m_ColorButton.signal_color_set().connect(sigc::mem_fun(*this,
    &amp;ExampleWindow::on_color_button_color_set) );

  m_VBox.append(m_Button_Dialog);
  m_Button_Dialog.signal_clicked().connect(sigc::mem_fun(*this,
    &amp;ExampleWindow::on_button_dialog_clicked) );

  //Set start color:
  m_Color.set_red(0.0);
  m_Color.set_green(0.0);
  m_Color.set_blue(1.0);
  m_Color.set_alpha(1.0); //opaque
  m_ColorButton.set_rgba(m_Color);

  m_VBox.append(m_DrawingArea);
  m_DrawingArea.set_expand(true);
  m_DrawingArea.set_draw_func(sigc::mem_fun(*this, &amp;ExampleWindow::on_drawing_area_draw));
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_color_button_color_set()
{
  //Store the chosen color:
  m_Color = m_ColorButton.get_rgba();
  m_DrawingArea.queue_draw();
}

void ExampleWindow::on_button_dialog_clicked()
{
  if (!m_pDialog)
  {
    m_pDialog.reset(new Gtk::ColorChooserDialog("Please choose a color", *this));
    m_pDialog-&gt;set_modal(true);
    m_pDialog-&gt;set_hide_on_close(true);
    m_pDialog-&gt;signal_response().connect(
      sigc::mem_fun(*this, &amp;ExampleWindow::on_dialog_response));
  }

  //Get the previously selected color:
  m_pDialog-&gt;set_rgba(m_Color);

  m_pDialog-&gt;show();
}

void ExampleWindow::on_dialog_response(int response_id)
{
  m_pDialog-&gt;hide();

  //Handle the response:
  switch (response_id)
  {
    case Gtk::ResponseType::OK:
    {
      //Store the chosen color:
      m_Color = m_pDialog-&gt;get_rgba();
      m_ColorButton.set_rgba(m_Color);
      m_DrawingArea.queue_draw();
      break;
    }
    case Gtk::ResponseType::CANCEL:
    {
      std::cout &lt;&lt; "Cancel clicked." &lt;&lt; std::endl;
      break;
    }
    default:
    {
      std::cout &lt;&lt; "Unexpected button clicked: " &lt;&lt; response_id &lt;&lt; std::endl;
      break;
    }
  }
}

void ExampleWindow::on_drawing_area_draw(const Cairo::RefPtr&lt;Cairo::Context&gt;&amp; cr, int, int)
{
  Gdk::Cairo::set_source_rgba(cr, m_Color);
  cr-&gt;paint();
}
</pre></div>
</div>
</div>
<div class="division sect1">
<a name="sec-font-chooser-dialog"><!--sec-font-chooser-dialog--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">15.4. </span>FontChooserDialog</span></h3></div>
<p class="para block block-first">
The <span class="classname" dir="ltr">FontChooserDialog</span> allows the user to choose a
font. The <span class="classname" dir="ltr">FontButton</span> opens a font chooser dialog
when it is clicked.
</p>
<p class="para block"><a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1FontChooserDialog.html" title="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1FontChooserDialog.html">Reference</a></p>
<div class="autotoc"><ul><li>
<span class="label">15.4.1. </span><a class="xref" href="#fontchooserdialog-example" title="Example">Example</a>
</li></ul></div>
<div class="division sect2">
<a name="fontchooserdialog-example"><!--fontchooserdialog-example--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">15.4.1. </span>Example</span></h4></div>
<div class=" block figure block-first block-indent">
<a name="figure-dialogs-fontchooserdialog"><!--figure-dialogs-fontchooserdialog--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 15-4</span> </span>FontChooserDialog</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/dialogs_fontchooserdialog.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/dialogs/fontchooserdialog" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/dialogs/fontchooserdialog">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;
#include &lt;memory&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_font_button_font_set();
  void on_button_dialog_clicked();
  void on_dialog_response(int response_id);

  //Child widgets:
  Gtk::Box m_ButtonBox;
  Gtk::FontButton m_FontButton;
  Gtk::Button m_Button_Dialog;

  std::unique_ptr&lt;Gtk::FontChooserDialog&gt; m_pDialog;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;gtkmm/application.h&gt;

int main(int argc, char *argv[])
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  //Shows the window and returns when it is closed.
  return app-&gt;make_window_and_run&lt;ExampleWindow&gt;(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;iostream&gt;

ExampleWindow::ExampleWindow()
: m_ButtonBox(Gtk::Orientation::VERTICAL),
  m_FontButton("Sans 10"),
  m_Button_Dialog("Choose Font")
{
  set_title("Gtk::FontChooserDialog example");

  set_child(m_ButtonBox);

  m_ButtonBox.append(m_FontButton);
  m_FontButton.set_expand(true);
  m_FontButton.set_use_font(true);
  m_FontButton.set_use_size(true);
  m_FontButton.signal_font_set().connect(sigc::mem_fun(*this,
    &amp;ExampleWindow::on_font_button_font_set) );

  m_ButtonBox.append(m_Button_Dialog);
  m_Button_Dialog.set_expand(true);
  m_Button_Dialog.signal_clicked().connect(sigc::mem_fun(*this,
    &amp;ExampleWindow::on_button_dialog_clicked) );
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_font_button_font_set()
{
  auto font_name = m_FontButton.get_font();
  std::cout &lt;&lt; "Font chosen: " &lt;&lt; font_name &lt;&lt; std::endl;
}

void ExampleWindow::on_button_dialog_clicked()
{
  if (!m_pDialog)
  {
    m_pDialog.reset(new Gtk::FontChooserDialog("Please choose a font", *this));
    m_pDialog-&gt;set_modal(true);
    m_pDialog-&gt;set_hide_on_close(true);
    m_pDialog-&gt;signal_response().connect(
      sigc::mem_fun(*this, &amp;ExampleWindow::on_dialog_response));
  }

  //Get the previously selected font name from the FontButton:
  m_pDialog-&gt;set_font(m_FontButton.get_font());

  m_pDialog-&gt;show();
}

void ExampleWindow::on_dialog_response(int response_id)
{
  m_pDialog-&gt;hide();

  //Handle the response:
  switch (response_id)
  {
    case Gtk::ResponseType::OK:
    {
      auto font_name = m_pDialog-&gt;get_font();
      std::cout &lt;&lt; "Font chosen: " &lt;&lt; font_name &lt;&lt; std::endl;
      m_FontButton.set_font(font_name);
      break;
    }
    case Gtk::ResponseType::CANCEL:
    {
      std::cout &lt;&lt; "Cancel clicked." &lt;&lt; std::endl;
      break;
    }
    default:
    {
      std::cout &lt;&lt; "Unexpected button clicked: " &lt;&lt; response_id &lt;&lt; std::endl;
      break;
    }
  }
}
</pre></div>
</div>
</div>
<div class="division sect1">
<a name="sec-about-dialog"><!--sec-about-dialog--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">15.5. </span>Non-modal AboutDialog</span></h3></div>
<p class="para block block-first">
The <span class="classname" dir="ltr">AboutDialog</span> offers a simple way to display information
about a program, like its logo, name, copyright, website and license.
</p>
<p class="para block">
Most dialogs in this chapter are modal, that is, they freeze the rest of
the application while they are shown. It's also possible to create a non-modal
dialog, which does not freeze other windows in the application.
The following example shows a non-modal <span class="classname" dir="ltr">AboutDialog</span>. This is
perhaps not the kind of dialog you would normally make non-modal, but non-modal
dialogs can be useful in other cases. E.g. <span class="application">gedit</span>'s
search-and-replace dialog is non-modal.
</p>
<p class="para block"><a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1AboutDialog.html" title="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1AboutDialog.html">Reference</a></p>
<div class="autotoc"><ul><li>
<span class="label">15.5.1. </span><a class="xref" href="#aboutdialog-example" title="Example">Example</a>
</li></ul></div>
<div class="division sect2">
<a name="aboutdialog-example"><!--aboutdialog-example--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">15.5.1. </span>Example</span></h4></div>
<div class=" block figure block-first block-indent">
<a name="figure-dialogs-about"><!--figure-dialogs-about--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 15-5</span> </span>AboutDialog</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/dialogs_about.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/dialogs/aboutdialog" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/dialogs/aboutdialog">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_button_clicked();

  //Child widgets:
  Gtk::Box m_VBox;
  Gtk::Label m_Label;
  Gtk::Box m_ButtonBox;
  Gtk::Button m_Button;
  Gtk::AboutDialog m_Dialog;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;gtkmm/application.h&gt;

int main(int argc, char *argv[])
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  //Shows the window and returns when it is closed.
  return app-&gt;make_window_and_run&lt;ExampleWindow&gt;(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;iostream&gt;

ExampleWindow::ExampleWindow()
: m_VBox(Gtk::Orientation::VERTICAL),
  m_Label("The AboutDialog is non-modal. "
    "You can select parts of this text while the AboutDialog is shown."),
  m_ButtonBox(Gtk::Orientation::VERTICAL),
  m_Button("Show AboutDialog")
{
  set_title("Gtk::AboutDialog example");
  set_default_size(400, 150);

  set_child(m_VBox);

  m_VBox.append(m_Label);
  m_Label.set_expand(true);
  m_Label.set_wrap(true);
  m_Label.set_selectable(true);

  m_VBox.append(m_ButtonBox);
  m_ButtonBox.append(m_Button);
  m_Button.set_expand(true);
  m_Button.set_halign(Gtk::Align::CENTER);
  m_Button.set_valign(Gtk::Align::CENTER);
  m_Button.signal_clicked().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_clicked) );

  m_Dialog.set_transient_for(*this);
  m_Dialog.set_hide_on_close();

  m_Dialog.set_logo(Gdk::Texture::create_from_resource("/about/gtkmm_logo.gif"));
  m_Dialog.set_program_name("Example application");
  m_Dialog.set_version("1.0.0");
  m_Dialog.set_copyright("Murray Cumming");
  m_Dialog.set_comments("This is just an example application.");
  m_Dialog.set_license("LGPL");

  m_Dialog.set_website("http://www.gtkmm.org");
  m_Dialog.set_website_label("gtkmm website");

  std::vector&lt;Glib::ustring&gt; list_authors;
  list_authors.push_back("Murray Cumming");
  list_authors.push_back("Somebody Else");
  list_authors.push_back("AN Other");
  m_Dialog.set_authors(list_authors);

  m_Button.grab_focus();
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_button_clicked()
{
  m_Dialog.show();

  //Bring it to the front, in case it was already shown:
  m_Dialog.present();
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">aboutdialog.gresource.xml</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;gresources&gt;
  &lt;gresource prefix="/about"&gt;
    &lt;file&gt;gtkmm_logo.gif&lt;/file&gt;
  &lt;/gresource&gt;
&lt;/gresources&gt;
</pre></div>
</div>
</div>
</div>
<div class="division chapter">
<a name="chapter-drawingarea"><!--chapter-drawingarea--></a><div class="header"><h2 class="chapter title"><span class="title"><span class="label">16. </span>The DrawingArea Widget</span></h2></div>
<p class="para block block-first">
    The <span class="classname" dir="ltr">DrawingArea</span> widget is a blank window that gives
    you the freedom to create any graphic you desire. Along with that freedom
    comes the responsibility to draw on the widget. When a
    widget is first shown, or when it is covered and then uncovered again it
    needs to redraw itself. Most widgets have code to do this, but the
    <span class="classname" dir="ltr">DrawingArea</span> does not, allowing you to write your own
    draw function to determine how the contents of the widget will be drawn.
    This is done by setting a draw function with a call to the
    <span class="methodname" dir="ltr">set_draw_func()</span> member function.
  </p>
<p class="para block">
      GTK uses the <a class="ulink" href="http://cairographics.org" title="http://cairographics.org">Cairo</a> drawing API.
      With <span class="application">gtkmm</span>, you may use the <a class="ulink" href="http://www.cairographics.org/cairomm/" title="http://www.cairographics.org/cairomm/">cairomm</a> C++ API for cairo.
  </p>
<p class="para block">
      You can draw very sophisticated shapes using Cairo, but the methods to do
      so are quite basic. Cairo provides methods for drawing straight lines,
      curved lines, and arcs (including circles). These basic shapes can be
      combined to create more complex shapes and paths which can be filled with
      solid colors, gradients, patterns, and other things. In addition, Cairo
      can perform complex transformations, do compositing of images, and render
      antialiased text.
  </p>
<div class="admonition block note block-indent"><div class="note-inner">
      <div class="block block-first title title-formal"><span class="title"><span class="label"></span>Cairo and Pango</span></div>
      <p class="para block block-first">Although Cairo can render text, it's not meant to be a replacement for
      Pango. Pango is a better choice if you need to perform more advanced
      text rendering such as wrapping or ellipsizing text. Drawing text with
      Cairo should only be done if the text is part of a graphic.</p>
  </div></div>
<p class="para block">
      In this section of the tutorial, we'll cover the basic Cairo drawing
      model, describe each of the basic drawing elements in some detail (with
      examples), and then present a simple application that uses Cairo to draw
      a custom clock widget.
  </p>
<div class="autotoc"><ul>
<li>
<span class="label">16.1. </span><a class="xref" href="#sec-cairo-drawing-model" title="The Cairo Drawing Model">The Cairo Drawing Model</a>
</li>
<li>
<span class="label">16.2. </span><a class="xref" href="#sec-cairo-drawing-lines" title="Drawing Straight Lines">Drawing Straight Lines</a>
</li>
<li>
<span class="label">16.3. </span><a class="xref" href="#sec-cairo-curved-lines" title="Drawing Curved Lines">Drawing Curved Lines</a>
</li>
<li>
<span class="label">16.4. </span><a class="xref" href="#sec-cairo-drawing-arcs" title="Drawing Arcs and Circles">Drawing Arcs and Circles</a>
</li>
<li>
<span class="label">16.5. </span><a class="xref" href="#sec-drawing-text" title="Drawing Text">Drawing Text</a>
</li>
<li>
<span class="label">16.6. </span><a class="xref" href="#sec-draw-images" title="Drawing Images">Drawing Images</a>
</li>
<li>
<span class="label">16.7. </span><a class="xref" href="#sec-drawing-clock-example" title="Example Application: Creating a Clock with Cairo">Example Application: Creating a Clock with Cairo</a>
</li>
</ul></div>
<div class="division sect1">
<a name="sec-cairo-drawing-model"><!--sec-cairo-drawing-model--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">16.1. </span>The Cairo Drawing Model</span></h3></div>
<p class="para block block-first">
        The basic concept of drawing in Cairo involves defining 'invisible'
        paths and then stroking or filling them to make them visible.
    </p>
<p class="para block">
        To do any drawing in <span class="application">gtkmm</span> with Cairo, you must first get a
        <span class="classname" dir="ltr">Cairo::Context</span> object. This class holds all of the graphics state parameters that
        describe how drawing is to be done. This includes information such as
        line width, color, the surface to draw to, and many other things. This
        allows the actual drawing functions to take fewer arguments to simplify
        the interface. Usually, you use the <span class="classname" dir="ltr">Cairo::Context</span>
        that you get as input data to the draw function that you set with the call to
        <span class="methodname" dir="ltr">set_draw_func()</span>. It's also possible to create
        a <span class="classname" dir="ltr">Cairo::Context</span> by calling the
        <span class="methodname" dir="ltr">Gdk::Surface::create_cairo_context()</span> and
        <span class="methodname" dir="ltr">Gdk::CairoContext::cairo_create()</span> functions.
        Since Cairo contexts are reference-counted objects, <span class="methodname" dir="ltr">cairo_create()</span>
        returns a <span class="classname" dir="ltr">Cairo::RefPtr&lt;Cairo::Context&gt;</span> object.
        (Note the difference between <span class="classname" dir="ltr">Gdk::CairoContext</span>
        and <span class="classname" dir="ltr">Cairo::Context</span>.)
    </p>
<p class="para block">
        The following example shows  how to set up a Cairo context with a
        foreground color of red and a width of 2. Any drawing functions that
        use this context will use these settings.
    </p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">Gtk::DrawingArea myArea;
auto gdkCairoContext = myArea.get_surface()-&gt;create_cairo_context();
auto myContext = gdkCairoContext-&gt;cairo_create();
myContext-&gt;set_source_rgb(1.0, 0.0, 0.0);
myContext-&gt;set_line_width(2.0);
    </pre></div>
<p class="para block">
        Each <span class="classname" dir="ltr">Cairo::Context</span> is associated with a
        particular <span class="classname" dir="ltr">Gdk::Surface</span>, so the first line of the
        above example creates a <span class="classname" dir="ltr">Gtk::DrawingArea</span> widget
        and the next two lines use its associated <span class="classname" dir="ltr">Gdk::Surface</span>
        to create a <span class="classname" dir="ltr">Cairo::Context</span> object. The final
        two lines change the graphics state of the context.
    </p>
<p class="para block">
        There are a number of graphics state variables that can be set for a
        Cairo context. The most common context attributes are color (using
        <span class="methodname" dir="ltr">set_source_rgb()</span> or
        <span class="methodname" dir="ltr">set_source_rgba()</span> for translucent colors), line
        width (using <span class="methodname" dir="ltr">set_line_width()</span>), line dash pattern
        (using <span class="methodname" dir="ltr">set_dash()</span>), line cap style (using
        <span class="methodname" dir="ltr">set_line_cap()</span>), and line join style (using
        <span class="methodname" dir="ltr">set_line_join()</span>), and font styles (using
        <span class="methodname" dir="ltr">set_font_size()</span>,
        <span class="methodname" dir="ltr">set_font_face()</span> and others).
        There are many other settings as well, such as transformation matrices,
        fill rules, whether to perform antialiasing, and others. For further
        information, see the <a class="ulink" href="http://www.cairographics.org/cairomm/" title="http://www.cairographics.org/cairomm/">cairomm</a> API documentation.
    </p>
<p class="para block">
        The current state of a <span class="classname" dir="ltr">Cairo::Context</span> can be
        saved to an internal stack of saved states and later be restored to the
        state it was in when you saved it. To do this, use the
        <span class="methodname" dir="ltr">save()</span>
        method and the <span class="methodname" dir="ltr">restore()</span> method. This can be
        useful if you need to temporarily change the line width and color (or
        any other graphics setting) in order to draw something and then return
        to the previous settings. In this situation, you could call
        <span class="methodname" dir="ltr">Cairo::Context::save()</span>, change the graphics
        settings, draw the lines, and then call
        <span class="methodname" dir="ltr">Cairo::Context::restore()</span> to restore the original
        graphics state. Multiple calls to <span class="methodname" dir="ltr">save()</span> and
        <span class="methodname" dir="ltr">restore()</span> can be nested; each call to
        <span class="methodname" dir="ltr">restore()</span> restores the state from the
        matching paired <span class="methodname" dir="ltr">save()</span>.
        <div class="admonition block tip block-indent"><div class="tip-inner">
            <p class="para block block-first">It is good practice to put all modifications to the graphics state
            between <span class="methodname" dir="ltr">save()</span>/<span class="methodname" dir="ltr">restore()</span>
            function calls. For example, if you have a function that takes a
            <span class="classname" dir="ltr">Cairo::Context</span> reference as an argument, you
            might implement it as follows:
          </p>
          <div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">void doSomething(const Cairo::RefPtr&lt;Cairo::Context&gt;&amp; context, int x)
{
    context-&gt;save();
    // change graphics state
    // perform drawing operations
    context-&gt;restore();
}</pre></div>
        </div></div>
    </p>
<p class="para block">
        The draw function that you set with a call to <span class="methodname" dir="ltr">set_draw_func()</span>
        is called with a Cairo context that you shall use for drawing in the
        <span class="classname" dir="ltr">Gtk::DrawingArea</span> widget. It is not necessary to
        save and restore this Cairo context in the draw function.
    </p>
</div>
<div class="division sect1">
<a name="sec-cairo-drawing-lines"><!--sec-cairo-drawing-lines--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">16.2. </span>Drawing Straight Lines</span></h3></div>
<p class="para block block-first">
        Now that we understand the basics of the Cairo graphics library, we're
        almost ready to start drawing. We'll start with the simplest of
        drawing elements: the straight line. But first you need to know a
        little bit about Cairo's coordinate system. The origin of the Cairo
        coordinate system is located in the upper-left corner of the window
        with positive x values to the right and positive y values going down.
        <div class="admonition block tip block-first block-indent"><div class="tip-inner">
            <p class="para block block-first">Since the Cairo graphics library was written with support for
            multiple output targets (the X window system, PNG images, OpenGL,
            etc), there is a distinction between user-space and device-space
            coordinates. The mapping between these two coordinate systems
            defaults to one-to-one so that integer values map roughly to pixels
            on the screen, but this setting can be adjusted if desired.
            Sometimes it may be useful to scale the coordinates so that the
            full width and height of a window both range from 0 to 1 (the 'unit
            square') or some other mapping that works for your application.
            This can be done with the
            <span class="methodname" dir="ltr">Cairo::Context::scale()</span> function.</p>
        </div></div>
    </p>
<div class="autotoc"><ul>
<li>
<span class="label">16.2.1. </span><a class="xref" href="#cairo-example-lines" title="Example">Example</a>
</li>
<li>
<span class="label">16.2.2. </span><a class="xref" href="#cairo-line-styles" title="Line styles">Line styles</a>
</li>
<li>
<span class="label">16.2.3. </span><a class="xref" href="#sec-cairo-thin-lines" title="Drawing thin lines">Drawing thin lines</a>
</li>
</ul></div>
<div class="division sect2">
<a name="cairo-example-lines"><!--cairo-example-lines--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">16.2.1. </span>Example</span></h4></div>
<p class="para block block-first">
        In this example, we'll construct a small but fully functional <span class="application">gtkmm</span>
        program and draw some lines into the window. The lines are drawn by
        creating a path and then stroking it. A path is created using the
        functions <span class="methodname" dir="ltr">Cairo::Context::move_to()</span> and
        <span class="methodname" dir="ltr">Cairo::Context::line_to()</span>. The function
        <span class="methodname" dir="ltr">move_to()</span> is similar to the act of lifting your
        pen off of the paper and placing it somewhere else -- no line is drawn
        between the point you were at and the point you moved to. To draw a
        line between two points, use the <span class="methodname" dir="ltr">line_to()</span>
        function.
    </p>
<p class="para block">
        After you've finished creating your path, you still haven't
        drawn anything visible yet. To make the path visible, you must use the
        function <span class="methodname" dir="ltr">stroke()</span> which will stroke the current
        path with the line width and style specified in your
        <span class="classname" dir="ltr">Cairo::Context</span> object. After stroking, the
        current path will be cleared so that you can start on your next path.
    </p>
<div class="admonition block tip block-indent"><div class="tip-inner">
            <p class="para block block-first">Many Cairo drawing functions have a <span class="methodname" dir="ltr">_preserve()</span>
            variant. Normally drawing functions such as
            <span class="methodname" dir="ltr">clip()</span>, <span class="methodname" dir="ltr">fill()</span>, or
            <span class="methodname" dir="ltr">stroke()</span> will clear the current path. If you
            use the <span class="methodname" dir="ltr">_preserve()</span> variant, the current path
            will be retained so that you can use the same path with the next
            drawing function.</p>
        </div></div>
<div class=" block figure block-indent">
<a name="figure-drawingarea-lines"><!--figure-drawingarea-lines--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 16-1</span> </span>Drawing Area - Lines</span></div>
<div class="figure-inner">
      
      <div class=" block screenshot block-first">
        <div class="graphic"><img src="figures/drawingarea_lines.png.en"></div>
      </div>
    </div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/drawingarea/simple" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/drawingarea/simple">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">myarea.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLE_MYAREA_H
#define GTKMM_EXAMPLE_MYAREA_H

#include &lt;gtkmm/drawingarea.h&gt;

class MyArea : public Gtk::DrawingArea
{
public:
  MyArea();
  virtual ~MyArea();

protected:
  void on_draw(const Cairo::RefPtr&lt;Cairo::Context&gt;&amp; cr, int width, int height);
};

#endif // GTKMM_EXAMPLE_MYAREA_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "myarea.h"
#include &lt;gtkmm/application.h&gt;
#include &lt;gtkmm/window.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();

protected:
  MyArea m_area;
};

ExampleWindow::ExampleWindow()
{
  set_title("DrawingArea");
  set_child(m_area);
}

int main(int argc, char** argv)
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  return app-&gt;make_window_and_run&lt;ExampleWindow&gt;(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">myarea.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "myarea.h"
#include &lt;cairomm/context.h&gt;

MyArea::MyArea()
{
  set_draw_func(sigc::mem_fun(*this, &amp;MyArea::on_draw));
}

MyArea::~MyArea()
{
}

void MyArea::on_draw(const Cairo::RefPtr&lt;Cairo::Context&gt;&amp; cr, int width, int height)
{
  // coordinates for the center of the window
  int xc, yc;
  xc = width / 2;
  yc = height / 2;

  cr-&gt;set_line_width(10.0);

  // draw red lines out from the center of the window
  cr-&gt;set_source_rgb(0.8, 0.0, 0.0);
  cr-&gt;move_to(0, 0);
  cr-&gt;line_to(xc, yc);
  cr-&gt;line_to(0, height);
  cr-&gt;move_to(xc, yc);
  cr-&gt;line_to(width, yc);
  cr-&gt;stroke();
}
</pre></div>
<p class="para block">
        This program contains a single class, <span class="classname" dir="ltr">MyArea</span>,
        which is a subclass of <span class="classname" dir="ltr">Gtk::DrawingArea</span> and
        contains an <span class="methodname" dir="ltr">on_draw()</span> member function.
        This function becomes the draw function by a call to <span class="methodname" dir="ltr">set_draw_func()</span>
        in <span class="classname" dir="ltr">MyArea</span>'s constructor. <span class="methodname" dir="ltr">on_draw()</span>
        is then called whenever the image in the drawing area needs to
        be redrawn. It is passed a <span class="classname" dir="ltr">Cairo::RefPtr</span>
        pointer to a <span class="classname" dir="ltr">Cairo::Context</span> that we use
        for the drawing.
        The actual drawing code sets the color we want to use for drawing by
        using <span class="methodname" dir="ltr">set_source_rgb()</span> which takes arguments
        defining the Red, Green, and Blue components of the desired color
        (valid values are between 0 and 1). After setting the color, we
        created a new path using the functions <span class="methodname" dir="ltr">move_to()</span>
        and <span class="methodname" dir="ltr">line_to()</span>, and then stroked this path with
        <span class="methodname" dir="ltr">stroke()</span>.
    </p>
<div class="admonition block tip block-indent"><div class="tip-inner">
        <div class="block block-first title title-formal"><span class="title"><span class="label"></span>Drawing with relative coordinates</span></div>
        <p class="para block block-first">In the example above we drew everything using absolute coordinates. You can also draw using
        relative coordinates. For a straight line, this is done with the
        function <span class="methodname" dir="ltr">Cairo::Context::rel_line_to()</span>.</p>
    </div></div>
</div>
<div class="division sect2">
<a name="cairo-line-styles"><!--cairo-line-styles--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">16.2.2. </span>Line styles</span></h4></div>
<p class="para block block-first">
            In addition to drawing basic straight lines, there are a number of
            things that you can customize about a line. You've already seen
            examples of setting a line's color and width, but there are others
            as well.
        </p>
<p class="para block">
            If you've drawn a series of lines that form a path, you may
            want them to join together in a certain way. Cairo offers
            three different ways to join lines together: Miter, Bevel, and
            Round. These are show below:
        </p>
<div class=" block figure block-indent">
<a name="figure-cairo-joins"><!--figure-cairo-joins--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 16-2</span> </span>Different join types in Cairo</span></div>
<div class="figure-inner">
            
            <div class=" block screenshot block-first">
                <div class="graphic"><img src="figures/cairo_joins.png.en"></div>
            </div>
        </div>
</div>
<p class="para block">
            The line join style is set using the function
            <span class="methodname" dir="ltr">Cairo::Context::set_line_join()</span>.
        </p>
<p class="para block">
            Line ends can have different styles as well. The default style
            is for the line to start and stop exactly at the destination
            points of the line. This is called a Butt cap. The other
            options are Round (uses a round ending, with the center of the
            circle at the end point) or Square (uses a squared ending, with
            the center of the square at the end point). This setting is set
            using the function
            <span class="methodname" dir="ltr">Cairo::Context::set_line_cap()</span>.
        </p>
<p class="para block">
            There are other things you can customize as well, including
            creating dashed lines and other things. For more information, see
            the Cairo API documentation.
        </p>
</div>
<div class="division sect2">
<a name="sec-cairo-thin-lines"><!--sec-cairo-thin-lines--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">16.2.3. </span>Drawing thin lines</span></h4></div>
<p class="para block block-first">
        If you try to draw one pixel wide lines, you may notice that the line
        sometimes comes up blurred and wider than it ought to be.
        This happens because Cairo will try to draw from the selected position,
        to both sides (half to each), so if you're positioned right on the
        intersection of the pixels, and want a one pixel wide line, Cairo will try
        to use half of each adjacent pixel, which isn't possible (a pixel is the
        smallest unit possible). This happens when the width of the line is an
        odd number of pixels (not just one pixel).
      </p>
<p class="para block">
        The trick is to position in the middle of the pixel where you want the
        line to be drawn, and thus guaranteeing you get the desired results.
        See <a class="ulink" href="http://cairographics.org/FAQ/#sharp_lines" title="http://cairographics.org/FAQ/#sharp_lines">Cairo FAQ</a>.
      </p>
<div class=" block figure block-indent">
<a name="figure-drawingarea-thin-lines"><!--figure-drawingarea-thin-lines--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 16-3</span> </span>Drawing Area - Thin Lines</span></div>
<div class="figure-inner">
        
        <div class=" block screenshot block-first">
          <div class="graphic"><img src="figures/drawingarea_thin_lines.png.en"></div>
        </div>
      </div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/drawingarea/thin_lines" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/drawingarea/thin_lines">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm/window.h&gt;
#include &lt;gtkmm/box.h&gt;
#include &lt;gtkmm/checkbutton.h&gt;
#include "myarea.h"

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_button_toggled();

private:
  Gtk::Box m_HBox;
  MyArea m_Area_Lines;
  Gtk::CheckButton m_Button_FixLines;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">myarea.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLE_MYAREA_H
#define GTKMM_EXAMPLE_MYAREA_H

#include &lt;gtkmm/drawingarea.h&gt;

class MyArea : public Gtk::DrawingArea
{
public:
  MyArea();
  virtual ~MyArea();

  void fix_lines(bool fix = true);

protected:
  void on_draw(const Cairo::RefPtr&lt;Cairo::Context&gt;&amp; cr, int width, int height);

private:
  double m_fix;
};

#endif // GTKMM_EXAMPLE_MYAREA_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;gtkmm/application.h&gt;

int main(int argc, char* argv[])
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  //Shows the window and returns when it is closed.
  return app-&gt;make_window_and_run&lt;ExampleWindow&gt;(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"

ExampleWindow::ExampleWindow()
: m_HBox(Gtk::Orientation::HORIZONTAL),
  m_Button_FixLines("Fix lines")
{
  set_title("Thin lines example");

  m_HBox.append(m_Area_Lines);
  m_HBox.append(m_Button_FixLines);

  set_child(m_HBox);

  m_Button_FixLines.signal_toggled().connect(
    sigc::mem_fun(*this, &amp;ExampleWindow::on_button_toggled));

  // Synchonize the drawing in m_Area_Lines with the state of the toggle button.
  on_button_toggled();
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_button_toggled()
{
  m_Area_Lines.fix_lines(m_Button_FixLines.get_active());
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">myarea.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "myarea.h"

MyArea::MyArea()
: m_fix (0)
{
  set_content_width(200);
  set_content_height(100);
  set_draw_func(sigc::mem_fun(*this, &amp;MyArea::on_draw));
}

MyArea::~MyArea()
{
}

void MyArea::on_draw(const Cairo::RefPtr&lt;Cairo::Context&gt;&amp; cr, int width, int height)
{
  cr-&gt;set_line_width(1.0);

  // draw one line, every two pixels
  // without the 'fix', you won't notice any space between the lines,
  // since each one will occupy two pixels (width)
  for (int i = 0; i &lt; width; i += 2)
  {
    cr-&gt;move_to(i + m_fix, 0);
    cr-&gt;line_to(i + m_fix, height);
  }

  cr-&gt;stroke();
}

// Toogle between both values (0 or 0.5)
void MyArea::fix_lines(bool fix)
{
  // to get the width right, we have to draw in the middle of the pixel
  m_fix = fix ? 0.5 : 0.0;

  // force the redraw of the image
  queue_draw();
}
</pre></div>
</div>
</div>
<div class="division sect1">
<a name="sec-cairo-curved-lines"><!--sec-cairo-curved-lines--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">16.3. </span>Drawing Curved Lines</span></h3></div>
<p class="para block block-first">
            In addition to drawing straight lines Cairo allows you to easily
            draw curved lines (technically a cubic Bézier spline) using the
            <span class="methodname" dir="ltr">Cairo::Context::curve_to()</span> and
            <span class="methodname" dir="ltr">Cairo::Context::rel_curve_to()</span> functions.
            These functions take coordinates for a destination point as well as
            coordinates for two 'control' points. This is best explained using
            an example, so let's dive in.
        </p>
<div class="autotoc"><ul><li>
<span class="label">16.3.1. </span><a class="xref" href="#cairo-example-curves" title="Example">Example</a>
</li></ul></div>
<div class="division sect2">
<a name="cairo-example-curves"><!--cairo-example-curves--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">16.3.1. </span>Example</span></h4></div>
<p class="para block block-first">
                This simple application draws a curve with Cairo and displays
                the control points for each end of the curve.
            </p>
<div class=" block figure block-indent">
<a name="figure-drawingarea-curve"><!--figure-drawingarea-curve--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 16-4</span> </span>Drawing Area - Lines</span></div>
<div class="figure-inner">
            
            <div class=" block screenshot block-first">
                <div class="graphic"><img src="figures/drawingarea_curve.png.en"></div>
            </div>
        </div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/drawingarea/curve" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/drawingarea/curve">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">myarea.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLE_MYAREA_H
#define GTKMM_EXAMPLE_MYAREA_H

#include &lt;gtkmm/drawingarea.h&gt;

class MyArea : public Gtk::DrawingArea
{
public:
  MyArea();
  virtual ~MyArea();

protected:
  void on_draw(const Cairo::RefPtr&lt;Cairo::Context&gt;&amp; cr, int width, int height);
};

#endif // GTKMM_EXAMPLE_MYAREA_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "myarea.h"
#include &lt;gtkmm/application.h&gt;
#include &lt;gtkmm/window.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();

protected:
  MyArea m_area;
};

ExampleWindow::ExampleWindow()
{
  set_title("DrawingArea");
  set_child(m_area);
}

int main(int argc, char** argv)
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  return app-&gt;make_window_and_run&lt;ExampleWindow&gt;(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">myarea.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "myarea.h"
#include &lt;cairomm/context.h&gt;

MyArea::MyArea()
{
  set_draw_func(sigc::mem_fun(*this, &amp;MyArea::on_draw));
}

MyArea::~MyArea()
{
}

void MyArea::on_draw(const Cairo::RefPtr&lt;Cairo::Context&gt;&amp; cr, int width, int height)
{
  double x0=0.1, y0=0.5, // start point
         x1=0.4, y1=0.9,  // control point #1
         x2=0.6, y2=0.1,  // control point #2
         x3=0.9, y3=0.5;  // end point

  // scale to unit square (0 to 1 width and height)
  cr-&gt;scale(width, height);

  cr-&gt;set_line_width(0.05);
  // draw curve
  cr-&gt;move_to(x0, y0);
  cr-&gt;curve_to(x1, y1, x2, y2, x3, y3);
  cr-&gt;stroke();
  // show control points
  cr-&gt;set_source_rgba(1, 0.2, 0.2, 0.6);
  cr-&gt;move_to(x0, y0);
  cr-&gt;line_to (x1, y1);
  cr-&gt;move_to(x2, y2);
  cr-&gt;line_to (x3, y3);
  cr-&gt;stroke();
}
</pre></div>
<p class="para block">
            The only difference between this example and the straight line
            example is in the <span class="methodname" dir="ltr">on_draw()</span> function,
            but there are a few new concepts and functions introduced here, so
            let's examine them briefly.
        </p>
<p class="para block">
            We make a call to
            <span class="methodname" dir="ltr">Cairo::Context::scale()</span>, passing in the width
            and height of the drawing area. This scales the user-space
            coordinate system such that the width and height of the widget
            are both equal to 1.0 'units'. There's no particular reason to
            scale the coordinate system in this case, but sometimes it can make
            drawing operations easier.
        </p>
<p class="para block">
            The call to <span class="methodname" dir="ltr">Cairo::Context::curve_to()</span> should
            be fairly self-explanatory. The first pair of coordinates define
            the control point for the beginning of the curve. The second set
            of coordinates define the control point for the end of the curve,
            and the last set of coordinates define the destination point. To
            make the concept of control points a bit easier to visualize, a
            line has been drawn from each control point to the end-point on the
            curve that it is associated with. Note that these control point
            lines are both translucent. This is achieved with a variant of
            <span class="methodname" dir="ltr">set_source_rgb()</span> called
            <span class="methodname" dir="ltr">set_source_rgba()</span>. This function takes a
            fourth argument specifying the alpha value of the color (valid
            values are between 0 and 1).
        </p>
</div>
</div>
<div class="division sect1">
<a name="sec-cairo-drawing-arcs"><!--sec-cairo-drawing-arcs--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">16.4. </span>Drawing Arcs and Circles</span></h3></div>
<p class="para block block-first">
          With Cairo, the same function is used to draw arcs, circles, or
          ellipses: <span class="methodname" dir="ltr">Cairo::Context::arc()</span>. This function
          takes five arguments. The first two are the coordinates of the
          center point of the arc, the third argument is the radius of the arc,
          and the final two arguments define the start and end angle of the
          arc. All angles are defined in radians, so drawing a circle is the
          same as drawing an arc from 0 to 2 * M_PI radians.
          An angle of 0 is in the direction of the positive X axis (in user-space). An
          angle of M_PI/2 radians (90 degrees) is in the direction of the positive Y axis
          (in user-space). Angles increase in the direction from the positive X axis
          toward the positive Y axis. So with the default transformation matrix, angles
          increase in a clockwise direction. (Remember that the positive Y axis
          points downwards.)
      </p>
<p class="para block">
          To draw an ellipse, you can scale the current transformation matrix
          by different amounts in the X and Y directions. For example, to draw
          an ellipse with center at <span class="varname" dir="ltr">x</span>, <span class="varname" dir="ltr">y</span>
          and size <span class="varname" dir="ltr">width</span>, <span class="varname" dir="ltr">height</span>:
      </p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">context-&gt;save();
context-&gt;translate(x, y);
context-&gt;scale(width / 2.0, height / 2.0);
context-&gt;arc(0.0, 0.0, 1.0, 0.0, 2 * M_PI);
context-&gt;restore();</pre></div>
<div class="autotoc"><ul><li>
<span class="label">16.4.1. </span><a class="xref" href="#cairo-example-arcs" title="Example">Example</a>
</li></ul></div>
<div class="division sect2">
<a name="cairo-example-arcs"><!--cairo-example-arcs--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">16.4.1. </span>Example</span></h4></div>
<p class="para block block-first">
              Here's an example of a simple program that draws an arc, a circle
              and an ellipse into a drawing area.
          </p>
<div class=" block figure block-indent">
<a name="figure-drawingarea-arc"><!--figure-drawingarea-arc--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 16-5</span> </span>Drawing Area - Arcs</span></div>
<div class="figure-inner">
              
              <div class=" block screenshot block-first">
                  <div class="graphic"><img src="figures/drawingarea_arcs.png.en"></div>
              </div>
          </div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/drawingarea/arcs" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/drawingarea/arcs">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">myarea.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLE_MYAREA_H
#define GTKMM_EXAMPLE_MYAREA_H

#include &lt;gtkmm/drawingarea.h&gt;

class MyArea : public Gtk::DrawingArea
{
public:
  MyArea();
  virtual ~MyArea();

protected:
  void on_draw(const Cairo::RefPtr&lt;Cairo::Context&gt;&amp; cr, int width, int height);
};

#endif // GTKMM_EXAMPLE_MYAREA_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "myarea.h"
#include &lt;gtkmm/application.h&gt;
#include &lt;gtkmm/window.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();

protected:
  MyArea m_area;
};

ExampleWindow::ExampleWindow()
{
  set_title("DrawingArea");
  set_child(m_area);
}

int main(int argc, char** argv)
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  return app-&gt;make_window_and_run&lt;ExampleWindow&gt;(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">myarea.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "myarea.h"
#include &lt;cairomm/context.h&gt;
#include &lt;cmath&gt;

MyArea::MyArea()
{
  set_draw_func(sigc::mem_fun(*this, &amp;MyArea::on_draw));
}

MyArea::~MyArea()
{
}

void MyArea::on_draw(const Cairo::RefPtr&lt;Cairo::Context&gt;&amp; cr, int width, int height)
{
  const int lesser = std::min(width, height);

  // coordinates for the center of the window
  const int xc = width / 2;
  const int yc = height / 2;

  cr-&gt;set_line_width(lesser * 0.02);  // outline thickness changes
                                      // with window size

  // first draw a simple unclosed arc
  cr-&gt;save();
  cr-&gt;arc(width / 3.0, height / 4.0, lesser / 4.0, -(M_PI / 5.0), M_PI);
  cr-&gt;close_path();   // line back to start point
  cr-&gt;set_source_rgb(0.0, 0.8, 0.0);
  cr-&gt;fill_preserve();
  cr-&gt;restore();  // back to opaque black
  cr-&gt;stroke();   // outline it

  // now draw a circle
  cr-&gt;save();
  cr-&gt;arc(xc, yc, lesser / 4.0, 0.0, 2.0 * M_PI); // full circle
  cr-&gt;set_source_rgba(0.0, 0.0, 0.8, 0.6);    // partially translucent
  cr-&gt;fill_preserve();
  cr-&gt;restore();  // back to opaque black
  cr-&gt;stroke();

  // and finally an ellipse
  double ex, ey, ew, eh;
  // center of ellipse
  ex = xc;
  ey = 3.0 * height / 4.0;
  // ellipse dimensions
  ew = 3.0 * width / 4.0;
  eh = height / 3.0;

  cr-&gt;save();

  cr-&gt;translate(ex, ey);  // make (ex, ey) == (0, 0)
  cr-&gt;scale(ew / 2.0, eh / 2.0);  // for width: ew / 2.0 == 1.0
                                  // for height: eh / 2.0 == 1.0

  cr-&gt;arc(0.0, 0.0, 1.0, 0.0, 2 * M_PI);  // 'circle' centered at (0, 0)
                                          // with 'radius' of 1.0

  cr-&gt;set_source_rgba(0.8, 0.0, 0.0, 0.7);
  cr-&gt;fill_preserve();
  cr-&gt;restore();  // back to opaque black
  cr-&gt;stroke();
}
</pre></div>
<p class="para block">
              There are a couple of things to note about this example code.
              Again, the only real difference between this example and the
              previous ones is the <span class="methodname" dir="ltr">on_draw()</span>
              function, so we'll limit our focus to that function. In
              addition, the first part of the function is nearly identical to
              the previous examples, so we'll skip that portion.
          </p>
<p class="para block">
              Note that in this case, we've expressed nearly everything in
              terms of the height and width of the window, including the width
              of the lines. Because of this, when you resize the window,
              everything scales with the window. Also note that there are
              three drawing sections in the function and each is wrapped with a
              <span class="methodname" dir="ltr">save()</span>/<span class="methodname" dir="ltr">restore()</span> pair
              so that we're back at a known state after each drawing.
          </p>
<p class="para block">
              The section for drawing an arc introduces one new function,
              <span class="methodname" dir="ltr">close_path()</span>. This function will in effect
              draw a straight line from the current point back to the first
              point in the path. There is a significant difference between
              calling <span class="methodname" dir="ltr">close_path()</span> and manually drawing a
              line back to the starting point, however. If you use
              <span class="methodname" dir="ltr">close_path()</span>, the lines will be nicely
              joined together. If you use <span class="methodname" dir="ltr">line_to()</span>
              instead, the lines will end at the same point, but Cairo won't do
              any special joining.
          </p>
<div class="admonition block note block-indent"><div class="note-inner">
              <div class="block block-first title title-formal"><span class="title"><span class="label"></span>Drawing counter-clockwise</span></div>
              <p class="para block block-first">
                  The function
                  <span class="methodname" dir="ltr">Cairo::Context::arc_negative()</span> is
                  exactly the same as
                  <span class="methodname" dir="ltr">Cairo::Context::arc()</span> but the angles go
                  the opposite direction.
              </p>
          </div></div>
</div>
</div>
<div class="division sect1">
<a name="sec-drawing-text"><!--sec-drawing-text--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">16.5. </span>Drawing Text</span></h3></div>
<div class="autotoc"><ul>
<li>
<span class="label">16.5.1. </span><a class="xref" href="#drawing-text-pango" title="Drawing Text with Pango">Drawing Text with Pango</a>
</li>
<li>
<span class="label">16.5.2. </span><a class="xref" href="#pango-text-example" title="Example">Example</a>
</li>
</ul></div>
<div class="division sect2">
<a name="drawing-text-pango"><!--drawing-text-pango--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">16.5.1. </span>Drawing Text with Pango</span></h4></div>
<p class="para block block-first">
              Text is drawn via Pango Layouts. The easiest way to create a
              <span class="classname" dir="ltr">Pango::Layout</span> is to use
              <span class="methodname" dir="ltr">Gtk::Widget::create_pango_layout()</span>.
              Once created, the layout can be manipulated in various ways,
              including changing the text, font, etc. Finally, the layout can
              be rendered using the
              <span class="methodname" dir="ltr">Pango::Layout::show_in_cairo_context()</span> method.
          </p>
</div>
<div class="division sect2">
<a name="pango-text-example"><!--pango-text-example--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">16.5.2. </span>Example</span></h4></div>
<p class="para block block-first">
           Here is an example of a program that draws some text, some of it
           upside-down. The Printing chapter contains another
           <a class="link" href="#sec-printing-example" title="Example">example</a> of drawing text.
        </p>
<div class=" block figure block-indent">
<a name="figure-drawingarea-pango-text"><!--figure-drawingarea-pango-text--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 16-6</span> </span>Drawing Area - Text</span></div>
<div class="figure-inner">
            
            <div class=" block screenshot block-first">
                <div class="graphic"><img src="figures/drawingarea_pango_text.png.en"></div>
            </div>
        </div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/drawingarea/pango_text" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/drawingarea/pango_text">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">myarea.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLE_MYAREA_H
#define GTKMM_EXAMPLE_MYAREA_H

#include &lt;gtkmm/drawingarea.h&gt;

class MyArea : public Gtk::DrawingArea
{
public:
  MyArea();
  virtual ~MyArea();

protected:
  void on_draw(const Cairo::RefPtr&lt;Cairo::Context&gt;&amp; cr, int width, int height);

private:
  void draw_rectangle(const Cairo::RefPtr&lt;Cairo::Context&gt;&amp; cr, int width, int height);
  void draw_text(const Cairo::RefPtr&lt;Cairo::Context&gt;&amp; cr, int rectangle_width, int rectangle_height);

};

#endif // GTKMM_EXAMPLE_MYAREA_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "myarea.h"
#include &lt;gtkmm/application.h&gt;
#include &lt;gtkmm/window.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();

protected:
  MyArea m_area;
};

ExampleWindow::ExampleWindow()
{
  set_title("Drawing text example");
  set_child(m_area);
}

int main(int argc, char* argv[])
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  return app-&gt;make_window_and_run&lt;ExampleWindow&gt;(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">myarea.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "myarea.h"

MyArea::MyArea()
{
  set_draw_func(sigc::mem_fun(*this, &amp;MyArea::on_draw));
}

MyArea::~MyArea()
{
}

void MyArea::on_draw(const Cairo::RefPtr&lt;Cairo::Context&gt;&amp; cr, int width, int height)
{
  const int rectangle_width = width;
  const int rectangle_height = height / 2;

  // Draw a black rectangle
  cr-&gt;set_source_rgb(0.0, 0.0, 0.0);
  draw_rectangle(cr, rectangle_width, rectangle_height);

  // and some white text
  cr-&gt;set_source_rgb(1.0, 1.0, 1.0);
  draw_text(cr, rectangle_width, rectangle_height);

  // flip the image vertically
  // see http://www.cairographics.org/documentation/cairomm/reference/classCairo_1_1Matrix.html
  // the -1 corresponds to the yy part (the flipping part)
  // the height part is a translation (we could have just called cr-&gt;translate(0, height) instead)
  // it's height and not height / 2, since we want this to be on the second part of our drawing
  // (otherwise, it would draw over the previous part)
  Cairo::Matrix matrix(1.0, 0.0, 0.0, -1.0, 0.0, height);

  // apply the matrix
  cr-&gt;transform(matrix);

  // white rectangle
  cr-&gt;set_source_rgb(1.0, 1.0, 1.0);
  draw_rectangle(cr, rectangle_width, rectangle_height);

  // black text
  cr-&gt;set_source_rgb(0.0, 0.0, 0.0);
  draw_text(cr, rectangle_width, rectangle_height);
}

void MyArea::draw_rectangle(const Cairo::RefPtr&lt;Cairo::Context&gt;&amp; cr,
                            int width, int height)
{
  cr-&gt;rectangle(0, 0, width, height);
  cr-&gt;fill();
}

void MyArea::draw_text(const Cairo::RefPtr&lt;Cairo::Context&gt;&amp; cr,
                       int rectangle_width, int rectangle_height)
{
  // http://developer.gnome.org/pangomm/unstable/classPango_1_1FontDescription.html
  Pango::FontDescription font;

  font.set_family("Monospace");
  font.set_weight(Pango::Weight::BOLD);

  // http://developer.gnome.org/pangomm/unstable/classPango_1_1Layout.html
  auto layout = create_pango_layout("Hi there!");

  layout-&gt;set_font_description(font);

  int text_width;
  int text_height;

  //get the text dimensions (it updates the variables -- by reference)
  layout-&gt;get_pixel_size(text_width, text_height);

  // Position the text in the middle
  cr-&gt;move_to((rectangle_width-text_width)/2, (rectangle_height-text_height)/2);

  layout-&gt;show_in_cairo_context(cr);
}
</pre></div>
</div>
</div>
<div class="division sect1">
<a name="sec-draw-images"><!--sec-draw-images--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">16.6. </span>Drawing Images</span></h3></div>
<p class="para block block-first">
              There is a method for drawing from a
              <span class="classname" dir="ltr">Gdk::Pixbuf</span> to a <span class="classname" dir="ltr">Cairo::Context</span>.
              A <span class="classname" dir="ltr">Gdk::Pixbuf</span> buffer is a useful wrapper
              around a collection of pixels, which can be read from files, and
              manipulated in various ways.
          </p>
<p class="para block">
              Probably the most common way of creating
              <span class="classname" dir="ltr">Gdk::Pixbuf</span>s is to use
              <span class="methodname" dir="ltr">Gdk::Pixbuf::create_from_file()</span> or
              <span class="methodname" dir="ltr">Gdk::Pixbuf::create_from_resource()</span>,
              which can read an image file, such as a png file into a pixbuf
              ready for rendering.
          </p>
<p class="para block">
              The <span class="classname" dir="ltr">Gdk::Pixbuf</span> can be rendered by setting
              it as the source pattern of the Cairo context with
              <span class="methodname" dir="ltr">Gdk::Cairo::set_source_pixbuf()</span>.
              Then draw the image with either <span class="methodname" dir="ltr">Cairo::Context::paint()</span>
              (to draw the whole image), or <span class="methodname" dir="ltr">Cairo::Context::rectangle()</span>
              and <span class="methodname" dir="ltr">Cairo::Context::fill()</span> (to fill the
              specified rectangle). <span class="methodname" dir="ltr">set_source_pixbuf()</span>
              is not a member of <span class="classname" dir="ltr">Cairo::Context</span>. It takes
              a <span class="classname" dir="ltr">Cairo::Context</span> as its first parameter.
          </p>
<p class="para block">
              Here is a small bit of code to tie it all together: (Note that
              usually you wouldn't load the image every time in the draw
              signal handler! It's just shown here to keep it all together.)
          </p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">void MyArea::on_draw(const Cairo::RefPtr&lt;Cairo::Context&gt;&amp; cr, int width, int height)
{
  auto image = Gdk::Pixbuf::create_from_file("myimage.png");
  // Draw the image at 110, 90, except for the outermost 10 pixels.
  Gdk::Cairo::set_source_pixbuf(cr, image, 100, 80);
  cr-&gt;rectangle(110, 90, image-&gt;get_width()-20, image-&gt;get_height()-20);
  cr-&gt;fill();
}</pre></div>
<div class="autotoc"><ul><li>
<span class="label">16.6.1. </span><a class="xref" href="#cairo-example-image" title="Example">Example</a>
</li></ul></div>
<div class="division sect2">
<a name="cairo-example-image"><!--cairo-example-image--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">16.6.1. </span>Example</span></h4></div>
<p class="para block block-first">
                Here is an example of a simple program that draws an image.
                The program loads the image from a resource file. See the <a class="link" href="#sec-gio-resource" title="Gio::Resource and glib-compile-resources">Gio::Resource and glib-compile-resources</a>
                section. Use <span class="application">glib-compile-resources</span> to compile
                the resources into a C source file that can be compiled and
                linked with the C++ code. E.g.
                <div dir="ltr" class=" block screen block-indent"><pre class="screen">$ glib-compile-resources --target=resources.c --generate-source image.gresource.xml</pre></div>
            </p>
<div class=" block figure block-indent">
<a name="figure-drawingarea-image"><!--figure-drawingarea-image--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 16-7</span> </span>Drawing Area - Image</span></div>
<div class="figure-inner">
            
            <div class=" block screenshot block-first">
                <div class="graphic"><img src="figures/drawingarea_image.png.en"></div>
            </div>
        </div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/drawingarea/image" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/drawingarea/image">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">myarea.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLE_MYAREA_H
#define GTKMM_EXAMPLE_MYAREA_H

#include &lt;gtkmm/drawingarea.h&gt;
#include &lt;gdkmm/pixbuf.h&gt;

class MyArea : public Gtk::DrawingArea
{
public:
  MyArea();
  virtual ~MyArea();

protected:
  void on_draw(const Cairo::RefPtr&lt;Cairo::Context&gt;&amp; cr, int width, int height);

  Glib::RefPtr&lt;Gdk::Pixbuf&gt; m_image;
};

#endif // GTKMM_EXAMPLE_MYAREA_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "myarea.h"
#include &lt;gtkmm/application.h&gt;
#include &lt;gtkmm/window.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();

protected:
  MyArea m_area;
};

ExampleWindow::ExampleWindow()
{
  set_title("DrawingArea");
  set_default_size(300, 200);
  set_child(m_area);
}

int main(int argc, char** argv)
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  return app-&gt;make_window_and_run&lt;ExampleWindow&gt;(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">myarea.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "myarea.h"
#include &lt;cairomm/context.h&gt;
#include &lt;giomm/resource.h&gt;
#include &lt;gdkmm/general.h&gt; // set_source_pixbuf()
#include &lt;glibmm/fileutils.h&gt;
#include &lt;iostream&gt;

MyArea::MyArea()
{
  try
  {
    // The fractal image has been created by the XaoS program.
    // http://xaos.sourceforge.net
    m_image = Gdk::Pixbuf::create_from_resource("/image/fractal_image.png");
  }
  catch(const Gio::ResourceError&amp; ex)
  {
    std::cerr &lt;&lt; "ResourceError: " &lt;&lt; ex.what() &lt;&lt; std::endl;
  }
  catch(const Gdk::PixbufError&amp; ex)
  {
    std::cerr &lt;&lt; "PixbufError: " &lt;&lt; ex.what() &lt;&lt; std::endl;
  }

  // Show at least a quarter of the image.
  if (m_image)
  {
    set_content_width(m_image-&gt;get_width()/2);
    set_content_height(m_image-&gt;get_height()/2);
  }

  // Set the draw function.
  set_draw_func(sigc::mem_fun(*this, &amp;MyArea::on_draw));
}

MyArea::~MyArea()
{
}

void MyArea::on_draw(const Cairo::RefPtr&lt;Cairo::Context&gt;&amp; cr, int width, int height)
{
  if (!m_image)
    return;

  // Draw the image in the middle of the drawing area, or (if the image is
  // larger than the drawing area) draw the middle part of the image.
  Gdk::Cairo::set_source_pixbuf(cr, m_image,
    (width - m_image-&gt;get_width())/2, (height - m_image-&gt;get_height())/2);
  cr-&gt;paint();
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">image.gresource.xml</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;gresources&gt;
  &lt;gresource prefix="/image"&gt;
    &lt;file&gt;fractal_image.png&lt;/file&gt;
  &lt;/gresource&gt;
&lt;/gresources&gt;
</pre></div>
</div>
</div>
<div class="division sect1">
<a name="sec-drawing-clock-example"><!--sec-drawing-clock-example--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">16.7. </span>Example Application: Creating a Clock with Cairo</span></h3></div>
<p class="para block block-first">
          Now that we've covered the basics of drawing with Cairo, let's try to
          put it all together and create a simple application that actually
          does something. The following example uses Cairo to create a custom
          <span class="classname" dir="ltr">Clock</span> widget. The clock has a second hand, a
          minute hand, and an hour hand, and updates itself every second.
      </p>
<div class=" block screenshot">
          <div class="graphic"><img src="figures/cairo_clock.png.en"></div>
      </div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/drawingarea/clock" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/drawingarea/clock">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">clock.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLE_CLOCK_H
#define GTKMM_EXAMPLE_CLOCK_H

#include &lt;gtkmm/drawingarea.h&gt;

class Clock : public Gtk::DrawingArea
{
public:
  Clock();
  virtual ~Clock();

protected:
  void on_draw(const Cairo::RefPtr&lt;Cairo::Context&gt;&amp; cr, int width, int height);

  bool on_timeout();

  double m_radius;
  double m_line_width;
};

#endif // GTKMM_EXAMPLE_CLOCK_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "clock.h"
#include &lt;gtkmm/application.h&gt;
#include &lt;gtkmm/window.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();

protected:
  Clock m_clock;
};

ExampleWindow::ExampleWindow()
{
  set_title("Cairomm Clock");
  set_child(m_clock);
}

int main(int argc, char** argv)
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  return app-&gt;make_window_and_run&lt;ExampleWindow&gt;(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">clock.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cairomm/context.h&gt;
#include &lt;glibmm/main.h&gt;
#include "clock.h"

Clock::Clock()
: m_radius(0.42), m_line_width(0.05)
{
  Glib::signal_timeout().connect( sigc::mem_fun(*this, &amp;Clock::on_timeout), 1000 );
  set_draw_func(sigc::mem_fun(*this, &amp;Clock::on_draw));
}

Clock::~Clock()
{
}

void Clock::on_draw(const Cairo::RefPtr&lt;Cairo::Context&gt;&amp; cr, int width, int height)
{
  // scale to unit square and translate (0, 0) to be (0.5, 0.5), i.e.
  // the center of the window
  cr-&gt;scale(width, height);
  cr-&gt;translate(0.5, 0.5);
  cr-&gt;set_line_width(m_line_width);

  cr-&gt;save();
  cr-&gt;set_source_rgba(0.337, 0.612, 0.117, 0.9);   // green
  cr-&gt;paint();
  cr-&gt;restore();
  cr-&gt;arc(0, 0, m_radius, 0, 2 * M_PI);
  cr-&gt;save();
  cr-&gt;set_source_rgba(1.0, 1.0, 1.0, 0.8);
  cr-&gt;fill_preserve();
  cr-&gt;restore();
  cr-&gt;stroke_preserve();
  cr-&gt;clip();

  //clock ticks
  for (int i = 0; i &lt; 12; i++)
  {
    double inset = 0.05;

    cr-&gt;save();
    cr-&gt;set_line_cap(Cairo::Context::LineCap::ROUND);

    if(i % 3 != 0)
    {
      inset *= 0.8;
      cr-&gt;set_line_width(0.03);
    }

    cr-&gt;move_to(
      (m_radius - inset) * cos (i * M_PI / 6),
      (m_radius - inset) * sin (i * M_PI / 6));
    cr-&gt;line_to (
      m_radius * cos (i * M_PI / 6),
      m_radius * sin (i * M_PI / 6));
    cr-&gt;stroke();
    cr-&gt;restore(); /* stack-pen-size */
  }

  // store the current time
  time_t rawtime;
  time(&amp;rawtime);
  struct tm * timeinfo = localtime (&amp;rawtime);

  // compute the angles of the indicators of our clock
  double minutes = timeinfo-&gt;tm_min * M_PI / 30;
  double hours = timeinfo-&gt;tm_hour * M_PI / 6;
  double seconds= timeinfo-&gt;tm_sec * M_PI / 30;

  cr-&gt;save();
  cr-&gt;set_line_cap(Cairo::Context::LineCap::ROUND);

  // draw the seconds hand
  cr-&gt;save();
  cr-&gt;set_line_width(m_line_width / 3);
  cr-&gt;set_source_rgba(0.7, 0.7, 0.7, 0.8); // gray
  cr-&gt;move_to(0, 0);
  cr-&gt;line_to(sin(seconds) * (m_radius * 0.9),
    -cos(seconds) * (m_radius * 0.9));
  cr-&gt;stroke();
  cr-&gt;restore();

  // draw the minutes hand
  cr-&gt;set_source_rgba(0.117, 0.337, 0.612, 0.9);   // blue
  cr-&gt;move_to(0, 0);
  cr-&gt;line_to(sin(minutes + seconds / 60) * (m_radius * 0.8),
    -cos(minutes + seconds / 60) * (m_radius * 0.8));
  cr-&gt;stroke();

  // draw the hours hand
  cr-&gt;set_source_rgba(0.337, 0.612, 0.117, 0.9);   // green
  cr-&gt;move_to(0, 0);
  cr-&gt;line_to(sin(hours + minutes / 12.0) * (m_radius * 0.5),
    -cos(hours + minutes / 12.0) * (m_radius * 0.5));
  cr-&gt;stroke();
  cr-&gt;restore();

  // draw a little dot in the middle
  cr-&gt;arc(0, 0, m_line_width / 3.0, 0, 2 * M_PI);
  cr-&gt;fill();
}

bool Clock::on_timeout()
{
  // force our program to redraw the entire clock.
  queue_draw();
  return true;
}
</pre></div>
<p class="para block">
          As before, almost all of the interesting stuff is done in the draw
          function <span class="methodname" dir="ltr">on_draw()</span>. Before we dig
          into the draw function, notice that the constructor for the
          <span class="classname" dir="ltr">Clock</span> widget connects a handler function
          <span class="methodname" dir="ltr">on_timeout()</span> to a timer with a timeout
          period of 1000 milliseconds (1 second). This means that
          <span class="methodname" dir="ltr">on_timeout()</span> will get called once per
          second. The sole responsibility of this function is to invalidate
          the window so that <span class="application">gtkmm</span> will be forced to redraw it.
      </p>
<p class="para block">
          Now let's take a look at the code that performs the actual drawing.
          The first section of <span class="methodname" dir="ltr">on_draw()</span> should be
          pretty familiar by now. This example again scales the coordinate system
          to be a unit square so that it's easier to draw the clock as a
          percentage of window size so that it will automatically scale when
          the window size is adjusted. Furthermore, the coordinate system is
          scaled over and down so that the (0, 0) coordinate is in the very
          center of the window.
      </p>
<p class="para block">
          The function <span class="methodname" dir="ltr">Cairo::Context::paint()</span> is used here
          to set the background color of the window. This function takes no
          arguments and fills the current surface (or the clipped portion of
          the surface) with the source color currently active. After setting
          the background color of the window, we draw a circle for the clock
          outline, fill it with white, and then stroke the outline in black.
          Notice that both of these actions use the
          <span class="methodname" dir="ltr">_preserve</span> variant to preserve the current path,
          and then this same path is clipped to make sure that our next lines
          don't go outside the outline of the clock.
      </p>
<p class="para block">
          After drawing the outline, we go around the clock and draw ticks for
          every hour, with a larger tick at 12, 3, 6, and 9. Now we're finally
          ready to implement the time-keeping functionality of the clock, which
          simply involves getting the current values for hours, minutes and
          seconds, and drawing the hands at the correct angles.
      </p>
</div>
</div>
<div class="division chapter">
<a name="chapter-draganddrop"><!--chapter-draganddrop--></a><div class="header"><h2 class="chapter title"><span class="title"><span class="label">17. </span>Drag and Drop</span></h2></div>
<p class="para block block-first">
<span class="classname" dir="ltr">Gtk::Widget</span> has several methods and signals which are
prefixed with "drag_". These are used for Drag and Drop.
</p>
<div class="autotoc"><ul>
<li>
<span class="label">17.1. </span><a class="xref" href="#sec-dnd-sources-destinations" title="Sources and Destinations">Sources and Destinations</a>
</li>
<li>
<span class="label">17.2. </span><a class="xref" href="#sec-dnd-methods" title="Methods">Methods</a>
</li>
<li>
<span class="label">17.3. </span><a class="xref" href="#sec-dnd-signals" title="Signals">Signals</a>
</li>
<li>
<span class="label">17.4. </span><a class="xref" href="#sec-dnd-example" title="Example">Example</a>
</li>
</ul></div>
<div class="division sect1">
<a name="sec-dnd-sources-destinations"><!--sec-dnd-sources-destinations--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">17.1. </span>Sources and Destinations</span></h3></div>
<p class="para block block-first">
Things are dragged from <span class="literal" dir="ltr">sources</span> to be dropped on
<span class="literal" dir="ltr">destinations</span>. Each source and destination has information
about the data formats that it can send or receive, provided by
<span class="classname" dir="ltr">Gdk::ContentFormats</span>. A drop destination will only
accept a dragged item if they both share a compatible format. Appropriate
signals will then be emitted, telling the signal handlers which format was used.
</p>
<p class="para block">
<span class="classname" dir="ltr">Gdk::ContentFormats</span> objects contain information about
available <span class="type" dir="ltr">GType</span>s and mime types (media types).
</p>
</div>
<div class="division sect1">
<a name="sec-dnd-methods"><!--sec-dnd-methods--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">17.2. </span>Methods</span></h3></div>
<p class="para block block-first">
<span class="classname" dir="ltr">Widget</span>s can be identified as sources or destinations
using these <span class="classname" dir="ltr">Gtk::Widget</span> methods:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">void drag_source_set(const Glib::RefPtr&lt;Gdk::ContentFormats&gt;&amp; targets,
      Gdk::ModifierType start_button_mask, Gdk::DragAction actions);</pre></div>
<div class="block list itemizedlist"><ul class="itemizedlist">
<li class="li-first">
    <span class="para">
        <span class="literal" dir="ltr">targets</span> is a <span class="classname" dir="ltr">Gdk::ContentFormats</span> object.
    </span>
</li>
<li>
    <span class="para">
        <span class="literal" dir="ltr">start_button_mask</span> is an ORed combination of values,
        which specify which modifier key or mouse button must be pressed to
        start the drag.
    </span>
</li>
<li>
    <span class="para">
        <span class="literal" dir="ltr">actions</span> is an ORed combination of values, which
        specify which Drag and Drop operations will be possible from this
        source - for instance, copy, move, or link. The user can choose between
        the actions by using modifier keys, such as <span class="keycap">Shift</span> to
        change from <span class="literal" dir="ltr">copy</span> to <span class="literal" dir="ltr">move</span>, and
        this will be shown by a different cursor.
    </span>
</li>
</ul></div>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">void drag_dest_set(const Glib::RefPtr&lt;Gdk::ContentFormats&gt;&amp; targets,
    Gtk::DestDefaults flags, Gdk::DragAction actions);</pre></div>
<div class="block list itemizedlist"><ul class="itemizedlist">
<li class="li-first">
    <span class="para">
        <span class="literal" dir="ltr">flags</span> is an ORed combination of values which
        indicates how the widget will respond visually to Drag and Drop items.
    </span>
</li>
<li>
    <span class="para">
        <span class="literal" dir="ltr">actions</span> indicates the Drag and Drop actions which
        this destination can receive - see the description above.
    </span>
</li>
</ul></div>
<p class="para block">There are several methods to add source formats and destination formats.
Examples:
<div class="block list itemizedlist"><ul class="itemizedlist">
<li class="li-first"><span class="para"><span class="methodname" dir="ltr">drag_source_add_text_targets()</span></span></li>
<li><span class="para"><span class="methodname" dir="ltr">drag_source_add_image_targets()</span></span></li>
<li><span class="para"><span class="methodname" dir="ltr">drag_dest_add_text_targets()</span></span></li>
<li><span class="para"><span class="methodname" dir="ltr">drag_dest_add_image_targets()</span></span></li>
</ul></div>
</p>
</div>
<div class="division sect1">
<a name="sec-dnd-signals"><!--sec-dnd-signals--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">17.3. </span>Signals</span></h3></div>
<p class="para block block-first">
When a drop destination has accepted a dragged item, certain signals will be
emitted, depending on what action has been selected. For instance, the user
might have held down the <span class="keycap">Shift</span> key to specify a
<span class="literal" dir="ltr">move</span> rather than a <span class="literal" dir="ltr">copy</span>. Remember that
the user can only select the actions which you have specified in your calls to
<span class="methodname" dir="ltr">drag_dest_set()</span> and
<span class="methodname" dir="ltr">drag_source_set()</span>.
</p>
<div class="autotoc"><ul>
<li>
<span class="label">17.3.1. </span><a class="xref" href="#sec-dnd-signals-copy" title="Copy">Copy</a>
</li>
<li>
<span class="label">17.3.2. </span><a class="xref" href="#dnd-signal-move" title="Move">Move</a>
</li>
</ul></div>
<div class="division sect2">
<a name="sec-dnd-signals-copy"><!--sec-dnd-signals-copy--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">17.3.1. </span>Copy</span></h4></div>
<p class="para block block-first">
The source widget will emit these signals, in this order:
<div class="block list itemizedlist"><ul class="itemizedlist">
<li class="li-first"><span class="para"><span class="literal" dir="ltr">drag_begin</span>: Provides a <span class="classname" dir="ltr">Gdk::Drag</span>.</span></li>
<li><span class="para"><span class="literal" dir="ltr">drag_data_get</span>: Provides a <span class="classname" dir="ltr">Gdk::Drag</span>,
  and a <span class="classname" dir="ltr">Gtk::SelectionData</span> object, in which you should put the requested data.</span></li>
<li><span class="para"><span class="literal" dir="ltr">drag_end</span>: Provides a <span class="classname" dir="ltr">Gdk::Drag</span>.</span></li>
</ul></div>
</p>
<p class="para block">
The destination widget will emit these signals, in this order:
<div class="block list itemizedlist"><ul class="itemizedlist">
<li class="li-first"><span class="para"><span class="literal" dir="ltr">drag_motion</span>: Provides a <span class="classname" dir="ltr">Gdk::Drop</span> and coordinates.
  You can call the <span class="methodname" dir="ltr">status()</span> method of the <span class="classname" dir="ltr">Gdk::Drop</span>
  to indicate which action will be accepted.</span></li>
<li><span class="para"><span class="literal" dir="ltr">drag_drop</span>: Provides a <span class="classname" dir="ltr">Gdk::Drop</span> and coordinates.
  You can call <span class="methodname" dir="ltr">drag_get_data()</span>, which triggers the
  <span class="literal" dir="ltr">drag_data_get</span> signal in the source widget, and then the
  <span class="literal" dir="ltr">drag_data_received</span> signal in the destination widget.</span></li>
<li>
    <span class="para">
        <span class="literal" dir="ltr">drag_data_received</span>: Provides a <span class="classname" dir="ltr">Gdk::Drop</span>,
        and a <span class="methodname" dir="ltr">Gtk::SelectionData</span> object which contains the
        dropped data. You should  call the <span class="methodname" dir="ltr">finish()</span> or
        <span class="methodname" dir="ltr">failed()</span> method of the <span class="classname" dir="ltr">Gdk::Drop</span>
        to indicate whether the operation was successful.
    </span>
</li>
</ul></div>
</p>
</div>
<div class="division sect2">
<a name="dnd-signal-move"><!--dnd-signal-move--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">17.3.2. </span>Move</span></h4></div>
<p class="para block block-first">During a <span class="literal" dir="ltr">move</span>, the source widget will also emit this signal:
<div class="block list itemizedlist"><ul class="itemizedlist"><li class="li-first"><span class="para"><span class="literal" dir="ltr">drag_data_delete</span>: Gives the source the opportunity to delete the original data if that's appropriate.</span></li></ul></div>
</p>
</div>
</div>
<div class="division sect1">
<a name="sec-dnd-example"><!--sec-dnd-example--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">17.4. </span>Example</span></h3></div>
<p class="para block block-first">Here is a very simple example, demonstrating a drag and drop <span class="literal" dir="ltr">Copy</span> operation:</p>
<div class=" block figure block-indent">
<a name="figure-drag-and-drop"><!--figure-drag-and-drop--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 17-1</span> </span>Drag and Drop</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/drag_and_drop.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/drag_and_drop" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/drag_and_drop">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">dndwindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLE_DNDWINDOW_H
#define GTKMM_EXAMPLE_DNDWINDOW_H

#include &lt;gdkmm/drop.h&gt;
#include &lt;gtkmm/box.h&gt;
#include &lt;gtkmm/label.h&gt;
#include &lt;gtkmm/window.h&gt;
#include &lt;gtkmm/button.h&gt;

class DnDWindow : public Gtk::Window
{

public:
  DnDWindow();
  virtual ~DnDWindow();

protected:
  //Signal handlers:
  Glib::RefPtr&lt;Gdk::ContentProvider&gt; on_label_drag_prepare_data(double x, double y);
  bool on_button_drop_drop_data(const Glib::ValueBase&amp; value, double x, double y);

  //Member widgets:
  Gtk::Box m_HBox;
  Gtk::Label m_Label_Drag;
  Gtk::Button m_Button_Drop;
};

#endif // GTKMM_EXAMPLE_DNDWINDOW_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "dndwindow.h"
#include &lt;gtkmm/application.h&gt;

int main(int argc, char* argv[])
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  //Shows the window and returns when it is closed.
  return app-&gt;make_window_and_run&lt;DnDWindow&gt;(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">dndwindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "dndwindow.h"
#include &lt;gdkmm/contentprovider.h&gt;
#include &lt;gtkmm/dragsource.h&gt;
#include &lt;gtkmm/droptarget.h&gt;
#include &lt;iostream&gt;

DnDWindow::DnDWindow()
: m_Label_Drag("Drag Here\n"),
  m_Button_Drop("Drop here\n")
{
  set_title("DnD example");

  set_child(m_HBox);

  //Drag site:

  //Make m_Label_Drag a DnD drag source:
  auto source = Gtk::DragSource::create();
  source-&gt;set_actions(Gdk::DragAction::COPY);
  source-&gt;signal_prepare().connect(
    sigc::mem_fun(*this, &amp;DnDWindow::on_label_drag_prepare_data), false);
  m_Label_Drag.add_controller(source);

  m_HBox.append(m_Label_Drag);
  m_Label_Drag.set_expand(true);

  //Drop site:

  //Make m_Button_Drop a DnD drop destination:
  const GType ustring_type = Glib::Value&lt;Glib::ustring&gt;::value_type();
  auto target = Gtk::DropTarget::create(ustring_type, Gdk::DragAction::COPY);
  target-&gt;signal_drop().connect(
    sigc::mem_fun(*this, &amp;DnDWindow::on_button_drop_drop_data), false);
  m_Button_Drop.add_controller(target);

  m_HBox.append(m_Button_Drop);
  m_Button_Drop.set_expand(true);
}

DnDWindow::~DnDWindow()
{
}

// In this simple example where just a small amount of data is copied,
// it would be reasonable to store the ContentProvider in the DragSource.
// Then this signal handler would be unnecessary.
Glib::RefPtr&lt;Gdk::ContentProvider&gt; DnDWindow::on_label_drag_prepare_data(double, double)
{
  Glib::Value&lt;Glib::ustring&gt; ustring_value;
  ustring_value.init(ustring_value.value_type());
  ustring_value.set("I'm Data!");
  return Gdk::ContentProvider::create(ustring_value);
}

bool DnDWindow::on_button_drop_drop_data(const Glib::ValueBase&amp; value, double, double)
{
  if (G_VALUE_HOLDS(value.gobj(), Glib::Value&lt;Glib::ustring&gt;::value_type()))
  {
    // We got the value type that we expected.
    Glib::Value&lt;Glib::ustring&gt; ustring_value;
    ustring_value.init(value.gobj());
    const Glib::ustring dropped_string = ustring_value.get();

    std::cout &lt;&lt; "Received \"" &lt;&lt; dropped_string &lt;&lt; "\" in button " &lt;&lt; std::endl;
    return true;
  }
  else
  {
    std::cout &lt;&lt; "Received unexpected data type \""
      &lt;&lt; G_VALUE_TYPE_NAME(value.gobj()) &lt;&lt; "\" in button " &lt;&lt; std::endl;
    return false;
  }
}
</pre></div>
<p class="para block">
There is a more complex example in examples/others/dnd.
</p>
</div>
</div>
<div class="division chapter">
<a name="chapter-clipboard"><!--chapter-clipboard--></a><div class="header"><h2 class="chapter title"><span class="title"><span class="label">18. </span>The Clipboard</span></h2></div>
<p class="para block block-first">Simple text copy-paste functionality is provided for free by widgets such as
<span class="classname" dir="ltr">Gtk::Entry</span> and <span class="classname" dir="ltr">Gtk::TextView</span>,
but you might need special code to deal with your own data formats. For instance,
a drawing program would need special code to allow copy and paste within a view,
or between documents.</p>
<p class="para block">
You can get a clipboard instance with <span class="methodname" dir="ltr">Gtk::Widget::get_clipboard()</span>
or <span class="methodname" dir="ltr">Gdk::Display::get_clipboard()</span>.
</p>
<p class="para block">
Your application doesn't need to wait for clipboard operations, particularly
between the time when the user chooses Copy and then later chooses Paste. Many
<span class="classname" dir="ltr">Gdk::Clipboard</span> methods take <span class="classname" dir="ltr">sigc::slot</span>s
which specify callback methods. When <span class="classname" dir="ltr">Gdk::Clipboard</span> is ready,
it will call these methods, providing the requested data.
</p>
<p class="para block"><a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGdk_1_1Clipboard.html" title="http://developer.gnome.org/gtkmm/unstable/classGdk_1_1Clipboard.html">Reference</a></p>
<div class="autotoc"><ul>
<li>
<span class="label">18.1. </span><a class="xref" href="#sec-clipboard-formats" title="Formats">Formats</a>
</li>
<li>
<span class="label">18.2. </span><a class="xref" href="#sec-clipboard-copy" title="Copy">Copy</a>
</li>
<li>
<span class="label">18.3. </span><a class="xref" href="#sec-clipboard-paste" title="Paste">Paste</a>
</li>
<li>
<span class="label">18.4. </span><a class="xref" href="#sec-clipboard-examples" title="Examples">Examples</a>
</li>
</ul></div>
<div class="division sect1">
<a name="sec-clipboard-formats"><!--sec-clipboard-formats--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">18.1. </span>Formats</span></h3></div>
<p class="para block block-first">
Different applications contain different types of data, and they might make that data available in
a variety of formats. <span class="application">gtkmm</span> calls these data types <span class="literal" dir="ltr">format</span>s.</p>
<p class="para block">
For instance, <span class="application">gedit</span> can supply and receive the <span class="literal" dir="ltr">text/plain</span> mime type,
so you can paste data into <span class="application">gedit</span> from any application that supplies that format.
Or two different image editing applications might supply and receive a variety of image formats.
As long as one application can receive one of the formats that the other supplies
then you will be able to copy data from one to the other.
</p>
<p class="para block">
Clipboard data can be in a variety of binary formats. This chapter, and the examples,
assume that the data is 8-bit text. This would allow us to use an XML format
for the clipboard data. However this would probably not be appropriate for
binary data such as images.
</p>
<p class="para block">The <a class="link" href="#chapter-draganddrop" title="Drag and Drop">Drag and Drop</a> API uses the same mechanism.
You should probably use the same data formats for both Clipboard and Drag and Drop operations.</p>
</div>
<div class="division sect1">
<a name="sec-clipboard-copy"><!--sec-clipboard-copy--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">18.2. </span>Copy</span></h3></div>
<p class="para block block-first">
When the user asks to copy some data, you should copy the data to the
<span class="classname" dir="ltr">Clipboard</span>. For instance,
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">void ExampleWindow::on_button_copy()
{
  get_clipboard()-&gt;set_text("example_custom_target");
}</pre></div>
</div>
<div class="division sect1">
<a name="sec-clipboard-paste"><!--sec-clipboard-paste--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">18.3. </span>Paste</span></h3></div>
<p class="para block block-first">
When the user asks to paste data from the <span class="classname" dir="ltr">Clipboard</span>, you
should request a specific format and provide a callback method which will be
called with the actual data. For instance:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">void ExampleWindow::on_button_paste()
{
  get_clipboard()-&gt;read_text_async(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_clipboard_received));
}</pre></div>
<p class="para block">Here is an example callback method:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">void ExampleWindow::on_clipboard_received(Glib::RefPtr&lt;Gio::AsyncResult&gt;&amp; result)
{
  auto text = get_clipboard()-&gt;read_text_finish(result);
  //Do something with the pasted data.
}</pre></div>
<div class="autotoc"><ul><li>
<span class="label">18.3.1. </span><a class="xref" href="#sec-clipboard-discovering-formats" title="Discovering the available formats">Discovering the available formats</a>
</li></ul></div>
<div class="division sect2">
<a name="sec-clipboard-discovering-formats"><!--sec-clipboard-discovering-formats--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">18.3.1. </span>Discovering the available formats</span></h4></div>
<p class="para block block-first">
To find out what formats are currently available on the <span class="classname" dir="ltr">Clipboard</span>
for pasting, call the <span class="methodname" dir="ltr">get_formats()</span> method. Then call a
<span class="classname" dir="ltr">Gdk::ContentFormats</span> method to find out if a format that
your application supports is available.
</p>
</div>
</div>
<div class="division sect1">
<a name="sec-clipboard-examples"><!--sec-clipboard-examples--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">18.4. </span>Examples</span></h3></div>
<div class="autotoc"><ul>
<li>
<span class="label">18.4.1. </span><a class="xref" href="#sec-clipboard-example-simple" title="Simple">Simple</a>
</li>
<li>
<span class="label">18.4.2. </span><a class="xref" href="#sec-clipboard-example-ideal" title="Ideal">Ideal</a>
</li>
</ul></div>
<div class="division sect2">
<a name="sec-clipboard-example-simple"><!--sec-clipboard-example-simple--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">18.4.1. </span>Simple</span></h4></div>
<p class="para block block-first">
This example allows copy and pasting of application-specific data, using the
standard text format. Although this is simple, it's not ideal because it does
not identify the <span class="classname" dir="ltr">Clipboard</span> data as being of a particular
type.
</p>
<div class=" block figure block-indent">
<a name="figure-clipboard-simple"><!--figure-clipboard-simple--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 18-1</span> </span>Clipboard - Simple</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/clipboard_simple.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/clipboard/simple/" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/clipboard/simple/">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_button_copy();
  void on_button_paste();

  void on_clipboard_text_received(Glib::RefPtr&lt;Gio::AsyncResult&gt;&amp; result);

  Glib::ustring m_strData;

  //Child widgets:
  Gtk::Box m_VBox;

  Gtk::Label m_Label;

  Gtk::Grid m_Grid;
  Gtk::ToggleButton m_ButtonA1, m_ButtonA2, m_ButtonB1, m_ButtonB2;

  Gtk::Box m_ButtonBox;
  Gtk::Button m_Button_Copy, m_Button_Paste;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;gtkmm/application.h&gt;

int main(int argc, char *argv[])
{
  // Gio::Application::Flags::NON_UNIQUE because it shall be possible to run
  // several instances of this application simultaneously.
  auto app = Gtk::Application::create(
    "org.gtkmm.example", Gio::Application::Flags::NON_UNIQUE);

  //Shows the window and returns when it is closed.
  return app-&gt;make_window_and_run&lt;ExampleWindow&gt;(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;iostream&gt;

ExampleWindow::ExampleWindow()
: m_VBox(Gtk::Orientation::VERTICAL),
  m_Label("Select cells in the grid, click Copy, then open a second "
        "instance of this example to try pasting the copied data."),
  m_ButtonA1("A1"), m_ButtonA2("A2"), m_ButtonB1("B1"), m_ButtonB2("B2"),
  m_Button_Copy("_Copy", /* mnemonic= */ true), m_Button_Paste("_Paste", true)
{
  set_title("Gtk::Clipboard example");

  m_VBox.set_margin(12);
  set_child(m_VBox);

  m_VBox.append(m_Label);

  //Fill Grid:
  m_VBox.append(m_Grid);
  m_Grid.set_expand(true);
  m_Grid.set_row_homogeneous(true);
  m_Grid.set_column_homogeneous(true);
  m_Grid.attach(m_ButtonA1, 0, 0);
  m_Grid.attach(m_ButtonA2, 1, 0);
  m_Grid.attach(m_ButtonB1, 0, 1);
  m_Grid.attach(m_ButtonB2, 1, 1);

  //Add ButtonBox to bottom:
  m_VBox.append(m_ButtonBox);
  m_VBox.set_spacing(6);

  //Fill ButtonBox:
  m_ButtonBox.append(m_Button_Copy);
  m_Button_Copy.set_hexpand(true);
  m_Button_Copy.set_halign(Gtk::Align::END);
  m_Button_Copy.signal_clicked().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_copy) );
  m_ButtonBox.append(m_Button_Paste);
  m_Button_Paste.signal_clicked().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_paste) );
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_button_copy()
{
  //Build a string representation of the stuff to be copied:
  //Ideally you would use XML, with an XML parser here:
  m_strData = m_ButtonA1.get_active() ? "1" : "0";
  m_strData += m_ButtonA2.get_active() ? "1" : "0";
  m_strData += m_ButtonB1.get_active() ? "1" : "0";
  m_strData += m_ButtonB2.get_active() ? "1" : "0";

  // Gdk::Clipboard::set_text() does not take a copy of the text.
  // The text can only be pasted (in this program or in some other program)
  // for as long as it exists.
  get_clipboard()-&gt;set_text(m_strData);
}

void ExampleWindow::on_button_paste()
{
  //Tell the clipboard to call our method when it is ready:
  get_clipboard()-&gt;read_text_async(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_clipboard_text_received));
}

void ExampleWindow::on_clipboard_text_received(Glib::RefPtr&lt;Gio::AsyncResult&gt;&amp; result)
{
  Glib::ustring text;
  try
  {
    text = get_clipboard()-&gt;read_text_finish(result);
  }
  catch (const Glib::Error&amp; err)
  {
    // Print an error about why pasting failed.
    // Usually you probably want to ignore such failures,
    // but for demonstration purposes, we show the error.
    std::cout &lt;&lt; "Pasting failed: " &lt;&lt; err.what() &lt;&lt; std::endl;
  }

  //See comment in on_button_copy() about this silly clipboard format.
  if(text.size() &gt;= 4)
  {
    m_ButtonA1.set_active( text[0] == '1' );
    m_ButtonA2.set_active( text[1] == '1' );
    m_ButtonB1.set_active( text[2] == '1' );
    m_ButtonB2.set_active( text[3] == '1' );
  }
}
</pre></div>
</div>
<div class="division sect2">
<a name="sec-clipboard-example-ideal"><!--sec-clipboard-example-ideal--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">18.4.2. </span>Ideal</span></h4></div>
<p class="para block block-first">This is like the simple example, but it
<div class="block list orderedlist"><ol class="orderedlist">
<li class="li-first"><p class="simpara block block-first">Defines a custom clipboard target, though the format is still text.</p></li>
<li><p class="simpara block block-first">It uses the <span class="methodname" dir="ltr">Gdk::ContentFormats::signal_changed()</span>
  signal and disables the Paste button if it can't use anything on the clipboard.</p></li>
</ol></div>
</p>
<div class=" block figure block-indent">
<a name="figure-clipboard-ideal"><!--figure-clipboard-ideal--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 18-2</span> </span>Clipboard - Ideal</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/clipboard_ideal.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/clipboard/ideal/" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/clipboard/ideal/">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_button_copy();
  void on_button_paste();

  void on_clipboard_content_changed();

  void on_clipboard_received(Glib::RefPtr&lt;Gio::AsyncResult&gt;&amp; result);
  void on_clipboard_received_status(Glib::RefPtr&lt;Gio::AsyncResult&gt;&amp; result);

  void update_paste_status(); //Disable the paste button if there is nothing to paste.

  Glib::ustring m_strData;

  //Child widgets:
  Gtk::Box m_VBox;

  Gtk::Label m_Label;

  Gtk::Grid m_Grid;
  Gtk::ToggleButton m_ButtonA1, m_ButtonA2, m_ButtonB1, m_ButtonB2;

  Gtk::Box m_ButtonBox;
  Gtk::Button m_Button_Copy, m_Button_Paste;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;gtkmm/application.h&gt;

int main(int argc, char *argv[])
{
  // Gio::Application::Flags::NON_UNIQUE because it shall be possible to run
  // several instances of this application simultaneously.
  auto app = Gtk::Application::create(
    "org.gtkmm.example", Gio::Application::Flags::NON_UNIQUE);

  //Shows the window and returns when it is closed.
  return app-&gt;make_window_and_run&lt;ExampleWindow&gt;(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;iostream&gt;
#include &lt;string&gt;

namespace
{

const char example_format_custom[] = "gtkmmclipboardexample";

} // anonymous namespace


ExampleWindow::ExampleWindow()
: m_VBox(Gtk::Orientation::VERTICAL),
  m_Label("Select cells in the grid, click Copy, then open a second instance "
          "of this example to try pasting the copied data.\nOr try pasting the "
          "text representation into gedit."),
  m_ButtonA1("A1"), m_ButtonA2("A2"), m_ButtonB1("B1"), m_ButtonB2("B2"),
  m_Button_Copy("_Copy", /* mnemonic= */ true), m_Button_Paste("_Paste", true)
{
  set_title("Gtk::Clipboard example");

  m_VBox.set_margin(12);
  set_child(m_VBox);

  m_VBox.append(m_Label);

  //Fill Grid:
  m_VBox.append(m_Grid);
  m_Grid.set_expand(true);
  m_Grid.set_row_homogeneous(true);
  m_Grid.set_column_homogeneous(true);
  m_Grid.attach(m_ButtonA1, 0, 0);
  m_Grid.attach(m_ButtonA2, 1, 0);
  m_Grid.attach(m_ButtonB1, 0, 1);
  m_Grid.attach(m_ButtonB2, 1, 1);

  //Add ButtonBox to bottom:
  m_VBox.append(m_ButtonBox);
  m_VBox.set_spacing(6);

  //Fill ButtonBox:
  m_ButtonBox.append(m_Button_Copy);
  m_Button_Copy.set_hexpand(true);
  m_Button_Copy.set_halign(Gtk::Align::END);
  m_Button_Copy.signal_clicked().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_copy) );
  m_ButtonBox.append(m_Button_Paste);
  m_Button_Paste.signal_clicked().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_paste) );

  //Connect a signal handler that will be called when the contents of
  //the clipboard change.
  get_clipboard()-&gt;signal_changed().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_clipboard_content_changed));

  update_paste_status();
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_button_copy()
{
  //Build a string representation of the stuff to be copied:
  //Ideally you would use XML, with an XML parser here:
  m_strData = example_format_custom;
  m_strData += m_ButtonA1.get_active() ? " A1" : "";
  m_strData += m_ButtonA2.get_active() ? " A2" : "";
  m_strData += m_ButtonB1.get_active() ? " B1" : "";
  m_strData += m_ButtonB2.get_active() ? " B2" : "";

  // Gdk::Clipboard::set_text() does not take a copy of the text.
  // The text can only be pasted (in this program or in some other program)
  // for as long as it exists.
  get_clipboard()-&gt;set_text(m_strData);
}

void ExampleWindow::on_button_paste()
{
  //Tell the clipboard to call our method when it is ready:
  get_clipboard()-&gt;read_text_async(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_clipboard_received));
}

void ExampleWindow::on_clipboard_content_changed()
{
  update_paste_status();
}

void ExampleWindow::on_clipboard_received(Glib::RefPtr&lt;Gio::AsyncResult&gt;&amp; result)
{
  Glib::ustring text;
  try
  {
    text = get_clipboard()-&gt;read_text_finish(result);
  }
  catch (const Glib::Error&amp; err)
  {
    // Print an error about why pasting failed.
    // Usually you probably want to ignore such failures,
    // but for demonstration purposes, we show the error.
    std::cout &lt;&lt; "Pasting failed: " &lt;&lt; err.what() &lt;&lt; std::endl;
  }

  if (text.find(example_format_custom) == 0)
  {
    // It's the expected format.
    m_ButtonA1.set_active(text.find("A1") != std::string::npos);
    m_ButtonA2.set_active(text.find("A2") != std::string::npos);
    m_ButtonB1.set_active(text.find("B1") != std::string::npos);
    m_ButtonB2.set_active(text.find("B2") != std::string::npos);
  }
  else
  {
    // Unexpected format. Disable the Paste button.
    std::cout &lt;&lt; "Unexpected pasted text: \"" &lt;&lt; text &lt;&lt; "\"" &lt;&lt; std::endl;
    m_Button_Paste.set_sensitive(false);
  }
}

void ExampleWindow::update_paste_status()
{
  // Disable the paste button if there is nothing to paste.
  get_clipboard()-&gt;read_text_async(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_clipboard_received_status));
}

void ExampleWindow::on_clipboard_received_status(Glib::RefPtr&lt;Gio::AsyncResult&gt;&amp; result)
{
  Glib::ustring text;
  try
  {
    text = get_clipboard()-&gt;read_text_finish(result);
  }
  catch (const Glib::Error&amp;)
  {
  }

  const bool bPasteIsPossible = text.find(example_format_custom) == 0;

  // Enable/Disable the Paste button appropriately:
  m_Button_Paste.set_sensitive(bPasteIsPossible);
}
</pre></div>
</div>
</div>
</div>
<div class="division chapter">
<a name="chapter-printing"><!--chapter-printing--></a><div class="header"><h2 class="chapter title"><span class="title"><span class="label">19. </span>Printing</span></h2></div>
<p class="para block block-first">
At the application development level, <span class="application">gtkmm</span>'s printing API
provides dialogs that are consistent across applications and allows use of Cairo's common drawing API, with Pango-driven text rendering. In the implementation of this common API, platform-specific backends and printer-specific drivers are used.
</p>
<div class="autotoc"><ul>
<li>
<span class="label">19.1. </span><a class="xref" href="#sec-printoperation" title="PrintOperation">PrintOperation</a>
</li>
<li>
<span class="label">19.2. </span><a class="xref" href="#sec-page-setup" title="Page setup">Page setup</a>
</li>
<li>
<span class="label">19.3. </span><a class="xref" href="#sec-printing-rendering-text" title="Rendering text">Rendering text</a>
</li>
<li>
<span class="label">19.4. </span><a class="xref" href="#sec-async-printing-ops" title="Asynchronous operations">Asynchronous operations</a>
</li>
<li>
<span class="label">19.5. </span><a class="xref" href="#sec-printing-export-to-pdf" title="Export to PDF">Export to PDF</a>
</li>
<li>
<span class="label">19.6. </span><a class="xref" href="#sec-extending-print-dialog" title="Extending the print dialog">Extending the print dialog</a>
</li>
<li>
<span class="label">19.7. </span><a class="xref" href="#sec-printing-preview" title="Preview">Preview</a>
</li>
<li>
<span class="label">19.8. </span><a class="xref" href="#sec-printing-example" title="Example">Example</a>
</li>
</ul></div>
<div class="division sect1">
<a name="sec-printoperation"><!--sec-printoperation--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">19.1. </span>PrintOperation</span></h3></div>
<p class="para block block-first">
The primary object is <span class="classname" dir="ltr">Gtk::PrintOperation</span>, allocated
for each print operation. To handle page drawing connect to its signals,
or inherit from it and override the default virtual signal handlers.
<span class="classname" dir="ltr">PrintOperation</span> automatically handles all the settings
affecting the print loop.
</p>
<div class="autotoc"><ul><li>
<span class="label">19.1.1. </span><a class="xref" href="#sec-printoperation-signals" title="Signals">Signals</a>
</li></ul></div>
<div class="division sect2">
<a name="sec-printoperation-signals"><!--sec-printoperation-signals--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">19.1.1. </span>Signals</span></h4></div>
<p class="para block block-first">
The <span class="methodname" dir="ltr">PrintOperation::run()</span> method starts the print loop,
during which various signals are emitted:

<div class="block list itemizedlist"><ul class="itemizedlist">
<li class="li-first">
    <span class="para">
      <span class="literal" dir="ltr">begin_print</span>:
      You must handle this signal, because this is where you
      create and set up a <span class="classname" dir="ltr">Pango::Layout</span> using the
      provided <span class="classname" dir="ltr">Gtk::PrintContext</span>, and break up your
      printing output into pages.
    </span>
  </li>
<li>
    <span class="para">
      <span class="literal" dir="ltr">paginate</span>: Pagination is potentially slow so if you
      need to monitor it you can call the
      <span class="methodname" dir="ltr">PrintOperation::set_show_progress()</span> method and
      handle this signal.
    </span>
  </li>
<li>
    <span class="para">
      For each page that needs to be rendered, the following signals
      are emitted:
      <div class="block list itemizedlist"><ul class="itemizedlist">
<li class="li-first">
          <span class="para">
            <span class="literal" dir="ltr">request_page_setup</span>: Provides a
            <span class="classname" dir="ltr">PrintContext</span>, page number and
            <span class="classname" dir="ltr">Gtk::PageSetup</span>. Handle this signal if you
            need to modify page setup on a per-page basis.
          </span>
        </li>
<li>
          <span class="para">
            <span class="literal" dir="ltr">draw_page</span>: You must handle this signal, which provides a
            <span class="classname" dir="ltr">PrintContext</span> and a page number.
            The <span class="classname" dir="ltr">PrintContext</span> should be used
            to create a <span class="classname" dir="ltr">Cairo::Context</span> into which
            the provided page should be drawn. To render text, iterate over
            the <span class="classname" dir="ltr">Pango::Layout</span> you created in the
            <span class="literal" dir="ltr">begin_print</span> handler.
          </span>
        </li>
</ul></div>
    </span>
  </li>
<li>
    <span class="para">
      <span class="literal" dir="ltr">end_print</span>: A handler for it is a safe place to free
      any resources related to a <span class="classname" dir="ltr">PrintOperation</span>.
      If you have your custom class that inherits from
      <span class="classname" dir="ltr">PrintOperation</span>, it is naturally simpler to do it
      in the destructor.
    </span>
  </li>
<li>
    <span class="para">
      <span class="literal" dir="ltr">done</span>: This signal is emitted when printing is finished, meaning when the
      print data is spooled. Note that the provided
      <span class="literal" dir="ltr">Gtk::PrintOperationResult</span> may indicate that
      an error occurred. In any case you probably want to notify the user
      about the final status.
    </span>
  </li>
<li>
    <span class="para">
      <span class="literal" dir="ltr">status_changed</span>: Emitted whenever a print job's
      status changes, until it is finished. Call the
      <span class="methodname" dir="ltr">PrintOperation::set_track_print_status()</span> method to
      monitor the job status after spooling. To see the status, use
      <span class="methodname" dir="ltr">get_status()</span> or
      <span class="methodname" dir="ltr">get_status_string()</span>.
    </span>
  </li>
</ul></div>

</p>
<p class="para block">
<a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1PrintOperation.html" title="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1PrintOperation.html">Reference</a>
</p>
</div>
</div>
<div class="division sect1">
<a name="sec-page-setup"><!--sec-page-setup--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">19.2. </span>Page setup</span></h3></div>
<p class="para block block-first">
The <span class="classname" dir="ltr">PrintOperation</span> class has a method called
<span class="methodname" dir="ltr">set_default_page_setup()</span> which selects the default
paper size, orientation and margins. To show a page setup dialog from your
application, use the <span class="methodname" dir="ltr">Gtk::run_page_setup_dialog()</span> method,
which returns a <span class="classname" dir="ltr">Gtk::PageSetup</span> object with the chosen
settings. Use this object to update a <span class="classname" dir="ltr">PrintOperation</span>
and to access the selected <span class="classname" dir="ltr">Gtk::PaperSize</span>,
<span class="literal" dir="ltr">Gtk::PageOrientation</span> and printer-specific margins.
</p>
<p class="para block">You should save the chosen <span class="classname" dir="ltr">Gtk::PageSetup</span>
so you can use it again if the page setup dialog is shown again.</p>
<p class="para block">For instance,</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">// Within a class that inherits from Gtk::Window and keeps m_refPageSetup
// and m_refSettings as members...
auto new_page_setup = Gtk::run_page_setup_dialog(*this, m_refPageSetup, m_refSettings);
m_refPageSetup = new_page_setup;
</pre></div>
<p class="para block">
<a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1PageSetup.html" title="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1PageSetup.html">Reference</a>
</p>
<p class="para block">
The Cairo coordinate system, in the <span class="literal" dir="ltr">draw_page</span> handler,
is automatically rotated to the current page orientation. It is normally
within the printer margins, but you can change that via the
<span class="methodname" dir="ltr">PrintOperation::set_use_full_page()</span>
method. The default measurement unit is device pixels. To select other units,
use the <span class="methodname" dir="ltr">PrintOperation::set_unit()</span> method.
</p>
</div>
<div class="division sect1">
<a name="sec-printing-rendering-text"><!--sec-printing-rendering-text--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">19.3. </span>Rendering text</span></h3></div>
<p class="para block block-first">
Text rendering is done using Pango.
The <span class="classname" dir="ltr">Pango::Layout</span> object for printing should be created by calling
the <span class="methodname" dir="ltr">PrintContext::create_pango_layout()</span> method.
The <span class="classname" dir="ltr">PrintContext</span> object also provides the page metrics,
via <span class="methodname" dir="ltr">get_width()</span> and <span class="methodname" dir="ltr">get_height()</span>.
The number of pages can be set with
<span class="methodname" dir="ltr">PrintOperation::set_n_pages()</span>. To actually render the
 Pango text in <span class="literal" dir="ltr">on_draw_page</span>, get a
<span class="classname" dir="ltr">Cairo::Context</span> with
<span class="methodname" dir="ltr">PrintContext::get_cairo_context()</span> and show the
<span class="classname" dir="ltr">Pango::LayoutLine</span>s that appear within the requested
page number.
</p>
<p class="para block">
See <a class="link" href="#sec-printing-example-simple" title="Simple">an example</a>
of exactly how this can be done.
</p>
</div>
<div class="division sect1">
<a name="sec-async-printing-ops"><!--sec-async-printing-ops--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">19.4. </span>Asynchronous operations</span></h3></div>
<p class="para block block-first">
By default, <span class="methodname" dir="ltr">PrintOperation::run()</span> returns when a print
operation is completed. If you need to run a non-blocking print operation,
call <span class="methodname" dir="ltr">PrintOperation::set_allow_async()</span>. Note that <span class="methodname" dir="ltr">set_allow_async()</span> is not supported
on all platforms, however the <span class="literal" dir="ltr">done</span> signal will still be emitted.
</p>
<p class="para block">
<span class="methodname" dir="ltr">run()</span> may return
<span class="literal" dir="ltr">PrintOperation::Result::IN_PROGRESS</span>. To track status
and handle the result or error you need to implement signal handlers for
the <span class="literal" dir="ltr">done</span> and <span class="literal" dir="ltr">status_changed</span> signals:
</p>
<p class="para block">For instance,</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">// in class ExampleWindow's method...
auto op = PrintOperation::create();
// ...set up op...
op-&gt;signal_done().connect(sigc::bind(sigc::mem_fun(
  *this, &amp;ExampleWindow::on_printoperation_done), op));
// run the op
</pre></div>
<p class="para block">Second, check for an error and connect to the <span class="literal" dir="ltr">status_changed</span> signal. For instance:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">void ExampleWindow::on_printoperation_done(Gtk::PrintOperationResult result,
  const Glib::RefPtr&lt;PrintOperation&gt;&amp; op)
{
  if (result == Gtk::PrintOperation::Result::ERROR)
    //notify user
  else if (result == Gtk::PrintOperation::Result::APPLY)
    //Update PrintSettings with the ones used in this PrintOperation

  if (! op-&gt;is_finished())
    op-&gt;signal_status_changed().connect(sigc::bind(sigc::mem_fun(
      *this, &amp;ExampleWindow::on_printoperation_status_changed), op));
}
</pre></div>
<p class="para block">Finally, check the status. For instance,</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">void ExampleWindow::on_printoperation_status_changed(const Glib::RefPtr&lt;PrintOperation&gt;&amp; op)
{
  if (op-&gt;is_finished())
    //the print job is finished
  else
    //get the status with get_status() or get_status_string()

  //update UI
}
</pre></div>
</div>
<div class="division sect1">
<a name="sec-printing-export-to-pdf"><!--sec-printing-export-to-pdf--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">19.5. </span>Export to PDF</span></h3></div>
<p class="para block block-first">
The 'Print to file' option is available in the print dialog, without the need for extra implementation. However, it is sometimes useful to generate a pdf file directly from code. For instance,
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">auto op = Gtk::PrintOperation::create();
// ...set up op...
op-&gt;set_export_filename("test.pdf");
auto res = op-&gt;run(Gtk::PrintOperation::Action::EXPORT);
</pre></div>
</div>
<div class="division sect1">
<a name="sec-extending-print-dialog"><!--sec-extending-print-dialog--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">19.6. </span>Extending the print dialog</span></h3></div>
<p class="para block block-first">
You may add a custom tab to the print dialog:

<div class="block list itemizedlist"><ul class="itemizedlist">
<li class="li-first">
    <span class="para">
      Set the title of the tab via
      <span class="methodname" dir="ltr">PrintOperation::set_custom_tab_label()</span>,
      create a new widget and return it from the
      <span class="literal" dir="ltr">create_custom_widget</span> signal handler. You'll probably
      want this to be a container widget, packed with some others.
    </span>
  </li>
<li>
    <span class="para">
      Get the data from the widgets in the
      <span class="literal" dir="ltr">custom_widget_apply</span> signal handler.
    </span>
  </li>
</ul></div>
</p>
<p class="para block">
Although the <span class="literal" dir="ltr">custom_widget_apply</span> signal provides the widget you
previously created, to simplify things you can keep the widgets you expect
to contain some user input as class members. For example, let's say you have
a <span class="classname" dir="ltr">Gtk::Entry</span> called <span class="literal" dir="ltr">m_Entry</span> as
a member of your <span class="classname" dir="ltr">CustomPrintOperation</span> class:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">Gtk::Widget* CustomPrintOperation::on_create_custom_widget()
{
  set_custom_tab_label("My custom tab");

  auto hbox = new Gtk::Box(Gtk::Orientation::HORIZONTAL, 8);
  hbox-&gt;set_margin(6);

  auto label = Gtk::make_managed&lt;Gtk::Label&gt;("Enter some text: ");
  hbox-&gt;append(*label);

  hbox-&gt;append(m_Entry);

  return hbox;
}

void CustomPrintOperation::on_custom_widget_apply(Gtk::Widget* /* widget */)
{
  auto user_input = m_Entry.get_text();
  //...
}
</pre></div>
<p class="para block">
The example in examples/book/printing/advanced demonstrates this.
</p>
</div>
<div class="division sect1">
<a name="sec-printing-preview"><!--sec-printing-preview--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">19.7. </span>Preview</span></h3></div>
<p class="para block block-first">
The native GTK print dialog has a preview button, but you may also start
a preview directly from an application:</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">// in a class that inherits from Gtk::Window...
auto op = PrintOperation::create();
// ...set up op...
op-&gt;run(Gtk::PrintOperation::Action::PREVIEW, *this);
</pre></div>
<p class="para block">
On Unix, the default preview handler uses an external viewer program.
On Windows, the native preview dialog will be shown. If necessary you may
override this behaviour and provide a custom preview dialog. See the example
located in /examples/book/printing/advanced.
</p>
</div>
<div class="division sect1">
<a name="sec-printing-example"><!--sec-printing-example--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">19.8. </span>Example</span></h3></div>
<div class="autotoc"><ul><li>
<span class="label">19.8.1. </span><a class="xref" href="#sec-printing-example-simple" title="Simple">Simple</a>
</li></ul></div>
<div class="division sect2">
<a name="sec-printing-example-simple"><!--sec-printing-example-simple--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">19.8.1. </span>Simple</span></h4></div>
<p class="para block block-first">
The following example demonstrates how to print some input from a user
interface. It shows how to implement <span class="literal" dir="ltr">on_begin_print</span>
and <span class="literal" dir="ltr">on_draw_page</span>, as well as how to track print status
and update the print settings.
</p>
<div class=" block figure block-indent">
<a name="figure-printing-simple"><!--figure-printing-simple--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 19-1</span> </span>Printing - Simple</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/printing.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/printing/simple/" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/printing/simple/">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

// This file is part of the printing/simple and printing/advanced examples

#include &lt;gtkmm.h&gt;
#include &lt;memory&gt;

class PrintFormOperation;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow(const Glib::RefPtr&lt;Gtk::Application&gt;&amp; app);
  virtual ~ExampleWindow();

protected:

  void build_main_menu(const Glib::RefPtr&lt;Gtk::Application&gt;&amp; app);

  void print_or_preview(Gtk::PrintOperation::Action print_action);

  //PrintOperation signal handlers.
  //We handle these so can get necessary information to update the UI or print settings.
  //Our derived PrintOperation class also overrides some default signal handlers.
  void on_printoperation_status_changed();
  void on_printoperation_done(Gtk::PrintOperation::Result result);

  //Action signal handlers:
  void on_menu_file_new();
  void on_menu_file_page_setup();
  void on_menu_file_print_preview();
  void on_menu_file_print();
  void on_menu_file_quit();

  //Printing-related objects:
  Glib::RefPtr&lt;Gtk::PageSetup&gt; m_refPageSetup;
  Glib::RefPtr&lt;Gtk::PrintSettings&gt; m_refSettings;
  Glib::RefPtr&lt;PrintFormOperation&gt; m_refPrintFormOperation;

  //Child widgets:
  Gtk::Box m_VBox;
  Gtk::Grid m_Grid;

  Gtk::Label m_NameLabel;
  Gtk::Entry m_NameEntry;

  Gtk::Label m_SurnameLabel;
  Gtk::Entry m_SurnameEntry;

  Gtk::Label m_CommentsLabel;
  Gtk::ScrolledWindow m_ScrolledWindow;
  Gtk::TextView m_TextView;

  Glib::RefPtr&lt;Gtk::TextBuffer&gt; m_refTextBuffer;

  unsigned m_ContextId;
  Gtk::Statusbar m_Statusbar;

  Glib::RefPtr&lt;Gtk::Builder&gt; m_refBuilder;

  std::unique_ptr&lt;Gtk::MessageDialog&gt; m_pDialog;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">printformoperation.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_PRINT_FORM_OPERATION_H
#define GTKMM_PRINT_FORM_OPERATION_H

#include &lt;gtkmm.h&gt;
#include &lt;pangomm.h&gt;
#include &lt;vector&gt;

//We derive our own class from PrintOperation,
//so we can put the actual print implementation here.
class PrintFormOperation : public Gtk::PrintOperation
{
 public:
  static Glib::RefPtr&lt;PrintFormOperation&gt; create();
  virtual ~PrintFormOperation();

  void set_name(const Glib::ustring&amp; name) { m_Name = name; }
  void set_comments(const Glib::ustring&amp; comments) { m_Comments = comments; }

 protected:
  PrintFormOperation();

  //PrintOperation default signal handler overrides:
  void on_begin_print(const Glib::RefPtr&lt;Gtk::PrintContext&gt;&amp; context) override;
  void on_draw_page(const Glib::RefPtr&lt;Gtk::PrintContext&gt;&amp; context, int page_nr) override;

  Glib::ustring m_Name;
  Glib::ustring m_Comments;
  Glib::RefPtr&lt;Pango::Layout&gt; m_refLayout;
  std::vector&lt;int&gt; m_PageBreaks; // line numbers where a page break occurs
};

#endif // GTKMM_PRINT_FORM_OPERATION_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;gtkmm/application.h&gt;

int main(int argc, char* argv[])
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  // Shows the window and returns when it is closed.
  return app-&gt;make_window_and_run&lt;ExampleWindow&gt;(argc, argv, app);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include "printformoperation.h"
#include &lt;iostream&gt;

const Glib::ustring app_title = "gtkmm Printing Example";

ExampleWindow::ExampleWindow(const Glib::RefPtr&lt;Gtk::Application&gt;&amp; app)
: m_VBox(Gtk::Orientation::VERTICAL),
  m_NameLabel("Name"),
  m_SurnameLabel("Surname"),
  m_CommentsLabel("Comments")
{
  m_refPageSetup = Gtk::PageSetup::create();
  m_refSettings = Gtk::PrintSettings::create();

  m_ContextId = m_Statusbar.get_context_id(app_title);

  set_title(app_title);
  set_default_size(400, 300);

  set_child(m_VBox);

  build_main_menu(app);

  m_VBox.append(m_Grid);

  //Arrange the widgets inside the grid:
  m_Grid.set_expand(true);
  m_Grid.set_row_spacing(5);
  m_Grid.set_column_spacing(5);
  m_Grid.attach(m_NameLabel, 0, 0);
  m_Grid.attach(m_NameEntry, 1, 0);

  m_Grid.attach(m_SurnameLabel, 0, 1);
  m_Grid.attach(m_SurnameEntry, 1, 1);

  //Add the TextView, inside a ScrolledWindow:
  m_ScrolledWindow.set_child(m_TextView);

  //Only show the scrollbars when they are necessary:
  m_ScrolledWindow.set_policy(Gtk::PolicyType::AUTOMATIC, Gtk::PolicyType::AUTOMATIC);

  m_Grid.attach(m_CommentsLabel, 0, 2);
  m_Grid.attach(m_ScrolledWindow, 1, 2);
  m_ScrolledWindow.set_expand(true);

  m_refTextBuffer = Gtk::TextBuffer::create();
  m_TextView.set_buffer(m_refTextBuffer);

  m_Statusbar.set_expand(true);
  m_VBox.append(m_Statusbar);
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::build_main_menu(const Glib::RefPtr&lt;Gtk::Application&gt;&amp; app)
{
  //Create actions for menus and toolbars:
  auto refActionGroup = Gio::SimpleActionGroup::create();

  //File menu:
  refActionGroup-&gt;add_action("new",
    sigc::mem_fun(*this, &amp;ExampleWindow::on_menu_file_new));

  refActionGroup-&gt;add_action("pagesetup",
    sigc::mem_fun(*this, &amp;ExampleWindow::on_menu_file_page_setup));

  refActionGroup-&gt;add_action("printpreview",
    sigc::mem_fun(*this, &amp;ExampleWindow::on_menu_file_print_preview));

  refActionGroup-&gt;add_action("print",
    sigc::mem_fun(*this, &amp;ExampleWindow::on_menu_file_print));

  refActionGroup-&gt;add_action("quit",
    sigc::mem_fun(*this, &amp;ExampleWindow::on_menu_file_quit));

  insert_action_group("example", refActionGroup);

  // When the menubar is a child of a Gtk::Window, keyboard accelerators are not
  // automatically fetched from the Gio::Menu.
  // See the examples/book/menus/main_menu example for an alternative way of
  // adding the menubar when using Gtk::ApplicationWindow.
  app-&gt;set_accel_for_action("example.new", "&lt;Primary&gt;n");
  app-&gt;set_accel_for_action("example.print", "&lt;Primary&gt;p");
  app-&gt;set_accel_for_action("example.quit", "&lt;Primary&gt;q");

  m_refBuilder = Gtk::Builder::create();

  // Layout the actions in a menubar:
  Glib::ustring ui_menu_info =
    "&lt;interface&gt;"
    "  &lt;menu id='menu-example'&gt;"
    "    &lt;submenu&gt;"
    "      &lt;attribute name='label' translatable='yes'&gt;_File&lt;/attribute&gt;"
    "      &lt;section&gt;"
    "        &lt;item&gt;"
    "          &lt;attribute name='label' translatable='yes'&gt;_New&lt;/attribute&gt;"
    "          &lt;attribute name='action'&gt;example.new&lt;/attribute&gt;"
    "        &lt;/item&gt;"
    "      &lt;/section&gt;"
    "      &lt;section&gt;"
    "        &lt;item&gt;"
    "          &lt;attribute name='label' translatable='yes'&gt;Page _Setup...&lt;/attribute&gt;"
    "          &lt;attribute name='action'&gt;example.pagesetup&lt;/attribute&gt;"
    "        &lt;/item&gt;"
    "        &lt;item&gt;"
    "          &lt;attribute name='label' translatable='yes'&gt;Print Preview&lt;/attribute&gt;"
    "          &lt;attribute name='action'&gt;example.printpreview&lt;/attribute&gt;"
    "        &lt;/item&gt;"
    "        &lt;item&gt;"
    "          &lt;attribute name='label' translatable='yes'&gt;_Print...&lt;/attribute&gt;"
    "          &lt;attribute name='action'&gt;example.print&lt;/attribute&gt;"
    "        &lt;/item&gt;"
    "      &lt;/section&gt;"
    "      &lt;section&gt;"
    "        &lt;item&gt;"
    "          &lt;attribute name='label' translatable='yes'&gt;_Quit&lt;/attribute&gt;"
    "          &lt;attribute name='action'&gt;example.quit&lt;/attribute&gt;"
    "        &lt;/item&gt;"
    "      &lt;/section&gt;"
    "    &lt;/submenu&gt;"
    "  &lt;/menu&gt;"
    "&lt;/interface&gt;";

  try
  {
    m_refBuilder-&gt;add_from_string(ui_menu_info);
  }
  catch(const Glib::Error&amp; ex)
  {
    std::cerr &lt;&lt; "building menus failed: " &lt;&lt; ex.what();
  }

  // Layout the actions in a toolbar:
  Glib::ustring ui_toolbar_info =
    "&lt;!-- Generated with glade 3.18.3 and then changed manually --&gt;"
    "&lt;interface&gt;"
      "&lt;object class='GtkBox' id='toolbar'&gt;"
        "&lt;property name='can_focus'&gt;False&lt;/property&gt;"
        "&lt;property name='spacing'&gt;3&lt;/property&gt;"
        "&lt;child&gt;"
          "&lt;object class='GtkButton' id='toolbutton_new'&gt;"
            "&lt;property name='can_focus'&gt;False&lt;/property&gt;"
            "&lt;property name='tooltip_text' translatable='yes'&gt;New&lt;/property&gt;"
            "&lt;property name='action_name'&gt;example.new&lt;/property&gt;"
            "&lt;property name='icon_name'&gt;document-new&lt;/property&gt;"
            "&lt;property name='hexpand'&gt;False&lt;/property&gt;"
            "&lt;property name='vexpand'&gt;False&lt;/property&gt;"
          "&lt;/object&gt;"
        "&lt;/child&gt;"
        "&lt;child&gt;"
          "&lt;object class='GtkButton' id='toolbutton_print'&gt;"
            "&lt;property name='can_focus'&gt;False&lt;/property&gt;"
            "&lt;property name='tooltip_text' translatable='yes'&gt;Print&lt;/property&gt;"
            "&lt;property name='action_name'&gt;example.print&lt;/property&gt;"
            "&lt;property name='icon_name'&gt;document-print&lt;/property&gt;"
            "&lt;property name='hexpand'&gt;False&lt;/property&gt;"
            "&lt;property name='vexpand'&gt;False&lt;/property&gt;"
          "&lt;/object&gt;"
        "&lt;/child&gt;"
        "&lt;child&gt;"
          "&lt;object class='GtkSeparator' id='separator1'&gt;"
            "&lt;property name='can_focus'&gt;False&lt;/property&gt;"
            "&lt;property name='hexpand'&gt;False&lt;/property&gt;"
            "&lt;property name='vexpand'&gt;False&lt;/property&gt;"
          "&lt;/object&gt;"
        "&lt;/child&gt;"
        "&lt;child&gt;"
          "&lt;object class='GtkButton' id='toolbutton_quit'&gt;"
            "&lt;property name='can_focus'&gt;False&lt;/property&gt;"
            "&lt;property name='tooltip_text' translatable='yes'&gt;Quit&lt;/property&gt;"
            "&lt;property name='action_name'&gt;example.quit&lt;/property&gt;"
            "&lt;property name='icon_name'&gt;application-exit&lt;/property&gt;"
            "&lt;property name='hexpand'&gt;False&lt;/property&gt;"
            "&lt;property name='vexpand'&gt;False&lt;/property&gt;"
          "&lt;/object&gt;"
        "&lt;/child&gt;"
      "&lt;/object&gt;"
    "&lt;/interface&gt;";

  try
  {
    m_refBuilder-&gt;add_from_string(ui_toolbar_info);
  }
  catch(const Glib::Error&amp; ex)
  {
    std::cerr &lt;&lt; "building toolbar failed: " &lt;&lt; ex.what();
  }

  // Get the menubar and add it to a container widget:
  auto object = m_refBuilder-&gt;get_object("menu-example");
  auto gmenu = std::dynamic_pointer_cast&lt;Gio::Menu&gt;(object);
  if (!gmenu)
    g_warning("GMenu not found");
  else
  {
    auto pMenuBar = Gtk::make_managed&lt;Gtk::PopoverMenuBar&gt;(gmenu);

    // Add the PopoverMenuBar to the window:
    m_VBox.append(*pMenuBar);
  }

  // Get the toolbar and add it to a container widget:
  auto toolbar = m_refBuilder-&gt;get_widget&lt;Gtk::Box&gt;("toolbar");
  if (!toolbar)
    g_warning("toolbar not found");
  else
    m_VBox.append(*toolbar);
}

void ExampleWindow::on_printoperation_status_changed()
{
  Glib::ustring status_msg;

  if (m_refPrintFormOperation-&gt;is_finished())
  {
    status_msg = "Print job completed.";
  }
  else
  {
    //You could also use get_status().
    status_msg = m_refPrintFormOperation-&gt;get_status_string();
  }

  m_Statusbar.push(status_msg, m_ContextId);
}

void ExampleWindow::on_printoperation_done(Gtk::PrintOperation::Result result)
{
  //Printing is "done" when the print data is spooled.

  if (result == Gtk::PrintOperation::Result::ERROR)
  {
    if (!m_pDialog)
    {
      m_pDialog.reset(new Gtk::MessageDialog(*this, "Error printing form",
        false /* use_markup */, Gtk::MessageType::ERROR, Gtk::ButtonsType::OK,
        true /* modal */));
      m_pDialog-&gt;set_hide_on_close(true);
      m_pDialog-&gt;signal_response().connect(
        sigc::hide(sigc::mem_fun(*m_pDialog, &amp;Gtk::Widget::hide)));
    }
    m_pDialog-&gt;show();
  }
  else if (result == Gtk::PrintOperation::Result::APPLY)
  {
    //Update PrintSettings with the ones used in this PrintOperation:
    m_refSettings = m_refPrintFormOperation-&gt;get_print_settings();
  }

  if (!m_refPrintFormOperation-&gt;is_finished())
  {
    //We will connect to the status-changed signal to track status
    //and update a status bar. In addition, you can, for example,
    //keep a list of active print operations, or provide a progress dialog.
    m_refPrintFormOperation-&gt;signal_status_changed().connect(sigc::mem_fun(*this,
                    &amp;ExampleWindow::on_printoperation_status_changed));
  }
}

void ExampleWindow::print_or_preview(Gtk::PrintOperation::Action print_action)
{
  //Create a new PrintOperation with our PageSetup and PrintSettings:
  //(We use our derived PrintOperation class)
  m_refPrintFormOperation = PrintFormOperation::create();

  m_refPrintFormOperation-&gt;set_name(m_NameEntry.get_text() + " " + m_SurnameEntry.get_text());
  m_refPrintFormOperation-&gt;set_comments(m_refTextBuffer-&gt;get_text(false /*Don't include hidden*/));
  // In the printing/advanced example, the font will be set through a custom tab
  // in the print dialog.

  m_refPrintFormOperation-&gt;set_track_print_status();
  m_refPrintFormOperation-&gt;set_default_page_setup(m_refPageSetup);
  m_refPrintFormOperation-&gt;set_print_settings(m_refSettings);

  m_refPrintFormOperation-&gt;signal_done().connect(sigc::mem_fun(*this,
                  &amp;ExampleWindow::on_printoperation_done));
  try
  {
    m_refPrintFormOperation-&gt;run(print_action /* print or preview */, *this);
  }
  catch (const Gtk::PrintError&amp; ex)
  {
    //See documentation for exact Gtk::PrintError error codes.
    std::cerr &lt;&lt; "An error occurred while trying to run a print operation:"
        &lt;&lt; ex.what() &lt;&lt; std::endl;
  }
}

void ExampleWindow::on_menu_file_new()
{
  //Clear entries and textview:
  m_NameEntry.set_text("");
  m_SurnameEntry.set_text("");
  m_refTextBuffer-&gt;set_text("");
  m_TextView.set_buffer(m_refTextBuffer);
}

void ExampleWindow::on_menu_file_page_setup()
{
  //Show the page setup dialog, asking it to start with the existing settings:
  auto new_page_setup =
      Gtk::run_page_setup_dialog(*this, m_refPageSetup, m_refSettings);

  //Save the chosen page setup dialog for use when printing, previewing, or
  //showing the page setup dialog again:
  m_refPageSetup = new_page_setup;
}

void ExampleWindow::on_menu_file_print_preview()
{
  print_or_preview(Gtk::PrintOperation::Action::PREVIEW);
}

void ExampleWindow::on_menu_file_print()
{
  print_or_preview(Gtk::PrintOperation::Action::PRINT_DIALOG);
}

void ExampleWindow::on_menu_file_quit()
{
  hide();
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">printformoperation.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "printformoperation.h"

PrintFormOperation::PrintFormOperation()
{
}

PrintFormOperation::~PrintFormOperation()
{
}

Glib::RefPtr&lt;PrintFormOperation&gt; PrintFormOperation::create()
{
  return Glib::make_refptr_for_instance&lt;PrintFormOperation&gt;(new PrintFormOperation());
}

void PrintFormOperation::on_begin_print(
        const Glib::RefPtr&lt;Gtk::PrintContext&gt;&amp; print_context)
{
  //Create and set up a Pango layout for PrintData based on the passed
  //PrintContext: We then use this to calculate the number of pages needed, and
  //the lines that are on each page.
  m_refLayout = print_context-&gt;create_pango_layout();

  Pango::FontDescription font_desc("sans 12");
  m_refLayout-&gt;set_font_description(font_desc);

  const double width = print_context-&gt;get_width();
  const double height = print_context-&gt;get_height();

  m_refLayout-&gt;set_width(static_cast&lt;int&gt;(width * Pango::SCALE));

  //Set and mark up the text to print:
  Glib::ustring marked_up_form_text;
  marked_up_form_text += "&lt;b&gt;Name&lt;/b&gt;: " + m_Name + "\n\n";
  marked_up_form_text += "&lt;b&gt;Comments&lt;/b&gt;: " + m_Comments;

  m_refLayout-&gt;set_markup(marked_up_form_text);

  //Set the number of pages to print by determining the line numbers
  //where page breaks occur:
  const int line_count = m_refLayout-&gt;get_line_count();

  Glib::RefPtr&lt;Pango::LayoutLine&gt; layout_line;
  double page_height = 0;

  for (int line = 0; line &lt; line_count; ++line)
  {
    Pango::Rectangle ink_rect, logical_rect;

    layout_line = m_refLayout-&gt;get_line(line);
    layout_line-&gt;get_extents(ink_rect, logical_rect);

    const double line_height = logical_rect.get_height() / 1024.0;

    if (page_height + line_height &gt; height)
    {
      m_PageBreaks.push_back(line);
      page_height = 0;
    }

    page_height += line_height;
  }

  set_n_pages(m_PageBreaks.size() + 1);
}

void PrintFormOperation::on_draw_page(
        const Glib::RefPtr&lt;Gtk::PrintContext&gt;&amp; print_context, int page_nr)
{
  //Decide which lines we need to print in order to print the specified page:
  int start_page_line = 0;
  int end_page_line = 0;

  if(page_nr == 0)
  {
    start_page_line = 0;
  }
  else
  {
    start_page_line = m_PageBreaks[page_nr - 1];
  }

  if(page_nr &lt; static_cast&lt;int&gt;(m_PageBreaks.size()))
  {
    end_page_line = m_PageBreaks[page_nr];
  }
  else
  {
    end_page_line = m_refLayout-&gt;get_line_count();
  }

  //Get a Cairo Context, which is used as a drawing board:
  Cairo::RefPtr&lt;Cairo::Context&gt; cairo_ctx = print_context-&gt;get_cairo_context();

  //We'll use black letters:
  cairo_ctx-&gt;set_source_rgb(0, 0, 0);

  //Render Pango LayoutLines over the Cairo context:
  auto iter = m_refLayout-&gt;get_iter();

  double start_pos = 0;
  int line_index = 0;

  do
  {
    if(line_index &gt;= start_page_line)
    {
      auto layout_line = iter.get_line();
      auto logical_rect = iter.get_line_logical_extents();
      int baseline = iter.get_baseline();

      if (line_index == start_page_line)
      {
        start_pos = logical_rect.get_y() / 1024.0;
      }

      cairo_ctx-&gt;move_to(logical_rect.get_x() / 1024.0,
        baseline / 1024.0 - start_pos);

      layout_line-&gt;show_in_cairo_context(cairo_ctx);
    }

    line_index++;
  }
  while(line_index &lt; end_page_line &amp;&amp; iter.next_line());
}

</pre></div>
</div>
</div>
</div>
<div class="division chapter">
<a name="chapter-recent-documents"><!--chapter-recent-documents--></a><div class="header"><h2 class="chapter title"><span class="title"><span class="label">20. </span>Recently Used Documents</span></h2></div>
<p class="para block block-first">
    <span class="application">gtkmm</span> provides an easy way to manage recently used documents. This functionality
    is implemented in the <span class="classname" dir="ltr">Gtk::RecentManager</span> class.
  </p>
<p class="para block">
    Each item in the list of recently used files is identified by its URI, and
    can have associated metadata. The metadata can be used to specify how the
    file should be displayed, a description of the file, its mime type, which
    application registered it, whether it's private to the registering
    application, and several other things.
  </p>
<div class="autotoc"><ul>
<li>
<span class="label">20.1. </span><a class="xref" href="#sec-recentmanager" title="RecentManager">RecentManager</a>
</li>
<li>
<span class="label">20.2. </span><a class="xref" href="#sec-filechooser" title="FileChooser">FileChooser</a>
</li>
</ul></div>
<div class="division sect1">
<a name="sec-recentmanager"><!--sec-recentmanager--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">20.1. </span>RecentManager</span></h3></div>
<p class="para block block-first">
      <span class="classname" dir="ltr">RecentManager</span> acts as a database of
      recently used files. You use this class to register new files, remove
      files from the list, or look up recently used files. There is one list
      of recently used files per user.
    </p>
<p class="para block">
      You can create a new <span class="classname" dir="ltr">RecentManager</span>, but you'll most
      likely just want to use the default one. You can get a reference to the
      default <span class="classname" dir="ltr">RecentManager</span> with
      <span class="methodname" dir="ltr">get_default()</span>.
    </p>
<div class="autotoc"><ul>
<li>
<span class="label">20.1.1. </span><a class="xref" href="#recent-files-adding" title="Adding Items to the List of Recent Files">Adding Items to the List of Recent Files</a>
</li>
<li>
<span class="label">20.1.2. </span><a class="xref" href="#recent-files-lookup" title="Looking up Items in the List of Recent Files">Looking up Items in the List of Recent Files</a>
</li>
<li>
<span class="label">20.1.3. </span><a class="xref" href="#recent-files-modifying" title="Modifying the List of Recent Files">Modifying the List of Recent Files</a>
</li>
</ul></div>
<div class="division sect2">
<a name="recent-files-adding"><!--recent-files-adding--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">20.1.1. </span>Adding Items to the List of Recent Files</span></h4></div>
<p class="para block block-first">
        To add a new file to the list of recent documents, in the simplest case,
        you only need to provide the URI. For example:
      </p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">auto recent_manager = Gtk::RecentManager::get_default();
recent_manager-&gt;add_item(uri);</pre></div>
<p class="para block">
        If you want to register a file with metadata, you can pass a
        <span class="classname" dir="ltr">RecentManager::Data</span> parameter to
        <span class="methodname" dir="ltr">add_item()</span>. The metadata that can be set on a
        particular file item is as follows:
      </p>
<div class="block list itemizedlist">
<a name="list-file-metadata"><!--list-file-metadata--></a><ul class="itemizedlist">
<li class="li-first">
          <span class="para"><span class="varname" dir="ltr">app_exec</span>: The command line to be used to launch
            this resource. This string may contain the "f" and "u" escape
            characters which will be expanded to the resource file path and URI
            respectively</span>
        </li>
<li>
          <span class="para"><span class="varname" dir="ltr">app_name</span>: The name of the application that
            registered the resource</span>
        </li>
<li>
          <span class="para"><span class="varname" dir="ltr">description</span>: A short description of the
            resource as a UTF-8 encoded string</span>
        </li>
<li>
          <span class="para"><span class="varname" dir="ltr">display_name</span>: The name of the resource to be
            used for display as a UTF-8 encoded string</span>
        </li>
<li>
          <span class="para"><span class="varname" dir="ltr">groups</span>: A list of groups associated with this
            item. Groups are essentially arbitrary strings associated with a
            particular resource. They can be thought of as 'categories' (such
            as "email", "graphics", etc) or tags for the resource.</span>
        </li>
<li>
          <span class="para"><span class="varname" dir="ltr">is_private</span>: Whether this resource should be
            visible only to applications that have registered it or not</span>
        </li>
<li>
          <span class="para"><span class="varname" dir="ltr">mime_type</span>: The MIME type of the resource</span>
        </li>
</ul>
</div>
<p class="para block">
        In addition to adding items to the list, you can also look up items from
        the list and modify or remove items.
      </p>
</div>
<div class="division sect2">
<a name="recent-files-lookup"><!--recent-files-lookup--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">20.1.2. </span>Looking up Items in the List of Recent Files</span></h4></div>
<p class="para block block-first">
        To look up recently used files, <span class="classname" dir="ltr">RecentManager</span>
        provides several functions. To look up a specific item by its URI, you
        can use the <span class="methodname" dir="ltr">lookup_item()</span> function, which will
        return a <span class="classname" dir="ltr">RecentInfo</span> class. If the specified URI
        did not exist in the list of recent files,
        <span class="methodname" dir="ltr">lookup_item()</span> throws a
        <span class="classname" dir="ltr">RecentManagerError</span> exception. For example:
      </p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">Glib::RefPtr&lt;Gtk::RecentInfo&gt; info;
try
{
  info = recent_manager-&gt;lookup_item(uri);
}
catch(const Gtk::RecentManagerError&amp; ex)
{
  std::cerr &lt;&lt; "RecentManagerError: " &lt;&lt; ex.what() &lt;&lt; std::endl;
}
if (info)
{
  // item was found
}</pre></div>
<p class="para block">
        A <span class="classname" dir="ltr">RecentInfo</span> object is essentially an object
        containing all of the metadata about a single recently-used file. You
        can use this object to look up any of the properties listed
        <a class="link" href="#list-file-metadata" title="">above</a>.
      </p>
<p class="para block">
        If you don't want to look for a specific URI, but instead want to get a
        list of all recently used items, <span class="classname" dir="ltr">RecentManager</span>
        provides the <span class="methodname" dir="ltr">get_items()</span> function. The return
        value of this function is a <span class="classname" dir="ltr">std::vector</span> of all
        recently used files. The following code demonstrates how you might get a
        list of recently used files:
      </p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">auto info_list = recent_manager-&gt;get_items();</pre></div>
<p class="para block">
        The maximum age of items in the recently used files list can be set with
        <span class="methodname" dir="ltr">Gtk::Settings::property_gtk_recent_files_max_age()</span>.
        Default value: 30 days.
      </p>
</div>
<div class="division sect2">
<a name="recent-files-modifying"><!--recent-files-modifying--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">20.1.3. </span>Modifying the List of Recent Files</span></h4></div>
<p class="para block block-first">
        There may be times when you need to modify the list of recent files.
        For instance, if a file is moved or renamed, you may need to update the
        file's location in the recent files list so that it doesn't point to an
        incorrect location. You can update an item's location by using
        <span class="methodname" dir="ltr">move_item()</span>.
      </p>
<p class="para block">
        In addition to changing a file's URI, you can also remove items from the
        list, either one at a time or by clearing them all at once. The former
        is accomplished with <span class="methodname" dir="ltr">remove_item()</span>, the latter with
        <span class="methodname" dir="ltr">purge_items()</span>.
      </p>
<div class="admonition block note block-indent"><div class="note-inner">
        <p class="para block block-first">
        The functions <span class="methodname" dir="ltr">move_item()</span>,
        <span class="methodname" dir="ltr">remove_item()</span> and
        <span class="methodname" dir="ltr">purge_items()</span> have no effect on the actual files
        that are referred to by the URIs, they only modify the list of recent
        files.
        </p>
      </div></div>
</div>
</div>
<div class="division sect1">
<a name="sec-filechooser"><!--sec-filechooser--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">20.2. </span>FileChooser</span></h3></div>
<p class="para block block-first">
      <span class="classname" dir="ltr">FileChooser</span> is an interface that can be
      implemented by widgets displaying a list of files.
      <span class="application">gtkmm</span> provides three built-in implementations for choosing recent files
      or other files:
      <span class="classname" dir="ltr">FileChooserWidget</span>,
      <span class="classname" dir="ltr">FileChooserDialog</span>, and
      <span class="classname" dir="ltr">FileChooserNative</span>.
    </p>
<p class="para block">
      <span class="classname" dir="ltr">FileChooserWidget</span> is a simple widget for
      displaying a list of recently used files or other files.
      <span class="classname" dir="ltr">FileChooserWidget</span> is the basic building block for
      <span class="classname" dir="ltr">FileChooserDialog</span>, but you can embed it into your
      user interface if you want to.
    </p>
<div class="autotoc"><ul>
<li>
<span class="label">20.2.1. </span><a class="xref" href="#recentfiles-example" title="Simple FileChooserDialog example">Simple FileChooserDialog example</a>
</li>
<li>
<span class="label">20.2.2. </span><a class="xref" href="#recent-files-filtering" title="Filtering Files">Filtering Files</a>
</li>
</ul></div>
<div class="division sect2">
<a name="recentfiles-example"><!--recentfiles-example--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">20.2.1. </span>Simple FileChooserDialog example</span></h4></div>
<p class="para block block-first">
        Shown below is a simple example of how to use the
        <span class="classname" dir="ltr">FileChooserDialog</span> class in a program.
        This simple program has a menubar with a
        <span class="guimenuitem">File Chooser Dialog</span> menu item.
        When you select this menu item, a dialog pops up showing a list of files.
        If you select <span class="guimenuitem">Recent</span> in the sidebar,
        the list of recently used files is shown.
      </p>
<div class="admonition block note block-indent"><div class="note-inner">
        <p class="para block block-first">
          If this is the first time you're using a program that uses the Recent
          Files framework, the dialog may be empty at first. Otherwise it
          should show the list of recently used documents registered by other
          applications.
        </p>
      </div></div>
<p class="para block">
        After selecting the <span class="guimenuitem">File Chooser Dialog</span> menu
        item and the <span class="guimenuitem">Recent</span> sidebar item, you should
        see something similar to the following window.
      </p>
<div class=" block screenshot">
          <div class="graphic"><img src="figures/recentfiles.png.en"></div>
      </div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/recent_files" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/recent_files">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;
#include &lt;memory&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow(const Glib::RefPtr&lt;Gtk::Application&gt;&amp; app);
  ~ExampleWindow() override;

protected:
  //Signal handlers:
  void on_menu_file_files_dialog();
  void on_menu_file_quit();
  void on_menu_file_new();
  void on_dialog_response(int response_id);

  //Child widgets:
  Gtk::Box m_Box;

  Glib::RefPtr&lt;Gtk::Builder&gt; m_refBuilder;
  Glib::RefPtr&lt;Gio::SimpleActionGroup&gt; m_refActionGroup;

  Glib::RefPtr&lt;Gtk::RecentManager&gt; m_refRecentManager;

  std::unique_ptr&lt;Gtk::FileChooserDialog&gt; m_pDialog;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;gtkmm/application.h&gt;

int main(int argc, char *argv[])
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  //Shows the window and returns when it is closed.
  return app-&gt;make_window_and_run&lt;ExampleWindow&gt;(argc, argv, app);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;iostream&gt;

ExampleWindow::ExampleWindow(const Glib::RefPtr&lt;Gtk::Application&gt;&amp; app)
: m_Box(Gtk::Orientation::VERTICAL),
  m_refRecentManager(Gtk::RecentManager::get_default())
{
  set_title("Recent files example");
  set_default_size(300, 150);

  //We can put a PopoverMenuBar at the top of the box and other stuff below it.
  set_child(m_Box);

  //Create actions for menus and toolbars:
  m_refActionGroup = Gio::SimpleActionGroup::create();

  //File menu:
  m_refActionGroup-&gt;add_action("new",
    sigc::mem_fun(*this, &amp;ExampleWindow::on_menu_file_new));

  //A menu item to open the file chooser dialog:
  m_refActionGroup-&gt;add_action("files-dialog",
    sigc::mem_fun(*this, &amp;ExampleWindow::on_menu_file_files_dialog));

  m_refActionGroup-&gt;add_action("quit",
    sigc::mem_fun(*this, &amp;ExampleWindow::on_menu_file_quit) );

  insert_action_group("example", m_refActionGroup);


  m_refBuilder = Gtk::Builder::create();

  // When the menubar is a child of a Gtk::Window, keyboard accelerators are not
  // automatically fetched from the Gio::Menu.
  // See the examples/book/menus/main_menu example for an alternative way of
  // adding the menubar when using Gtk::ApplicationWindow.
  app-&gt;set_accel_for_action("example.new", "&lt;Primary&gt;n");
  app-&gt;set_accel_for_action("example.files-dialog", "&lt;Primary&gt;o");
  app-&gt;set_accel_for_action("example.quit", "&lt;Primary&gt;q");

  //Layout the actions in a menubar and a toolbar:
  const char* ui_info =
    "&lt;interface&gt;"
    "  &lt;menu id='menubar'&gt;"
    "    &lt;submenu&gt;"
    "      &lt;attribute name='label' translatable='yes'&gt;_File&lt;/attribute&gt;"
    "      &lt;item&gt;"
    "        &lt;attribute name='label' translatable='yes'&gt;_New&lt;/attribute&gt;"
    "        &lt;attribute name='action'&gt;example.new&lt;/attribute&gt;"
    "        &lt;attribute name='accel'&gt;&amp;lt;Primary&amp;gt;n&lt;/attribute&gt;"
    "      &lt;/item&gt;"
    "      &lt;item&gt;"
    "        &lt;attribute name='label' translatable='yes'&gt;File Chooser _Dialog&lt;/attribute&gt;"
    "        &lt;attribute name='action'&gt;example.files-dialog&lt;/attribute&gt;"
    "        &lt;attribute name='accel'&gt;&amp;lt;Primary&amp;gt;o&lt;/attribute&gt;"
    "      &lt;/item&gt;"
    "      &lt;item&gt;"
    "        &lt;attribute name='label' translatable='yes'&gt;_Quit&lt;/attribute&gt;"
    "        &lt;attribute name='action'&gt;example.quit&lt;/attribute&gt;"
    "        &lt;attribute name='accel'&gt;&amp;lt;Primary&amp;gt;q&lt;/attribute&gt;"
    "      &lt;/item&gt;"
    "    &lt;/submenu&gt;"
    "  &lt;/menu&gt;"
    "  &lt;object class='GtkBox' id='toolbar'&gt;"
    "    &lt;property name='can_focus'&gt;False&lt;/property&gt;"
    "    &lt;child&gt;"
    "      &lt;object class='GtkButton' id='toolbutton_new'&gt;"
    "        &lt;property name='can_focus'&gt;False&lt;/property&gt;"
    "        &lt;property name='tooltip_text' translatable='yes'&gt;New&lt;/property&gt;"
    "        &lt;property name='action_name'&gt;example.new&lt;/property&gt;"
    "        &lt;property name='icon_name'&gt;document-new&lt;/property&gt;"
    "        &lt;property name='hexpand'&gt;False&lt;/property&gt;"
    "        &lt;property name='vexpand'&gt;False&lt;/property&gt;"
    "      &lt;/object&gt;"
    "    &lt;/child&gt;"
    "    &lt;child&gt;"
    "      &lt;object class='GtkButton' id='toolbutton_quit'&gt;"
    "        &lt;property name='can_focus'&gt;False&lt;/property&gt;"
    "        &lt;property name='tooltip_text' translatable='yes'&gt;Quit&lt;/property&gt;"
    "        &lt;property name='action_name'&gt;example.quit&lt;/property&gt;"
    "        &lt;property name='icon_name'&gt;application-exit&lt;/property&gt;"
    "        &lt;property name='hexpand'&gt;False&lt;/property&gt;"
    "        &lt;property name='vexpand'&gt;False&lt;/property&gt;"
    "      &lt;/object&gt;"
    "    &lt;/child&gt;"
    "  &lt;/object&gt;"
    "&lt;/interface&gt;";

  try
  {
    m_refBuilder-&gt;add_from_string(ui_info);
  }
  catch(const Glib::Error&amp; ex)
  {
    std::cerr &lt;&lt; "building menubar and toolbar failed: " &lt;&lt;  ex.what();
  }

  //Get the menubar and toolbar widgets, and add them to a container widget:
  auto object = m_refBuilder-&gt;get_object("menubar");
  auto gmenu = std::dynamic_pointer_cast&lt;Gio::Menu&gt;(object);
  if (gmenu)
  {
    //Menubar:
    auto pMenubar = Gtk::make_managed&lt;Gtk::PopoverMenuBar&gt;(gmenu);
    m_Box.append(*pMenubar);
  }
  else
    g_warning("GMenu not found");

  auto pToolbar = m_refBuilder-&gt;get_widget&lt;Gtk::Box&gt;("toolbar");
  if (pToolbar)
    //Toolbar:
    m_Box.append(*pToolbar);
  else
    g_warning("toolbar not found");
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_menu_file_new()
{
  std::cout &lt;&lt; " New File" &lt;&lt; std::endl;
}

void ExampleWindow::on_menu_file_quit()
{
  hide(); //Closes the main window to stop the app-&gt;make_window_and_run().
}

void ExampleWindow::on_menu_file_files_dialog()
{
  if (!m_pDialog)
  {
    m_pDialog.reset(new Gtk::FileChooserDialog(*this, "Files",
      Gtk::FileChooser::Action::OPEN, /* use_header_bar= */ true));
    m_pDialog-&gt;set_transient_for(*this);
    m_pDialog-&gt;set_modal(true);
    m_pDialog-&gt;signal_response().connect(
      sigc::mem_fun(*this, &amp;ExampleWindow::on_dialog_response));

    m_pDialog-&gt;add_button("Select File", Gtk::ResponseType::OK);
    m_pDialog-&gt;add_button("_Cancel", Gtk::ResponseType::CANCEL);
  }
  m_pDialog-&gt;show();
}

void ExampleWindow::on_dialog_response(int response_id)
{
  m_pDialog-&gt;hide();

  if (response_id == Gtk::ResponseType::OK)
  {
    auto selected_uri = m_pDialog-&gt;get_file()-&gt;get_uri();
    std::cout &lt;&lt; "URI selected = " &lt;&lt; selected_uri &lt;&lt; std::endl;
    std::cout &lt;&lt; (m_refRecentManager-&gt;has_item(selected_uri) ? "A" : "Not a")
      &lt;&lt; " recently used file" &lt;&lt; std::endl;
  }
}
</pre></div>
<p class="para block">
        The constructor for <span class="classname" dir="ltr">ExampleWindow</span> creates the
        menu and the toolbar using <span class="classname" dir="ltr">Builder</span> (see <a class="xref" href="#chapter-menus-and-toolbars" title="Menus and Toolbars">Chapter 13 ― Menus and Toolbars</a> for more information). It then adds
        the menu and the toolbar to the window.
      </p>
</div>
<div class="division sect2">
<a name="recent-files-filtering"><!--recent-files-filtering--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">20.2.2. </span>Filtering Files</span></h4></div>
<p class="para block block-first">
        For any of the <span class="classname" dir="ltr">FileChooser</span> classes, if you
        don't wish to display all of the items in the list of files, you
        can filter the list to show only those that you want. You can filter
        the list with the help of the <span class="classname" dir="ltr">FileFilter</span> class.
        This class allows you to filter files by their name
        (<span class="methodname" dir="ltr">add_pattern()</span>), or their mime type
        (<span class="methodname" dir="ltr">add_mime_type()</span>).
      </p>
<p class="para block">
        After you've created and set up the filter to match only the items you
        want, you can apply a filter to a chooser widget with the
        <span class="methodname" dir="ltr">FileChooser::add_filter()</span> function.
      </p>
</div>
</div>
</div>
<div class="division chapter">
<a name="chapter-keyboardevents"><!--chapter-keyboardevents--></a><div class="header"><h2 class="chapter title"><span class="title"><span class="label">21. </span>Keyboard Events</span></h2></div>
<p class="para block block-first">
    X events differ in some ways from other signals. These differences are described
    in the <a class="link" href="#sec-xeventsignals" title="X Event signals">X Event signals</a> section in
    the appendix. Here we will use keyboard events to show how X events can be
    used in a program.
  </p>
<div class="autotoc"><ul>
<li>
<span class="label">21.1. </span><a class="xref" href="#sec-keyboardevents-overview" title="Overview">Overview</a>
</li>
<li>
<span class="label">21.2. </span><a class="xref" href="#sec-keyboardevents-propagation" title="Event Propagation">Event Propagation</a>
</li>
</ul></div>
<div class="division sect1">
<a name="sec-keyboardevents-overview"><!--sec-keyboardevents-overview--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">21.1. </span>Overview</span></h3></div>
<p class="para block block-first">
      Whenever you press or release a key, an event is emitted. You can connect
      a signal handler to handle such events.
    </p>
<p class="para block">
      The event signal handler will
      receive an argument that depends on the type of event. For keyboard
      events it's a <span class="type" dir="ltr">GdkEventKey*</span>. As discribed in the
      <a class="link" href="#sec-xeventsignals" title="X Event signals">appendix</a>, the event signal handler
      returns a <span class="type" dir="ltr">bool</span> value, to indicate that the signal is fully
      handled (<span class="literal" dir="ltr">true</span>) or allow event propagation
      (<span class="literal" dir="ltr">false</span>).
    </p>
<p class="para block">
      To determine which key was pressed or released, you read the value of
      <span class="varname" dir="ltr">GdkEventKey::keyval</span> and compare it with a constant in the
      <span class="filename" dir="ltr">&lt;gdk/gdkkeysyms.h&gt;</span> header file. The states of
      modifier keys (shift, ctrl, etc.) are available as bit-flags in
      <span class="varname" dir="ltr">GdkEventKey::state</span>.
    </p>
<p class="para block">
      Here's a simple example:
    </p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">bool on_key_press_or_release_event(GdkEventKey* event)
{
  if (event-&gt;type == GDK_KEY_PRESS &amp;&amp;
    event-&gt;keyval == GDK_KEY_1 &amp;&amp;
    (event-&gt;state &amp; (GDK_SHIFT_MASK | GDK_CONTROL_MASK | GDK_MOD1_MASK)) == GDK_MOD1_MASK)
  {
    handle_alt_1_press(); // GDK_MOD1_MASK is normally the Alt key
    return true;
  }
  return false;
}

Gtk::Entry m_entry; // in a class definition

// in the class constructor
m_entry.signal_key_press_event().connect( sigc::ptr_fun(&amp;on_key_press_or_release_event) );
m_entry.signal_key_release_event().connect( sigc::ptr_fun(&amp;on_key_press_or_release_event) );
</pre></div>
<div class="autotoc"><ul><li>
<span class="label">21.1.1. </span><a class="xref" href="#keyboardevents-simple-example" title="Example">Example</a>
</li></ul></div>
<div class="division sect2">
<a name="keyboardevents-simple-example"><!--keyboardevents-simple-example--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">21.1.1. </span>Example</span></h4></div>
<p class="para block block-first">
        In this example there are three keyboard shortcuts:
        <span class="keycap">Alt</span>+<span class="keycap">1</span> selects the first radio button,
        <span class="keycap">Alt</span>+<span class="keycap">2</span> selects the second one, and the
        <span class="keycap">Esc</span> key hides (closes) the window.
        The default event signal handler is overridden, as described in the
        <a class="link" href="#sec-overriding-default-signal-handlers" title="Overriding default signal handlers">Overriding default signal handlers</a>
        section in the appendix.
      </p>
<div class=" block figure block-indent">
<a name="figure-keyboardevents-simple"><!--figure-keyboardevents-simple--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 21-1</span> </span>Keyboard Events - Simple</span></div>
<div class="figure-inner">
        
        <div class=" block screenshot block-first">
          <div class="graphic"><img src="figures/keyboardevents_simple.png.en"></div>
        </div>
      </div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/keyboard_events/simple/" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/keyboard_events/simple/">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:

  ExampleWindow();
  virtual ~ExampleWindow();

private:
  // Signal handler:
  bool on_window_key_pressed(guint keyval, guint keycode, Gdk::ModifierType state);

  Gtk::Box m_container;
  Gtk::CheckButton m_first;
  Gtk::CheckButton m_second;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;gtkmm/application.h&gt;

int main(int argc, char *argv[])
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  //Shows the window and returns when it is closed.
  return app-&gt;make_window_and_run&lt;ExampleWindow&gt;(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"

ExampleWindow::ExampleWindow()
{
  set_title("Keyboard Events");
  m_container.set_margin(10);
  set_child(m_container);

  // Radio buttons:
  m_first.set_label("First");
  m_second.set_label("Second");

  m_second.set_group(m_first);
  m_first.set_active();

  // Main Container:
  m_container.set_orientation(Gtk::Orientation::HORIZONTAL);
  m_container.append(m_first);
  m_container.append(m_second);

  // Events.
  auto controller = Gtk::EventControllerKey::create();
  controller-&gt;signal_key_pressed().connect(
    sigc::mem_fun(*this, &amp;ExampleWindow::on_window_key_pressed), false);
  add_controller(controller);
}

bool ExampleWindow::on_window_key_pressed(guint keyval, guint, Gdk::ModifierType state)
{
  //Gdk::ModifierType::ALT_MASK -&gt; the 'Alt' key(mask)
  //GDK_KEY_1 -&gt; the '1' key
  //GDK_KEY_2 -&gt; the '2' key

  //select the first radio button, when we press alt + 1
  if((keyval == GDK_KEY_1) &amp;&amp;
    (state &amp; (Gdk::ModifierType::SHIFT_MASK | Gdk::ModifierType::CONTROL_MASK | Gdk::ModifierType::ALT_MASK)) == Gdk::ModifierType::ALT_MASK)
  {
    m_first.set_active();
    //returning true, cancels the propagation of the event
    return true;
  }
  else if((keyval == GDK_KEY_2) &amp;&amp;
    (state &amp; (Gdk::ModifierType::SHIFT_MASK | Gdk::ModifierType::CONTROL_MASK | Gdk::ModifierType::ALT_MASK)) == Gdk::ModifierType::ALT_MASK)
  {
    //and the second radio button, when we press alt + 2
    m_second.set_active();
    return true;
  }
  else if(keyval == GDK_KEY_Escape)
  {
    //close the window, when the 'esc' key is pressed
    hide();
    return true;
  }

  //the event has not been handled
  return false;
}

ExampleWindow::~ExampleWindow()
{
}

</pre></div>
</div>
</div>
<div class="division sect1">
<a name="sec-keyboardevents-propagation"><!--sec-keyboardevents-propagation--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">21.2. </span>Event Propagation</span></h3></div>
<p class="para block block-first">
      Event propagation means that, when an event is emitted on a particular
      widget, it can be passed to its parent widget (and that widget can pass
      it to its parent, and so on) and, if the parent has an event handler,
      that handler will be called. 
    </p>
<p class="para block">
      Contrary to other events, keyboard events are first sent to the toplevel window
      (<span class="classname" dir="ltr">Gtk::Window</span>), where it will be checked
      for any keyboard shortcuts that may be set (accelerator keys and mnemonics,
      used for selecting menu items from the keyboard). After this (and assuming
      the event wasn't handled), it is sent to the widget which has focus,
      and the propagation begins from there.
    </p>
<p class="para block">
      The event will propagate until it reaches the top-level widget, or until
      you stop the propagation by returning <span class="literal" dir="ltr">true</span> from an
      event handler.
    </p>
<p class="para block">
      Notice, that after canceling an event, no other function will be called
      (even if it is from the same widget).
    </p>
<div class="autotoc"><ul><li>
<span class="label">21.2.1. </span><a class="xref" href="#keyboardevents-propagation-example" title="Example">Example</a>
</li></ul></div>
<div class="division sect2">
<a name="keyboardevents-propagation-example"><!--keyboardevents-propagation-example--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">21.2.1. </span>Example</span></h4></div>
<p class="para block block-first">
        In this example there are three event handlers that are called after
        <span class="classname" dir="ltr">Gtk::Window</span>'s default event handler, one in the
        <span class="classname" dir="ltr">Gtk::Entry</span>, one in the <span class="classname" dir="ltr">Gtk::Grid</span>
        and one in the <span class="classname" dir="ltr">Gtk::Window</span>.
      </p>
<p class="para block">
        In the <span class="classname" dir="ltr">Gtk::Window</span>, we have also the default handler
        overridden (<span class="methodname" dir="ltr">on_key_release_event()</span>), and
        another handler being called before the default handler
        (<span class="methodname" dir="ltr">windowKeyReleaseBefore()</span>).
      </p>
<p class="para block">
        The purpose of this example is to show the steps the event takes when it is emitted.
      </p>
<p class="para block">
        When you write in the entry, a key release event will be emitted,
        which will go first to the toplevel window (<span class="classname" dir="ltr">Gtk::Window</span>),
        since we have one event handler set to be called before, that's what is
        called first (<span class="methodname" dir="ltr">windowKeyReleaseBefore()</span>).
        Then the default handler is called (which we have overridden), and after
        that the event is sent to the widget that has focus,
        the <span class="classname" dir="ltr">Entry</span> in our example and, depending on whether we let
        it propagate, it can reach the <span class="classname" dir="ltr">Grid</span>'s and the
        <span class="classname" dir="ltr">Window</span>'s event handlers. If it propagates,
        the text you're writing will appear in the <span class="classname" dir="ltr">Label</span>
        above the <span class="classname" dir="ltr">Entry</span>.
      </p>
<div class=" block figure block-indent">
<a name="figure-keyboardevents-propagation"><!--figure-keyboardevents-propagation--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 21-2</span> </span>Keyboard Events - Event Propagation</span></div>
<div class="figure-inner">
        
        <div class=" block screenshot block-first">
          <div class="graphic"><img src="figures/keyboardevents_propagation.png.en"></div>
        </div>
      </div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/keyboard_events/propagation/" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/keyboard_events/propagation/">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EVENT_PROPAGATION_H
#define GTKMM_EVENT_PROPAGATION_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:

  ExampleWindow();
  virtual ~ExampleWindow();

private:
  // Signal handlers:
  bool label2_key_pressed(guint keyval, guint keycode, Gdk::ModifierType state, const Glib::ustring&amp; phase);
  bool grid_key_pressed(guint keyval, guint keycode, Gdk::ModifierType state, const Glib::ustring&amp; phase);
  bool window_key_pressed(guint keyval, guint keycode, Gdk::ModifierType state, const Glib::ustring&amp; phase);

  bool m_first = true;
  Gtk::Box m_container;
  Gtk::Frame m_frame;
  Gtk::Label m_label1;
  Gtk::Label m_label2;
  Gtk::CheckButton m_checkbutton_can_propagate_down;
  Gtk::CheckButton m_checkbutton_can_propagate_up;
};

#endif //GTKMM_EVENT_PROPAGATION_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;gtkmm/application.h&gt;

int main(int argc, char *argv[])
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  //Shows the window and returns when it is closed.
  return app-&gt;make_window_and_run&lt;ExampleWindow&gt;(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;iostream&gt;

ExampleWindow::ExampleWindow()
:
m_label1("A label"),
m_label2("Write here"),
m_checkbutton_can_propagate_down("Can propagate down"),
m_checkbutton_can_propagate_up("Can propagate up")
{
  set_title("Event Propagation");
  m_container.set_margin(10);
  set_child(m_container);

  m_frame.set_child(m_label2);
  m_label2.set_selectable();
  m_checkbutton_can_propagate_down.set_active();
  m_checkbutton_can_propagate_up.set_active();

  // Main container
  m_container.set_orientation(Gtk::Orientation::VERTICAL);
  m_container.append(m_label1);
  m_container.append(m_frame);
  m_container.append(m_checkbutton_can_propagate_down);
  m_container.append(m_checkbutton_can_propagate_up);

  // Events
  const bool after = false; // Run before or after the default signal handlers.

  // Called in the capture phase of the event handling.
  auto controller = Gtk::EventControllerKey::create();
  controller-&gt;set_propagation_phase(Gtk::PropagationPhase::CAPTURE);
  controller-&gt;signal_key_pressed().connect(
    sigc::bind(sigc::mem_fun(*this, &amp;ExampleWindow::label2_key_pressed), "capture"), after);
  m_label2.add_controller(controller);

  controller = Gtk::EventControllerKey::create();
  controller-&gt;set_propagation_phase(Gtk::PropagationPhase::CAPTURE);
  controller-&gt;signal_key_pressed().connect(
    sigc::bind(sigc::mem_fun(*this, &amp;ExampleWindow::grid_key_pressed), "capture"), after);
  m_container.add_controller(controller);

  controller = Gtk::EventControllerKey::create();
  controller-&gt;set_propagation_phase(Gtk::PropagationPhase::CAPTURE);
  controller-&gt;signal_key_pressed().connect(
    sigc::bind(sigc::mem_fun(*this, &amp;ExampleWindow::window_key_pressed), "capture"), after);
  add_controller(controller);

  // Called in the target phase of the event handling.
  controller = Gtk::EventControllerKey::create();
  controller-&gt;set_propagation_phase(Gtk::PropagationPhase::TARGET);
  controller-&gt;signal_key_pressed().connect(
    sigc::bind(sigc::mem_fun(*this, &amp;ExampleWindow::label2_key_pressed), "target"), after);
  m_label2.add_controller(controller);

  controller = Gtk::EventControllerKey::create();
  controller-&gt;set_propagation_phase(Gtk::PropagationPhase::TARGET);
  controller-&gt;signal_key_pressed().connect(
    sigc::bind(sigc::mem_fun(*this, &amp;ExampleWindow::grid_key_pressed), "target"), after);
  m_container.add_controller(controller);

  controller = Gtk::EventControllerKey::create();
  controller-&gt;set_propagation_phase(Gtk::PropagationPhase::TARGET);
  controller-&gt;signal_key_pressed().connect(
    sigc::bind(sigc::mem_fun(*this, &amp;ExampleWindow::window_key_pressed), "target"), after);
  add_controller(controller);

  // Called in the bubble phase of the event handling.
  // This is the default, if set_propagation_phase() is not called.
  controller = Gtk::EventControllerKey::create();
  controller-&gt;set_propagation_phase(Gtk::PropagationPhase::BUBBLE);
  controller-&gt;signal_key_pressed().connect(
    sigc::bind(sigc::mem_fun(*this, &amp;ExampleWindow::label2_key_pressed), "bubble"), after);
  m_label2.add_controller(controller);

  controller = Gtk::EventControllerKey::create();
  controller-&gt;set_propagation_phase(Gtk::PropagationPhase::BUBBLE);
  controller-&gt;signal_key_pressed().connect(
    sigc::bind(sigc::mem_fun(*this, &amp;ExampleWindow::grid_key_pressed), "bubble"), after);
  m_container.add_controller(controller);

  controller = Gtk::EventControllerKey::create();
  controller-&gt;set_propagation_phase(Gtk::PropagationPhase::BUBBLE);
  controller-&gt;signal_key_pressed().connect(
    sigc::bind(sigc::mem_fun(*this, &amp;ExampleWindow::window_key_pressed), "bubble"), after);
  add_controller(controller);
}

// By changing the return value we allow, or don't allow, the event to propagate to other elements.
bool ExampleWindow::label2_key_pressed(guint keyval, guint, Gdk::ModifierType, const Glib::ustring&amp; phase)
{
  std::cout &lt;&lt; "Label,  " &lt;&lt; phase &lt;&lt; " phase" &lt;&lt; std::endl;

  if (phase == "bubble")
  {
    const gunichar unichar = gdk_keyval_to_unicode(keyval);
    if (unichar != 0)
    {
      if (m_first)
      {
        m_label2.set_label("");
        m_first = false;
      }
      if (unichar == '\b')
        m_label2.set_label("");
      else
      {
        const Glib::ustring newchar(1, unichar);
        m_label2.set_label(m_label2.get_label() + newchar);
      }
    }

    if (!m_checkbutton_can_propagate_up.get_active())
      return true; // Don't propagate
  }
  return false;
}

bool ExampleWindow::grid_key_pressed(guint, guint, Gdk::ModifierType, const Glib::ustring&amp; phase)
{
  std::cout &lt;&lt; "Grid,   " &lt;&lt; phase &lt;&lt; " phase" &lt;&lt; std::endl;

  // Let it propagate
  return false;
}

// This will set the second label's text in the first label every time a key is pressed.
bool ExampleWindow::window_key_pressed(guint, guint, Gdk::ModifierType, const Glib::ustring&amp; phase)
{
  if (phase == "capture")
    std::cout &lt;&lt; std::endl;
  std::cout &lt;&lt; "Window, " &lt;&lt; phase &lt;&lt; " phase";

  // Checking if the second label is on focus, otherwise the label would get
  // changed by pressing keys on the window (when the label is not on focus),
  // even if m_checkbutton_can_propagate_up wasn't active.
  if (phase == "bubble" &amp;&amp; m_label2.has_focus())
  {
    m_label1.set_text(m_label2.get_text());
    std::cout &lt;&lt; ", " &lt;&lt; m_label2.get_text();
  }
  std::cout &lt;&lt; std::endl;

  if (phase == "capture" &amp;&amp; !m_checkbutton_can_propagate_down.get_active())
    return true; // Don't propagate
  return false;
}

ExampleWindow::~ExampleWindow()
{
}

</pre></div>
</div>
</div>
</div>
<div class="division chapter">
<a name="chapter-chapter-timeouts"><!--chapter-chapter-timeouts--></a><div class="header"><h2 class="chapter title"><span class="title"><span class="label">22. </span>Timeouts, I/O and Idle Functions </span></h2></div>
<div class="autotoc"><ul>
<li>
<span class="label">22.1. </span><a class="xref" href="#sec-timeouts" title="Timeouts">Timeouts</a>
</li>
<li>
<span class="label">22.2. </span><a class="xref" href="#sec-monitoring-io" title="Monitoring I/O">Monitoring I/O</a>
</li>
<li>
<span class="label">22.3. </span><a class="xref" href="#sec-idle-functions" title="Idle Functions">Idle Functions</a>
</li>
</ul></div>
<div class="division sect1">
<a name="sec-timeouts"><!--sec-timeouts--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">22.1. </span>Timeouts</span></h3></div>
<p class="para block block-first">
You may be wondering how to make <span class="application">gtkmm</span> do useful work while it's idling along. Happily,
you have several options. Using the following methods you can create a timeout
method that will be called every few milliseconds.
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">sigc::connection Glib::SignalTimeout::connect(const sigc::slot&lt;bool()&gt;&amp; slot,
                                      unsigned int interval, int priority = Glib::PRIORITY_DEFAULT);
</pre></div>
<p class="para block">
The first argument is a <span class="classname" dir="ltr">slot</span> you wish to have called
when the timeout occurs. The second argument is the number of milliseconds
between calls to that method. You receive a
<span class="classname" dir="ltr">sigc::connection</span> object that can be used to deactivate
the connection using its <span class="methodname" dir="ltr">disconnect()</span> method:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">my_connection.disconnect();
</pre></div>
<p class="para block">
Another way of destroying the connection is your signal handler.
It has to be of the type <span class="classname" dir="ltr">sigc::slot&lt;bool()&gt;</span>.
As you see from the definition your signal handler has to return a value of
the type <span class="literal" dir="ltr">bool</span>. A definition of a sample method might
look like this:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">bool MyCallback() { std::cout &lt;&lt; "Hello World!\n" &lt;&lt; std::endl; return true; }
</pre></div>
<p class="para block">
You can stop the timeout method by returning <span class="literal" dir="ltr">false</span> from
your signal handler. Therefore, if you want your
method to be called repeatedly, it should return <span class="literal" dir="ltr">true</span>.
</p>
<p class="para block">
Here's an example of this technique:
</p>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/timeout/" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/timeout/">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">timerexample.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLE_TIMEREXAMPLE_H
#define GTKMM_EXAMPLE_TIMEREXAMPLE_H

#include &lt;gtkmm.h&gt;
#include &lt;iostream&gt;
#include &lt;map&gt;

class TimerExample : public Gtk::Window
{
public:
  TimerExample();

protected:
  // signal handlers
  void on_button_add_timer();
  void on_button_delete_timer();
  void on_button_quit();

  // This is the callback function the timeout will call
  bool on_timeout(int timer_number);

  // Member data:

  Gtk::Box m_Box;
  Gtk::Button m_ButtonAddTimer, m_ButtonDeleteTimer, m_ButtonQuit;

  // Keep track of the timers being added:
  int m_timer_number;

  // These two constants are initialized in the constructor's member initializer:
  const int count_value;
  const int timeout_value;

  // STL map for storing our connections
  std::map&lt;int, sigc::connection&gt; m_timers;

  // STL map for storing our timer values.
  // Each timer counts back from COUNT_VALUE to 0 and is removed when it reaches 0
  std::map&lt;int, int&gt; m_counters;
};

#endif // GTKMM_EXAMPLE_TIMEREXAMPLE_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "timerexample.h"
#include &lt;gtkmm/application.h&gt;

int main (int argc, char *argv[])
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  return app-&gt;make_window_and_run&lt;TimerExample&gt;(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">timerexample.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "timerexample.h"

TimerExample::TimerExample() :
  m_Box(Gtk::Orientation::HORIZONTAL, 10),
  m_ButtonAddTimer("_Add", true),
  m_ButtonDeleteTimer("_Remove", true),
  m_ButtonQuit("_Quit", true),
  m_timer_number(0), // start numbering the timers at 0
  count_value(5), // each timer will count down 5 times before disconnecting
  timeout_value(1500) // 1500 ms = 1.5 seconds
{
  m_Box.set_margin(10);
  set_child(m_Box);
  m_Box.append(m_ButtonAddTimer);
  m_Box.append(m_ButtonDeleteTimer);
  m_Box.append(m_ButtonQuit);
  m_ButtonAddTimer.set_expand();
  m_ButtonDeleteTimer.set_expand();
  m_ButtonQuit.set_expand();

  // Connect the three buttons:
  m_ButtonQuit.signal_clicked().connect(sigc::mem_fun(*this,
              &amp;TimerExample::on_button_quit));
  m_ButtonAddTimer.signal_clicked().connect(sigc::mem_fun(*this,
              &amp;TimerExample::on_button_add_timer));
  m_ButtonDeleteTimer.signal_clicked().connect(sigc::mem_fun(*this,
              &amp;TimerExample::on_button_delete_timer));
}

void TimerExample::on_button_quit()
{
  hide();
}

void TimerExample::on_button_add_timer()
{
  // Creation of a new object prevents long lines and shows us a little
  // how slots work.  We have 0 parameters and bool as a return value
  // after calling sigc::bind.
  sigc::slot&lt;bool()&gt; my_slot = sigc::bind(sigc::mem_fun(*this,
              &amp;TimerExample::on_timeout), m_timer_number);

  // This is where we connect the slot to the Glib::signal_timeout()
  auto conn = Glib::signal_timeout().connect(my_slot,
          timeout_value);

  // Remember the connection:
  m_timers[m_timer_number] = conn;

  // Initialize timer count:
  m_counters[m_timer_number] = count_value + 1;

  // Print some info to the console for the user:
  std::cout &lt;&lt; "added timeout " &lt;&lt; m_timer_number++ &lt;&lt; std::endl;
}

void TimerExample::on_button_delete_timer()
{
  // any timers?
  if(m_timers.empty())
  {
    // no timers left
    std::cout &lt;&lt; "Sorry, there are no timers left." &lt;&lt; std::endl;
  }
  else
  {
    // get the number of the first timer
    int timer_number = m_timers.begin()-&gt;first;

    // Give some info to the user:
    std::cout &lt;&lt; "manually disconnecting timer " &lt;&lt; timer_number
        &lt;&lt; std::endl;

    // Remove the entry in the counter values
    m_counters.erase(timer_number);

    // Diconnect the signal handler:
    m_timers[timer_number].disconnect();

    // Forget the connection:
    m_timers.erase(timer_number);
  }
}

bool TimerExample::on_timeout(int timer_number)
{
  // Print the timer:
  std::cout &lt;&lt; "This is timer " &lt;&lt; timer_number;

  // decrement and check counter value
  if (--m_counters[timer_number] == 0)
  {
    std::cout &lt;&lt; " being disconnected" &lt;&lt;  std::endl;

    // delete the counter entry in the STL MAP
    m_counters.erase(timer_number);

    // delete the connection entry in the STL MAP
    m_timers.erase(timer_number);

    // Note that we do not have to explicitly call disconnect() on the
    // connection since Gtk::Main does this for us when we return false.
    return false;
  }

  // Print the timer value
  std::cout &lt;&lt; " - " &lt;&lt; m_counters[timer_number] &lt;&lt; "/"
      &lt;&lt; count_value &lt;&lt; std::endl;

 // Keep going (do not disconnect yet):
  return true;
}
</pre></div>
</div>
<div class="division sect1">
<a name="sec-monitoring-io"><!--sec-monitoring-io--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">22.2. </span>Monitoring I/O</span></h3></div>
<p class="para block block-first">
A nifty feature of Glib (one of the libraries underlying
<span class="application">gtkmm</span>) is the ability to have it check for data on a file descriptor
for you. This is especially useful for networking applications. The
following method is used to do this:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">sigc::connection Glib::SignalIO::connect(const sigc::slot&lt;bool(Glib::IOCondition)&gt;&amp; slot,
                                 Glib::PollFD::fd_t fd, Glib::IOCondition condition,
                                 int priority = Glib::PRIORITY_DEFAULT);
</pre></div>
<p class="para block">
The first argument is a slot you wish to have called when
the specified event (see argument 3) occurs on the file descriptor you specify
using argument two. Argument three may be one or more (using
<span class="literal" dir="ltr">|</span>) of:
</p>
<div class="block list itemizedlist"><ul class="itemizedlist">
<li class="li-first">

<span class="para">
Glib::IO_IN - Call your method when there is data ready for
reading on your file descriptor.

</span>
</li>
<li>

<span class="para">
Glib::IO_OUT - Call your method when the file descriptor is
ready for writing.

</span>
</li>
<li>

<span class="para">
Glib::IO_PRI - Call your method when the file descriptor has urgent data to be read.

</span>
</li>
<li>

<span class="para">
Glib::IO_ERR - Call your method when an error has occurred on the file descriptor.

</span>
</li>
<li>

<span class="para">
Glib::IO_HUP - Call your method when hung up (the connection has been broken usually for pipes and sockets).
</span>
</li>
</ul></div>
<p class="para block">
    The return value is a <span class="classname" dir="ltr">sigc::connection</span> that may be used to stop monitoring
this file descriptor using its <span class="methodname" dir="ltr">disconnect()</span> method. The
<span class="parameter" dir="ltr">slot</span> signal handler should be declared as follows:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">bool input_callback(Glib::IOCondition condition);
</pre></div>
<p class="para block">
where <span class="parameter" dir="ltr">condition</span> is as
specified above. As usual the slot is created with
<span class="function">sigc::mem_fun()</span> (for a member method of an object), or
<span class="function">sigc::ptr_fun()</span> (for a function).
</p>
<p class="para block">
A little example follows. To use the example just execute it from a terminal;
it doesn't create a window. It will create a pipe named
<span class="literal" dir="ltr">testfifo</span> in the current directory. Then start another shell
and execute <span class="literal" dir="ltr">echo "Hello" &gt; testfifo</span>. The example will
print each line you enter until you execute <span class="literal" dir="ltr">echo "Q" &gt;
testfifo</span>.
</p>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/input/" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/input/">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include &lt;gtkmm/application.h&gt;
#include &lt;glibmm/main.h&gt;
#include &lt;glibmm/iochannel.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;iostream&gt;

#include &lt;unistd.h&gt; //The SUN Forte compiler puts F_OK here.

//The SUN Forte compiler needs these for mkfifo:
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;

Glib::RefPtr&lt;Gtk::Application&gt; app;

int read_fd;
Glib::RefPtr&lt;Glib::IOChannel&gt; iochannel;

/*
  send to the fifo with:
  echo "Hello" &gt; testfifo

  quit the program with:
  echo "Q" &gt; testfifo
*/

// this will be our signal handler for read operations
// it will print out the message sent to the fifo
// and quit the program if the message was 'Q'.
bool MyCallback(Glib::IOCondition io_condition)
{
  if ((io_condition &amp; Glib::IOCondition::IO_IN) != Glib::IOCondition::IO_IN) {
    std::cerr &lt;&lt; "Invalid fifo response" &lt;&lt; std::endl;
  }
  else {
   Glib::ustring buf;

   iochannel-&gt;read_line(buf);
   std::cout &lt;&lt; buf;
   if (buf == "Q\n")
     app-&gt;quit();

  }
  return true;
}


int main(int argc, char *argv[])
{
  app = Gtk::Application::create("org.gtkmm.example");

  if (access("testfifo", F_OK) == -1) {
    // fifo doesn't exist - create it
    #ifndef DONT_HAVE_MKFIFO
    if (mkfifo("testfifo", 0666) != 0) {
      std::cerr &lt;&lt; "error creating fifo" &lt;&lt; std::endl;
      return -1;
    }
    #else
      std::cerr &lt;&lt; "error creating fifo: This platform does not have mkfifo()"
          &lt;&lt; std::endl;
    #endif //DONT_HAVE_MKFIFO
  }

  // Although we will only read from the fifo, we open it in read/write mode.
  // Due to a peculiarity with the poll() system call, used deep down in glib,
  // this small program will use all available CPU time, if the fifo is opened
  // as O_RDONLY. See a discussion on the gtkmm-list, e.g.
  // https://mail.gnome.org/archives/gtkmm-list/2015-September/msg00034.html
  // and the link from there to stackoverflow.
  read_fd = open("testfifo", O_RDWR);
  if (read_fd == -1)
  {
    std::cerr &lt;&lt; "error opening fifo" &lt;&lt; std::endl;
    return -1;
  }

  // connect the signal handler
  Glib::signal_io().connect(sigc::ptr_fun(MyCallback), read_fd, Glib::IOCondition::IO_IN);

  // Creates a iochannel from the file descriptor
  iochannel = Glib::IOChannel::create_from_fd(read_fd);

  // and last but not least - run the application main loop
  app-&gt;hold(); // keep the application running without a window
  app-&gt;run(argc, argv);

  // now remove the temporary fifo
  if(unlink("testfifo"))
    std::cerr &lt;&lt; "error removing fifo" &lt;&lt; std::endl;

  return 0;
}
</pre></div>
</div>
<div class="division sect1">
<a name="sec-idle-functions"><!--sec-idle-functions--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">22.3. </span>Idle Functions</span></h3></div>
<p class="para block block-first">
If you want to specify a method that gets called when nothing else is happening, use the following:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">sigc::connection  Glib::SignalIdle::connect(const sigc::slot&lt;bool()&gt;&amp; slot,
                                    int priority = Glib::PRIORITY_DEFAULT_IDLE);
</pre></div>
<p class="para block">
This causes <span class="application">gtkmm</span> to call the specified method whenever nothing else is
happening. You can add a priority (lower numbers are higher priorities). There are two ways to remove the signal handler: calling
<span class="methodname" dir="ltr">disconnect()</span> on the
<span class="classname" dir="ltr">sigc::connection</span> object, or returning
<span class="literal" dir="ltr">false</span> in the signal handler, which should be declared
as follows:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">bool idleFunc();
</pre></div>
<p class="para block">
Since this is very similar to the methods above this explanation should
be sufficient to understand what's going on. However, here's a little example:
</p>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/idle/" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/idle/">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">idleexample.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLE_IDLEEXAMPLE_H
#define GTKMM_EXAMPLE_IDLEEXAMPLE_H

#include &lt;gtkmm.h&gt;
#include &lt;iostream&gt;

class IdleExample : public Gtk::Window
{
public:
  IdleExample();

protected:
  // Signal Handlers:
  bool on_timer();
  bool on_idle();
  void on_button_clicked();

  // Member data:
  Gtk::Box m_Box;
  Gtk::Button m_ButtonQuit;
  Gtk::ProgressBar m_ProgressBar_c;
  Gtk::ProgressBar m_ProgressBar_d;
};

#endif // GTKMM_EXAMPLE_IDLEEXAMPLE_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "idleexample.h"
#include &lt;gtkmm/application.h&gt;

int main (int argc, char *argv[])
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  return app-&gt;make_window_and_run&lt;IdleExample&gt;(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">idleexample.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "idleexample.h"

IdleExample::IdleExample() :
  m_Box(Gtk::Orientation::VERTICAL, 5),
  m_ButtonQuit("_Quit", true)
{
  m_Box.set_margin(5);

  // Put buttons into container

  // Adding a few widgets:
  set_child(m_Box);
  m_Box.append(*Gtk::make_managed&lt;Gtk::Label&gt;("Formatting Windows drive C:"));
  m_Box.append(*Gtk::make_managed&lt;Gtk::Label&gt;("100 MB"));
  m_Box.append(m_ProgressBar_c);
  m_ProgressBar_c.set_expand();

  m_Box.append(*Gtk::make_managed&lt;Gtk::Label&gt;(""));

  m_Box.append(*Gtk::make_managed&lt;Gtk::Label&gt;("Formatting Windows drive D:"));
  m_Box.append(*Gtk::make_managed&lt;Gtk::Label&gt;("5000 MB"));
  m_Box.append(m_ProgressBar_d);
  m_ProgressBar_d.set_expand();

  auto hbox = Gtk::make_managed&lt;Gtk::Box&gt;(Gtk::Orientation::HORIZONTAL,10);
  m_Box.append(*hbox);
  hbox-&gt;append(m_ButtonQuit);
  m_ButtonQuit.set_expand();
  m_ButtonQuit.set_halign(Gtk::Align::END);
  m_ButtonQuit.set_valign(Gtk::Align::END);

  // Connect the signal handlers:
  m_ButtonQuit.signal_clicked().connect( sigc::mem_fun(*this,
              &amp;IdleExample::on_button_clicked) );

  // formatting drive c in timeout signal handler - called once every 50ms
  Glib::signal_timeout().connect( sigc::mem_fun(*this, &amp;IdleExample::on_timer),
          50 );

  // formatting drive d in idle signal handler - called as quickly as possible
  Glib::signal_idle().connect( sigc::mem_fun(*this, &amp;IdleExample::on_idle) );
}


void IdleExample::on_button_clicked()
{
  hide();
}

// this timer callback function is executed once every 50ms (set in connection
// above).  Use timeouts when speed is not critical. (ie periodically updating
// something).
bool IdleExample::on_timer()
{
  double value = m_ProgressBar_c.get_fraction();

  // Update progressbar 1/500th each time:
  m_ProgressBar_c.set_fraction(value + 0.002);

  return value &lt; 0.99;  // return false when done
}


// This idle callback function is executed as often as possible, hence it is
// ideal for processing intensive tasks.
bool IdleExample::on_idle()
{
  double value = m_ProgressBar_d.get_fraction();

  // Update progressbar 1/5000th each time:
  m_ProgressBar_d.set_fraction(value + 0.0002);

  return value &lt; 0.99;  // return false when done
}
</pre></div>
<p class="para block">
This example points out the difference of idle and timeout methods a
little. If you need methods that are called periodically, and speed
is not very important, then you want timeout methods. If
you want methods that are called as often as possible (like
calculating a fractal in background), then use idle methods.
</p>
<p class="para block">
Try executing the example and increasing the system load. The upper
progress bar will increase steadily; the lower one will slow down.
</p>
</div>
</div>
<div class="division chapter">
<a name="chapter-memory"><!--chapter-memory--></a><div class="header"><h2 class="chapter title"><span class="title"><span class="label">23. </span>Memory management</span></h2></div>
<div class="autotoc"><ul>
<li>
<span class="label">23.1. </span><a class="xref" href="#sec-memory-widgets" title="Widgets">Widgets</a>
</li>
<li>
<span class="label">23.2. </span><a class="xref" href="#sec-memory-shared-resources" title="Shared resources">Shared resources</a>
</li>
</ul></div>
<div class="division sect1">
<a name="sec-memory-widgets"><!--sec-memory-widgets--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">23.1. </span>Widgets</span></h3></div>
<div class="autotoc"><ul>
<li>
<span class="label">23.1.1. </span><a class="xref" href="#memory-normal" title="Normal C++ memory management">Normal C++ memory management</a>
</li>
<li>
<span class="label">23.1.2. </span><a class="xref" href="#memory-managed-widgets" title="Managed Widgets">Managed Widgets</a>
</li>
</ul></div>
<div class="division sect2">
<a name="memory-normal"><!--memory-normal--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">23.1.1. </span>Normal C++ memory management</span></h4></div>
<p class="para block block-first">
<span class="application">gtkmm</span> allows the programmer to control the lifetime (that is, the construction
and destruction) of any widget in the same manner as any other C++ object.
This flexibility allows you to use <span class="literal" dir="ltr">new</span> and
<span class="literal" dir="ltr">delete</span> to create and destroy objects dynamically
or to use regular class members (that are destroyed automatically when the
class is destroyed) or to use local instances (that are destroyed when the
instance goes out of scope). This flexibility is not present in some C++ GUI
toolkits, which restrict the programmer to only a subset of C++'s memory
management features.
</p>
<p class="para block">Here are some examples of normal C++ memory management:</p>
<div class="autotoc"><ul>
<li>
<span class="label">23.1.1.1. </span><a class="xref" href="#memory-class-scope" title="Class Scope widgets">Class Scope widgets</a>
</li>
<li>
<span class="label">23.1.1.2. </span><a class="xref" href="#memory-function-scope" title="Function scope widgets">Function scope widgets</a>
</li>
<li>
<span class="label">23.1.1.3. </span><a class="xref" href="#memory-dynamic-allocation" title="Dynamic allocation with new and delete">Dynamic allocation with new and delete</a>
</li>
</ul></div>
<div class="division sect3">
<a name="memory-class-scope"><!--memory-class-scope--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">23.1.1.1. </span>Class Scope widgets</span></h5></div>
<p class="para block block-first">
If a programmer does not need dynamic memory allocation, automatic widgets in class
scope may be used. One advantage of automatic widgets in class scope is that
memory management is grouped in one place. The programmer does not
risk memory leaks from failing to <span class="literal" dir="ltr">delete</span> a widget.
</p>
<p class="para block">
The primary disadvantage of using class scope widgets is revealing
the class implementation rather than the class interface in the class header.
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include &lt;gtkmm/button.h&gt;
#include &lt;gtkmm/window.h&gt;
class Foo : public Gtk::Window
{
private:
  Gtk::Button theButton;
  // will be destroyed when the Foo object is destroyed
};
</pre></div>
</div>
<div class="division sect3">
<a name="memory-function-scope"><!--memory-function-scope--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">23.1.1.2. </span>Function scope widgets</span></h5></div>
<p class="para block block-first">
If a programmer does not need a class scope widget, a function scope widget
may also be used. The advantages to function scope over class scope are the
increased data hiding and reduced dependencies.
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">{
  Gtk::Button aButton;
  aButton.show();
  ...
  app-&gt;run();
}
</pre></div>
</div>
<div class="division sect3">
<a name="memory-dynamic-allocation"><!--memory-dynamic-allocation--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">23.1.1.3. </span>Dynamic allocation with new and delete</span></h5></div>
<p class="para block block-first">
Usually, the programmer will prefer to allow containers to automatically destroy
their children by creating them using <span class="function">Gtk::make_managed()</span>
(see below). This is not strictly required, as the <span class="literal" dir="ltr">new</span> and
<span class="literal" dir="ltr">delete</span> operators may also be used, but modern C++ style
discourages those in favour of safer models of memory management, so it is
better to create widgets using <span class="function">Gtk::make_managed()</span> and
let their parent destroy them, than to manually perform dynamic allocation.
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">auto pButton = new Gtk::Button("Test");

// do something useful with pButton

delete pButton;
</pre></div>
Here, the programmer deletes <span class="varname" dir="ltr">pButton</span> to prevent a memory leak.
</p>
</div>
</div>
<div class="division sect2">
<a name="memory-managed-widgets"><!--memory-managed-widgets--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">23.1.2. </span>Managed Widgets</span></h4></div>
<p class="para block block-first">
Alternatively, you can let a widget's container control when the widget is
destroyed. In most cases, you want a widget to last only as long as the
container it is in. To delegate the management of a widget's lifetime to its
container, create it with <span class="function">Gtk::make_managed()</span> and then
pack it into its container with <span class="methodname" dir="ltr">Gtk::Box::append()</span> or
a similar method. Now the widget will be destroyed whenever its container is destroyed.
</p>
<div class="autotoc"><ul><li>
<span class="label">23.1.2.1. </span><a class="xref" href="#memory-managed-dynamic" title="Dynamic allocation with make_managed() and append()">Dynamic allocation with make_managed() and append()</a>
</li></ul></div>
<div class="division sect3">
<a name="memory-managed-dynamic"><!--memory-managed-dynamic--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">23.1.2.1. </span>Dynamic allocation with make_managed() and append()</span></h5></div>
<p class="para block block-first">
<span class="application">gtkmm</span> provides ways including the <span class="function">make_managed()</span> function
and <span class="methodname" dir="ltr">Gtk::Box::append()</span> method to simplify creation
and destruction of widgets whose lifetime can be managed by a parent.
</p>
<p class="para block">
Every widget except a top-level window must be added to a parent container in
order to be displayed. The <span class="function">manage()</span> function marks a widget
so that when that widget is added to a parent container, said container becomes
responsible for deleting the widget, meaning the user no longer needs to do so.
The original way to create widgets whose lifetime is managed by their parent in
this way was to call <span class="function">manage()</span>, passing in the result of a
<span class="literal" dir="ltr">new</span> expression that created a dynamically allocated widget.
</p>
<p class="para block">
However, usually, when you create such a widget, you will already know that its
parent container should be responsible for destroying it, In addition, modern
C++ style discourages use of the <span class="literal" dir="ltr">new</span> operator, which was
required when passing a newly created widget to <span class="function">manage()</span>.
Therefore, <span class="application">gtkmm</span> has added <span class="function">make_managed()</span>, which combines
creation and marking with <span class="function">manage()</span> into a single step. This
avoids you having to write <span class="literal" dir="ltr">new</span>, which is discouraged in
modern C++ style, and more clearly expresses intent to create a managed widget.
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">MyContainer::MyContainer()
{
  auto pButton = Gtk::make_managed&lt;Gtk::Button&gt;("Test");
  append(*pButton); //add *pButton to MyContainer
}
</pre></div>
<p class="para block">
Now, when objects of type <span class="classname" dir="ltr">MyContainer</span> are destroyed, the
button will also be deleted. It is no longer necessary to delete <span class="varname" dir="ltr">pButton</span>
to free the button's memory; its deletion has been delegated to the
<span class="classname" dir="ltr">MyContainer</span> object.
</p>
<p class="para block">
Note that if you never added the widget to any parent container, or you did but
later <span class="methodname" dir="ltr">Gtk::Container::remove()</span>d it from said parent,
<span class="application">gtkmm</span> restores the widget’s lifetime management to whatever state it had
before <span class="function">manage()</span> was called, which typically means that the
responsibility for <span class="literal" dir="ltr">delete</span>ing the widget returns to the user.
</p>
<p class="para block">
Of course, a top-level container will not be added to another container. The
programmer is responsible for destroying the top-level container using one of
the traditional C++ techniques. For instance, your top-level Window might just
be an instance in your <span class="function">main()</span> function.
</p>
</div>
</div>
</div>
<div class="division sect1">
<a name="sec-memory-shared-resources"><!--sec-memory-shared-resources--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">23.2. </span>Shared resources</span></h3></div>
<p class="para block block-first">
Some objects, such as <span class="classname" dir="ltr">Gdk::Pixbuf</span>s and
<span class="classname" dir="ltr">Pango::Font</span>s, are obtained from a shared store.
Therefore you cannot instantiate your own instances. These classes typically
inherit from <span class="classname" dir="ltr">Glib::Object</span>. Rather than requiring you to
reference and unreference these objects, <span class="application">gtkmm</span> uses the
<span class="classname" dir="ltr">Glib::RefPtr&lt;&gt;</span> smartpointer. Cairomm has its own
smartpointer, <span class="classname" dir="ltr">Cairo::RefPtr&lt;&gt;</span>.
</p>
<p class="para block">
Objects such as <span class="classname" dir="ltr">Gdk::Pixbuf</span> can only be instantiated
with a <span class="methodname" dir="ltr">create()</span> function. For instance,
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">auto pixbuf = Gdk::Pixbuf::create_from_file(filename);
</pre></div>
<p class="para block">
You have no way of getting a bare <span class="classname" dir="ltr">Gdk::Pixbuf</span>. In the
example, <span class="varname" dir="ltr">pixbuf</span> is a smart pointer, so you can do this, much
like a normal pointer:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">auto width = 0;
if(pixbuf)
{
  width = pixbuf-&gt;get_width();
}
</pre></div>
<p class="para block">
When <span class="varname" dir="ltr">pixbuf</span> goes out of scope an
<span class="methodname" dir="ltr">unref()</span> will happen in the background and you don't need
to worry about it anymore. There's no <span class="literal" dir="ltr">new</span> so there's no
<span class="literal" dir="ltr">delete</span>.
</p>
<p class="para block">
If you copy a <span class="classname" dir="ltr">RefPtr</span>, for instance
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">auto pixbuf2 = pixbuf;
</pre></div>
, or if you pass it as a method argument or a return type, then
<span class="classname" dir="ltr">RefPtr</span> will do any necessary referencing to ensure that
the instance will not be destroyed until the last <span class="classname" dir="ltr">RefPtr</span>
has gone out of scope.
</p>
<p class="para block">See the <a class="link" href="#chapter-refptr" title="The RefPtr smartpointer">appendix</a> for detailed information about RefPtr.</p>
<p class="para block">
If you wish to learn more about smartpointers, you might look in these
books:
<div class="block list itemizedlist"><ul class="itemizedlist">
<li class="li-first"><span class="para">
Bjarne Stroustrup, "The C++ Programming Language" Forth Edition - section 34.3
</span></li>
<li><span class="para">
Nicolai M. Josuttis, "The C++ Standard Library" - section 4.2
</span></li>
</ul></div>
</p>
</div>
</div>
<div class="division chapter">
<a name="chapter-builder"><!--chapter-builder--></a><div class="header"><h2 class="chapter title"><span class="title"><span class="label">24. </span>Glade and Gtk::Builder</span></h2></div>
<p class="para block block-first">
Although you can use C++ code to instantiate and arrange widgets, this
can soon become tedious and repetitive. And it requires a recompilation to show
changes. The <span class="application">Glade</span> application allows you to layout
widgets on screen and then save an XML description of the arrangement. Your
application can then use the <span class="application">Gtk::Builder</span> API to load
that XML file at runtime and obtain a pointer to specifically named widget
instances.
</p>
<p class="para block">
This has the following advantages:
<div class="block list orderedlist"><ol class="orderedlist">
<li class="li-first"><p class="simpara block block-first">Less C++ code is required.</p></li>
<li><p class="simpara block block-first">UI changes can be seen more quickly, so UIs are able to improve.</p></li>
<li><p class="simpara block block-first">Designers without programming skills can create and edit UIs.</p></li>
</ol></div>
</p>
<p class="para block">
You still need C++ code to deal with User Interface changes triggered by user
actions, but using <span class="application">Gtk::Builder</span> for the widget
layout allows you to focus on implementing that functionality.
</p>
<div class="autotoc"><ul>
<li>
<span class="label">24.1. </span><a class="xref" href="#sec-builder-loading-glade-file" title="Loading the .glade file">Loading the .glade file</a>
</li>
<li>
<span class="label">24.2. </span><a class="xref" href="#sec-builder-accessing-widgets" title="Accessing widgets">Accessing widgets</a>
</li>
<li>
<span class="label">24.3. </span><a class="xref" href="#sec-builder-using-derived-widgets" title="Using derived widgets">Using derived widgets</a>
</li>
</ul></div>
<div class="division sect1">
<a name="sec-builder-loading-glade-file"><!--sec-builder-loading-glade-file--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">24.1. </span>Loading the .glade file</span></h3></div>
<p class="para block block-first">
<span class="classname" dir="ltr">Gtk::Builder</span> must be used via a
<span class="classname" dir="ltr">Glib::RefPtr</span>. Like all such classes, you need to use a
<span class="methodname" dir="ltr">create()</span> method to instantiate it. For instance,
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">auto builder = Gtk::Builder::create_from_file("basic.glade");
</pre></div>
This will instantiate the windows defined in the <span class="filename" dir="ltr">.glade</span> file.
</p>
<p class="para block">To instantiate just one window, or just one of the child widgets, you can specify the name of a widget as the second parameter. For instance,
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">auto builder = Gtk::Builder::create_from_file("basic.glade", "treeview_products");
</pre></div>
</div>
<div class="division sect1">
<a name="sec-builder-accessing-widgets"><!--sec-builder-accessing-widgets--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">24.2. </span>Accessing widgets</span></h3></div>
<p class="para block block-first">
To access a widget, for instance to <span class="methodname" dir="ltr">show()</span> a dialog, use
the <span class="methodname" dir="ltr">get_widget()</span> method, providing the widget's name. This
name should be specified in the <span class="application">Glade</span> Properties
window. If the widget could not be found, or is of the wrong type, then the
pointer will be set to nullptr.
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">auto pDialog = builder-&gt;get_widget&lt;Gtk::Dialog&gt;("DialogBasic");
</pre></div>
<p class="para block">
<span class="application">Gtk::Builder</span> checks for a null pointer, and checks
that the widget is of the expected type, and will show warnings on the command
line about these.
</p>
<p class="para block">
Remember that you are not instantiating a widget with
<span class="methodname" dir="ltr">get_widget()</span>, you are just obtaining a pointer to one that
already exists. You will always receive a pointer to the same instance when you
call <span class="methodname" dir="ltr">get_widget()</span> on the same
<span class="classname" dir="ltr">Gtk::Builder</span>, with the same widget name. The
widgets are instantiated during <span class="methodname" dir="ltr">Gtk::Builder::create_from_file()</span>.
</p>
<p class="para block">
<span class="methodname" dir="ltr">get_widget()</span> returns child widgets that are
<span class="function">manage()</span>ed (see the <a class="link" href="#chapter-memory" title="Memory management">Memory
Management</a> chapter), so they will be deleted when their parent
container is deleted. <span class="classname" dir="ltr">Windows</span> (such as <span class="classname" dir="ltr">Dialogs</span>)
cannot be managed because they have no parent container, so you must delete them at
some point. The documentation of <span class="classname" dir="ltr">Gtk::Builder</span> has more to say
about the memory management of different kinds of objects.
</p>
<p class="para block"><a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Builder.html" title="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Builder.html">Reference</a></p>
<div class="autotoc"><ul><li>
<span class="label">24.2.1. </span><a class="xref" href="#builder-example-basic" title="Example">Example</a>
</li></ul></div>
<div class="division sect2">
<a name="builder-example-basic"><!--builder-example-basic--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">24.2.1. </span>Example</span></h4></div>
<p class="para block block-first">
This simple example shows how to load a <span class="application">Glade</span> file at runtime and access the widgets with
<span class="application">Gtk::Builder</span>.
</p>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/builder/basic" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/builder/basic">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include &lt;gtkmm.h&gt;
#include &lt;iostream&gt;

namespace
{
Gtk::Dialog* pDialog = nullptr;
Glib::RefPtr&lt;Gtk::Application&gt; app;

void on_button_clicked()
{
  if (pDialog)
    pDialog-&gt;hide(); //hide() will cause Gtk::Application::run() to end.
}

void on_app_activate()
{
  // Load the GtkBuilder file and instantiate its widgets:
  auto refBuilder = Gtk::Builder::create();
  try
  {
    refBuilder-&gt;add_from_file("basic.glade");
  }
  catch(const Glib::FileError&amp; ex)
  {
    std::cerr &lt;&lt; "FileError: " &lt;&lt; ex.what() &lt;&lt; std::endl;
    return;
  }
  catch(const Glib::MarkupError&amp; ex)
  {
    std::cerr &lt;&lt; "MarkupError: " &lt;&lt; ex.what() &lt;&lt; std::endl;
    return;
  }
  catch(const Gtk::BuilderError&amp; ex)
  {
    std::cerr &lt;&lt; "BuilderError: " &lt;&lt; ex.what() &lt;&lt; std::endl;
    return;
  }

  // Get the GtkBuilder-instantiated dialog:
  pDialog = refBuilder-&gt;get_widget&lt;Gtk::Dialog&gt;("DialogBasic");
  if (!pDialog)
  {
    std::cerr &lt;&lt; "Could not get the dialog" &lt;&lt; std::endl;
    return;
  }

  // Get the GtkBuilder-instantiated button, and connect a signal handler:
  auto pButton = refBuilder-&gt;get_widget&lt;Gtk::Button&gt;("quit_button");
  if (pButton)
    pButton-&gt;signal_clicked().connect([] () { on_button_clicked(); });

  // It's not possible to delete widgets after app-&gt;run() has returned.
  // Delete the dialog with its child widgets before app-&gt;run() returns.
  pDialog-&gt;signal_hide().connect([] () { delete pDialog; });

  app-&gt;add_window(*pDialog);
  pDialog-&gt;show();
}
} // anonymous namespace

int main(int argc, char** argv)
{
  app = Gtk::Application::create("org.gtkmm.example");

  // Instantiate a dialog when the application has been activated.
  // This can only be done after the application has been registered.
  // It's possible to call app-&gt;register_application() explicitly, but
  // usually it's easier to let app-&gt;run() do it for you.
  app-&gt;signal_activate().connect([] () { on_app_activate(); });

  return app-&gt;run(argc, argv);
}
</pre></div>
</div>
</div>
<div class="division sect1">
<a name="sec-builder-using-derived-widgets"><!--sec-builder-using-derived-widgets--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">24.3. </span>Using derived widgets</span></h3></div>
<p class="para block block-first">
You can use <span class="classname" dir="ltr">Gtk::Builder</span> and
<span class="application">Glade</span> to layout your own custom widgets
derived from <span class="application">gtkmm</span> widget classes. This keeps your code organized and
encapsulated, separating declarative presentation from business logic, avoiding
having most of your source just be setting properties and packing in containers.
</p>
<p class="para block">Use <span class="methodname" dir="ltr">Gtk::Builder::get_widget_derived()</span> like so:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">auto pDialog = Gtk::Builder::get_widget_derived&lt;DerivedDialog&gt;(builder, "DialogDerived");
</pre></div>
<p class="para block">
Your derived class must have a constructor that takes a pointer to the
underlying C type, and the <span class="classname" dir="ltr">Gtk::Builder</span> instance.
All relevant classes of <span class="application">gtkmm</span> typedef their underlying C type as
<span class="classname" dir="ltr">BaseObjectType</span> (<span class="classname" dir="ltr">Gtk::Dialog</span>
typedefs <span class="classname" dir="ltr">BaseObjectType</span> as <span class="type" dir="ltr">GtkDialog</span>, for instance).
</p>
<p class="para block">
You must call the base class's constructor in the initialization list, providing the C pointer. For
instance,
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">DerivedDialog::DerivedDialog(BaseObjectType* cobject, const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; builder)
: Gtk::Dialog(cobject)
{
}
</pre></div>
<p class="para block">
You could then encapsulate the manipulation of the child widgets in the
constructor of the derived class, maybe using <span class="methodname" dir="ltr">get_widget()</span>
or <span class="methodname" dir="ltr">get_widget_derived()</span> again. For instance,
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">DerivedDialog::DerivedDialog(BaseObjectType* cobject, const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; builder)
: Gtk::Dialog(cobject),
  m_builder(builder),
  //Get the Glade-instantiated Button, and connect a signal handler:
  m_pButton(m_builder-&gt;get_widget&lt;Gtk::Button&gt;("quit_button"))
{
  if(m_pButton)
  {
    m_pButton-&gt;signal_clicked().connect( sigc::mem_fun(*this, &amp;DerivedDialog::on_button_quit) );
  }
}
</pre></div>
<p class="para block">
It's possible to pass additional arguments from
<span class="methodname" dir="ltr">get_widget_derived()</span> to the constructor of the derived
widget. For instance, this call to <span class="methodname" dir="ltr">get_widget_derived()</span>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">auto pDialog = Gtk::Builder::get_widget_derived&lt;DerivedDialog&gt;(builder, "DialogDerived", true);
</pre></div>
can invoke this constructor
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">DerivedDialog::DerivedDialog(BaseObjectType* cobject, const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; builder, bool warning)
: Gtk::Dialog(cobject),
  m_builder(builder),
  m_pButton(m_builder-&gt;get_widget&lt;Gtk::Button&gt;("quit_button"))
{
  // ....
}
</pre></div>
</p>
<div class="autotoc"><ul>
<li>
<span class="label">24.3.1. </span><a class="xref" href="#sec-builder-and-property" title="Gtk::Builder and Glib::Property">Gtk::Builder and Glib::Property</a>
</li>
<li>
<span class="label">24.3.2. </span><a class="xref" href="#builder-example-derived" title="Example">Example</a>
</li>
</ul></div>
<div class="division sect2">
<a name="sec-builder-and-property"><!--sec-builder-and-property--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">24.3.1. </span>Gtk::Builder and Glib::Property</span></h4></div>
<p class="para block block-first">
If your derived widget uses <span class="classname" dir="ltr">Glib::Property</span>, it becomes slightly
more complicated. A derived widget that contains <span class="classname" dir="ltr">Glib::Property</span>
members must be registered with its own name in the <span class="type" dir="ltr">GType</span> system.
It must be registered before any of the <span class="methodname" dir="ltr">create_from_*()</span> or
<span class="methodname" dir="ltr">add_from_*()</span> methods are called, meaning that you may have
to create an instance of your derived widget just to have its class registered.
Your derived widget must have a constructor that has the parameters required by
<span class="methodname" dir="ltr">get_widget_derived()</span> and calls the <span class="classname" dir="ltr">Glib::ObjectBase</span>
constructor to register the <span class="type" dir="ltr">GType</span>.
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">DerivedButton::DerivedButton(BaseObjectType* cobject, const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; builder)
: Glib::ObjectBase("MyButton"), // The GType name will be gtkmm__CustomObject_MyButton.
  Gtk::Button(cobject),
  prop_ustring(*this, "button-ustring"),
  prop_int(*this, "button-int", 10)
{
  // ....
}
</pre></div>
<p class="para block">
When using <span class="application">gtkmm</span> with a version of <span class="application">glibmm</span> from 2.62
onwards, it is possible also to specify properties of derived widgets, declared
in C++ using <span class="application">gtkmm</span>, within <span class="filename" dir="ltr">.glade</span> files and load/set
these using <span class="classname" dir="ltr">Gtk::Builder</span>. See the documentation of
<span class="classname" dir="ltr">Gtk::Builder</span> for more details on how to achieve this.
Glade won’t recognise such properties as-is, but it should be able to through
use of <a class="ulink" href="https://developer.gnome.org/gladeui/stable/properties.html" title="https://developer.gnome.org/gladeui/stable/properties.html">
property class definitions</a> and a catalog declaring those new properties.
</p>
</div>
<div class="division sect2">
<a name="builder-example-derived"><!--builder-example-derived--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">24.3.2. </span>Example</span></h4></div>
<p class="para block block-first">
This example shows how to load a <span class="application">Glade</span> file at runtime and access the widgets via derived classes.
</p>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/builder/derived" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/builder/derived">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">derivedbutton.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLE_DERIVED_BUTTON_H
#define GTKMM_EXAMPLE_DERIVED_BUTTON_H

#include &lt;gtkmm.h&gt;

class DerivedButton : public Gtk::Button
{
public:
  DerivedButton();
  DerivedButton(BaseObjectType* cobject, const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; refGlade);
  virtual ~DerivedButton();

  // Provide proxies for the properties. The proxy allows you to connect to
  // the 'changed' signal, etc.
  Glib::PropertyProxy&lt;Glib::ustring&gt; property_ustring() { return prop_ustring.get_proxy(); }
  Glib::PropertyProxy&lt;int&gt; property_int() { return prop_int.get_proxy(); }

private:
  Glib::Property&lt;Glib::ustring&gt; prop_ustring;
  Glib::Property&lt;int&gt; prop_int;
};

#endif //GTKMM_EXAMPLE_DERIVED_BUTTON_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">deriveddialog.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLE_DERIVED_DIALOG_H
#define GTKMM_EXAMPLE_DERIVED_DIALOG_H

#include &lt;gtkmm.h&gt;
#include "derivedbutton.h"

class DerivedDialog : public Gtk::Dialog
{
public:
  DerivedDialog(BaseObjectType* cobject, const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; refGlade);
  DerivedDialog(BaseObjectType* cobject, const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; refGlade,
    bool is_glad);
  virtual ~DerivedDialog();

protected:
  //Signal handlers:
  void on_button_quit();

  Glib::RefPtr&lt;Gtk::Builder&gt; m_refGlade;
  DerivedButton* m_pButton;
};

#endif //GTKMM_EXAMPLE_DERIVED_DIALOG_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "deriveddialog.h"
#include &lt;iostream&gt;
#include &lt;cstring&gt;

namespace
{
bool show_icon = false;
bool is_glad = true;

DerivedDialog* pDialog = nullptr;
Glib::RefPtr&lt;Gtk::Application&gt; app;

void on_app_activate()
{
  // Create a dummy instance before the call to refBuilder-&gt;add_from_file().
  // This creation registers DerivedButton's class in the GType system.
  // This is necessary because DerivedButton contains user-defined properties
  // (Glib::Property) and is created by Gtk::Builder.
  static_cast&lt;void&gt;(DerivedButton());

  // Load the GtkBuilder file and instantiate its widgets:
  auto refBuilder = Gtk::Builder::create();
  try
  {
    refBuilder-&gt;add_from_file("derived.glade");
  }
  catch(const Glib::FileError&amp; ex)
  {
    std::cerr &lt;&lt; "FileError: " &lt;&lt; ex.what() &lt;&lt; std::endl;
    return;
  }
  catch(const Glib::MarkupError&amp; ex)
  {
    std::cerr &lt;&lt; "MarkupError: " &lt;&lt; ex.what() &lt;&lt; std::endl;
    return;
  }
  catch(const Gtk::BuilderError&amp; ex)
  {
    std::cerr &lt;&lt; "BuilderError: " &lt;&lt; ex.what() &lt;&lt; std::endl;
    return;
  }

  // Get the GtkBuilder-instantiated dialog:
  if (show_icon)
    pDialog = Gtk::Builder::get_widget_derived&lt;DerivedDialog&gt;(refBuilder, "DialogDerived", is_glad);
  else
    pDialog = Gtk::Builder::get_widget_derived&lt;DerivedDialog&gt;(refBuilder, "DialogDerived");

  if (!pDialog)
  {
    std::cerr &lt;&lt; "Could not get the dialog" &lt;&lt; std::endl;
    return;
  }

  // It's not possible to delete widgets after app-&gt;run() has returned.
  // Delete the dialog with its child widgets before app-&gt;run() returns.
  pDialog-&gt;signal_hide().connect([] () { delete pDialog; });

  app-&gt;add_window(*pDialog);
  pDialog-&gt;show();
}
} // anonymous namespace

int main(int argc, char** argv)
{
  int argc1 = argc;
  if (argc &gt; 1)
  {
    if (std::strcmp(argv[1], "--glad") == 0)
    {
      show_icon = true;
      is_glad = true;
      argc1 = 1; // Don't give the command line arguments to Gtk::Application.
    }
    else if (std::strcmp(argv[1], "--sad") == 0)
    {
      show_icon = true;
      is_glad = false;
      argc1 = 1; // Don't give the command line arguments to Gtk::Application.
    }
  }

  app = Gtk::Application::create("org.gtkmm.example");

  // Instantiate a dialog when the application has been activated.
  // This can only be done after the application has been registered.
  // It's possible to call app-&gt;register_application() explicitly, but
  // usually it's easier to let app-&gt;run() do it for you.
  app-&gt;signal_activate().connect([] () { on_app_activate(); });

  return app-&gt;run(argc1, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">derivedbutton.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "derivedbutton.h"
#include &lt;iostream&gt;

namespace
{
void on_ustring_changed()
{
  std::cout &lt;&lt; "- ustring property changed!" &lt;&lt; std::endl;
}

void on_int_changed()
{
  std::cout &lt;&lt; "- int property changed!" &lt;&lt; std::endl;
}
} // anonymous namespace

// For creating a dummy object in main.cc.
DerivedButton::DerivedButton()
: Glib::ObjectBase("MyButton"),
  prop_ustring(*this, "button-ustring"),
  prop_int(*this, "button-int", 10)
{
}

DerivedButton::DerivedButton(BaseObjectType* cobject, const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; /* refGlade */)
: // To register custom properties, you must register a custom GType.  If
  // you don't know what that means, don't worry, just remember to add
  // this Glib::ObjectBase constructor call to your class' constructor.
  // The GType name will be gtkmm__CustomObject_MyButton.
  Glib::ObjectBase("MyButton"),
  Gtk::Button(cobject),
  // register the properties with the object and give them names
  prop_ustring(*this, "button-ustring"),
  // this one has a default value
  prop_int(*this, "button-int", 10)
{
  // Register some handlers that will be called when the values of the
  // specified parameters are changed.
  property_ustring().signal_changed().connect(sigc::ptr_fun(&amp;on_ustring_changed));
  property_int().signal_changed().connect(sigc::ptr_fun(&amp;on_int_changed));
}

DerivedButton::~DerivedButton()
{
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">deriveddialog.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "deriveddialog.h"
#include &lt;iostream&gt;

DerivedDialog::DerivedDialog(BaseObjectType* cobject, const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; refGlade)
: Gtk::Dialog(cobject),
  m_refGlade(refGlade),
  m_pButton(nullptr)
{
  // Get the Glade-instantiated Button, and connect a signal handler:
  m_pButton = Gtk::Builder::get_widget_derived&lt;DerivedButton&gt;(m_refGlade, "quit_button");
  if (m_pButton)
  {
    m_pButton-&gt;signal_clicked().connect( sigc::mem_fun(*this, &amp;DerivedDialog::on_button_quit) );
    std::cout &lt;&lt; "ustring, int: " &lt;&lt; m_pButton-&gt;property_ustring()
              &lt;&lt; ", " &lt;&lt; m_pButton-&gt;property_int() &lt;&lt; std::endl;
    m_pButton-&gt;property_int() = 99;
    std::cout &lt;&lt; "ustring, int: " &lt;&lt; m_pButton-&gt;property_ustring()
              &lt;&lt; ", " &lt;&lt; m_pButton-&gt;property_int() &lt;&lt; std::endl;
  }
}

// The first two parameters are mandatory in a constructor that will be called
// from Gtk::Builder::get_widget_derived().
// Additional parameters, if any, correspond to additional arguments in the call
// to Gtk::Builder::get_widget_derived().
DerivedDialog::DerivedDialog(BaseObjectType* cobject, const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; refGlade,
  bool is_glad)
: DerivedDialog(cobject, refGlade) // Delegate to the other constructor
{
  // Show an icon.
  auto pImage = Gtk::make_managed&lt;Gtk::Image&gt;();
  pImage-&gt;set_from_icon_name(is_glad ? "face-smile" : "face-sad");
  pImage-&gt;set_icon_size(Gtk::IconSize::LARGE);
  pImage-&gt;set_expand();
  get_content_area()-&gt;append(*pImage);
}

DerivedDialog::~DerivedDialog()
{
}

void DerivedDialog::on_button_quit()
{
  hide(); //hide() will cause Gtk::Application::run() to end.
}
</pre></div>
</div>
</div>
</div>
<div class="division chapter">
<a name="chapter-internationalization"><!--chapter-internationalization--></a><div class="header"><h2 class="chapter title"><span class="title"><span class="label">25. </span>Internationalization and Localization</span></h2></div>
<p class="para block block-first">
    <span class="application">gtkmm</span> applications can easily support multiple languages, including
    non-European languages such as Chinese and right-to-left languages such as
    Arabic. An appropriately-written and translated <span class="application">gtkmm</span> application will use
    the appropriate language at runtime based on the user's environment.
  </p>
<p class="para block">
    You might not anticipate the need to support additional languages, but
    you can never rule it out. And it's easier to develop the application
    properly in the first place rather than retrofitting later.
  </p>
<p class="para block">
    The process of writing source code that allows for translation is called
    <span class="literal" dir="ltr">internationalization</span>, often abbreviated to
    <span class="literal" dir="ltr">i18n</span>. The <span class="literal" dir="ltr">Localization</span> process,
    sometimes abbreviated as <span class="literal" dir="ltr">l10n</span>, provides translated text
    for other languages, based on that source code.
  </p>
<p class="para block">
    The main activity in the internationalization process is finding strings
    seen by users and marking them for translation. You do not need to do it all
    at once - if you set up the necessary project infrastructure correctly then
    your application will work normally regardless of how many strings you've
    covered.
  </p>
<p class="para block">
    String literals should be typed in the source code in English, but
    surrounded by a macro. The <span class="application">gettext</span> (or intltool)
    utility can then extract the marked strings for translation, and substitute
    the translated text at runtime.
  </p>
<div class="autotoc"><ul>
<li>
<span class="label">25.1. </span><a class="xref" href="#sec-internationalization-intro" title="Preparing your project">Preparing your project</a>
</li>
<li>
<span class="label">25.2. </span><a class="xref" href="#sec-i18n-marking-strings" title="Marking strings for translation">Marking strings for translation</a>
</li>
<li>
<span class="label">25.3. </span><a class="xref" href="#sec-i18n-expecting-utf8" title="Expecting UTF8">Expecting UTF8</a>
</li>
<li>
<span class="label">25.4. </span><a class="xref" href="#sec-i18n-pitfalls" title="Pitfalls">Pitfalls</a>
</li>
<li>
<span class="label">25.5. </span><a class="xref" href="#sec-i18n-getting-help-with-translations" title="Getting help with translations">Getting help with translations</a>
</li>
</ul></div>
<div class="division sect1">
<a name="sec-internationalization-intro"><!--sec-internationalization-intro--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">25.1. </span>Preparing your project</span></h3></div>
<div class="admonition block note block-first block-indent"><div class="note-inner">
      <p class="para block block-first">
        In the instructions below we will assume that you will not be using
        <span class="application">gettext</span> directly, but
        <span class="application">intltool</span>, which was written specifically for
        <span class="literal" dir="ltr">GNOME</span>. <span class="application">intltool</span> uses
        <span class="function">gettext()</span>, which extracts strings from source code,
        but <span class="application">intltool</span> can also combine strings from
        other files, for example from desktop menu details, and GUI resource
        files such as <span class="application">Glade</span> files, into standard
        <span class="application">gettext</span> <span class="filename" dir="ltr">.pot/.po</span> files.
      </p>
      <p class="para block">
        We also assume that you are using autotools (e.g.
        <span class="application">automake</span> and
        <span class="application">autoconf</span>) to build your project, and
        that you are using <a class="ulink" href="https://gitlab.gnome.org/GNOME/gnome-common/blob/master/autogen.sh" title="https://gitlab.gnome.org/GNOME/gnome-common/blob/master/autogen.sh">https://gitlab.gnome.org/GNOME/gnome-common/blob/master/autogen.sh</a>
        or a similar <span class="literal" dir="ltr">autogen.sh</span> file, which, among other
        things, takes care of some <span class="application">intltool</span>
        initialization.
      </p>
    </div></div>
<p class="para block">
      An alternative to <span class="application">gnome-common</span>'s
      <span class="literal" dir="ltr">autogen.sh</span> may look like this:
    </p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#! /bin/sh -e
test -n "$srcdir" || srcdir=`dirname "$0"`
test -n "$srcdir" || srcdir=.

autoreconf --force --install --verbose --warnings=all "$srcdir"
echo "Running intltoolize --copy --force --automake"
intltoolize --copy --force --automake
test -n "$NOCONFIGURE" || "$srcdir/configure" "$@"</pre></div>
<p class="para block">
      Create a sub-directory named <span class="literal" dir="ltr">po</span> in your project's root
      directory. This directory will eventually contain all of your
      translations. Within it, create a file named <span class="literal" dir="ltr">LINGUAS</span>
      and a file named <span class="literal" dir="ltr">POTFILES.in</span>. It is common practice to
      also create a <span class="literal" dir="ltr">ChangeLog</span> file in the
      <span class="literal" dir="ltr">po</span> directory so that translators can keep track of
      translation changes.
    </p>
<p class="para block">
      <span class="literal" dir="ltr">LINGUAS</span> contains an alphabetically sorted list of codes
      identifying the languages for which your program is translated (comment
      lines starting with a <span class="literal" dir="ltr">#</span> are ignored). Each language
      code listed in the <span class="literal" dir="ltr">LINGUAS</span> file must have a
      corresponding <span class="literal" dir="ltr">.po</span> file. So, if your program has German
      and Japanese translations, your <span class="literal" dir="ltr">LINGUAS</span> file would
      look like this:
    </p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting"># keep this file sorted alphabetically, one language code per line
de
ja</pre></div>
<p class="para block">
      (In addition, you'd have the files <span class="literal" dir="ltr">ja.po</span> and
      <span class="literal" dir="ltr">de.po</span> in your
      <span class="literal" dir="ltr">po</span> directory which contain the German and Japanese
      translations, respectively.)
    </p>
<p class="para block">
      <span class="literal" dir="ltr">POTFILES.in</span> is a list of paths to all files which
      contain strings marked up for translation, starting from the project root
      directory. So for example, if your project sources were located in a
      subdirectory named <span class="literal" dir="ltr">src</span>, and you had two files that
      contained strings that should be translated, your
      <span class="literal" dir="ltr">POTFILES.in</span> file might look like this:
    </p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">src/main.cc
src/other.cc</pre></div>
<p class="para block">
      If you are using <span class="application">gettext</span> directly, you can only
      mark strings for translation if they are in source code file. However, if
      you use <span class="application">intltool</span>, you can mark strings for
      translation in a variety of other file formats, including
      <span class="application">Glade</span> UI files, xml, <a class="ulink" href="http://standards.freedesktop.org/desktop-entry-spec/latest/" title="http://standards.freedesktop.org/desktop-entry-spec/latest/">.desktop
        files</a> and several more. So, if you have designed some of the
      application UI in <span class="application">Glade</span> then also add your
      <span class="filename" dir="ltr">.glade</span> files to the list in
      <span class="literal" dir="ltr">POTFILES.in</span>.
    </p>
<p class="para block">
      Now that there is a place to put your translations, you need to initialize
      <span class="application">intltool</span> and <span class="application">gettext</span>.
      Add the following code to your <span class="literal" dir="ltr">configure.ac</span>,
      substituting 'programname' with the name of your program:
    </p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">IT_PROG_INTLTOOL([0.35.0])

GETTEXT_PACKAGE=programname
AC_SUBST(GETTEXT_PACKAGE)
AC_DEFINE_UNQUOTED([GETTEXT_PACKAGE], ["$GETTEXT_PACKAGE"],
                   [The domain to use with gettext])
AM_GNU_GETTEXT([external])
AM_GNU_GETTEXT_VERSION([0.17])

PROGRAMNAME_LOCALEDIR=[${datadir}/locale]
AC_SUBST(PROGRAMNAME_LOCALEDIR)</pre></div>
<p class="para block">
      This <span class="varname" dir="ltr">PROGRAMNAME_LOCALEDIR</span> variable will be used later
      in the <span class="literal" dir="ltr">Makefile.am</span> file, to define a macro that will be
      used when you initialize <span class="application">gettext</span> in your source
      code.
    </p>
<p class="para block">
      <span class="literal" dir="ltr">AM_GLIB_GNU_GETTEXT</span> has been an alternative to
      <span class="literal" dir="ltr">AM_GNU_GETTEXT</span> and <span class="literal" dir="ltr">AM_GNU_GETTEXT_VERSION</span>,
      but <span class="literal" dir="ltr">AM_GLIB_GNU_GETTEXT</span> is now deprecated, and shall
      not be used in new code.
    </p>
<p class="para block">
      In the top-level Makefile.am:
      <div class="block list itemizedlist"><ul class="itemizedlist">
<li class="li-first">
          <span class="para">Add <span class="literal" dir="ltr">po</span> to the <span class="literal" dir="ltr">SUBDIRS</span>
            variable. Without this, your translations won't get built and
            installed when you build the program</span>
        </li>
<li>
          <span class="para">
            Define <span class="literal" dir="ltr">INTLTOOL_FILES</span> as:
            <div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">INTLTOOL_FILES = intltool-extract.in \
                 intltool-merge.in \
                 intltool-update.in</pre></div>
          </span>
        </li>
<li>
          <span class="para">
            Add <span class="literal" dir="ltr">INTLTOOL_FILES</span> to the
            <span class="literal" dir="ltr">EXTRA_DIST</span> list of files. This ensures that when
            you do a <span class="command" dir="ltr">make dist</span>, these files will be
            included in the source tarball.
          </span>
        </li>
<li>
          <span class="para">
            Update your <span class="literal" dir="ltr">DISTCLEANFILES</span>:
            <div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">DISTCLEANFILES = ... intltool-extract \
                 intltool-merge \
                 intltool-update \
                 po/.intltool-merge-cache</pre></div>
          </span>
        </li>
<li>
          <span class="para">
            Depending on the types of files that contain translatable strings,
            add code such as
            <div dir="ltr" class=" block programlisting block-indent block-first"><pre class="programlisting">desktopdir = $(datadir)/applications
desktop_in_files = programname.desktop.in
desktop_DATA = $(desktop_in_files:.desktop.in=.desktop)
@INTLTOOL_DESKTOP_RULE@</pre></div>
          </span>
        </li>
</ul></div>
    </p>
<p class="para block">
      In your <span class="literal" dir="ltr">src/Makefile.am</span>, update your
      <span class="literal" dir="ltr">AM_CPPFLAGS</span> to add the following preprocessor macro
      definition:
    </p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">AM_CPPFLAGS = ... -DPROGRAMNAME_LOCALEDIR=\"${PROGRAMNAME_LOCALEDIR}\"</pre></div>
<p class="para block">
      This macro will be used when you initialize <span class="literal" dir="ltr">gettext</span> in
      your source code.
    </p>
</div>
<div class="division sect1">
<a name="sec-i18n-marking-strings"><!--sec-i18n-marking-strings--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">25.2. </span>Marking strings for translation</span></h3></div>
<p class="para block block-first">
    String literals should be typed in the source code in English, but
    they should be surrounded by a call to the <span class="function">gettext()</span>
    function. These strings will be extracted for translation and the
    translations may be used at runtime instead of the original English
    strings.
  </p>
<p class="para block">
    The <span class="application">GNU gettext</span> package allows you to mark
    strings in source code, extract those strings for translation, and use
    the translated strings in your application.
  </p>
<p class="para block">
    However, <span class="application">Glib</span> defines
    <span class="function">gettext()</span>
    support macros which are shorter wrappers in an easy-to-use form.
    To use these macros, include <span class="literal" dir="ltr">&lt;glibmm/i18n.h&gt;</span>,
    and then, for example, substitute:
    <div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">display_message("Getting ready for i18n.");</pre></div>
    with:
    <div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">display_message(_("Getting ready for i18n."));</pre></div>
  </p>
<p class="para block">
    For reference, it is possible to generate a file which contains all
    strings which appear in your code, even if they are not marked for translation,
    together with file name and line
    number references. To generate such a file named
    <span class="literal" dir="ltr">my-strings</span>, execute the following command,
    within the source code directory:
  </p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">xgettext -a -o my-strings --omit-header *.cc *.h</pre></div>
<p class="para block">
    Finally, to let your program use the translation for the current locale,
    add this code to the beginning of your <span class="filename" dir="ltr">main.cc</span> file, to initialize gettext.
  </p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">bindtextdomain(GETTEXT_PACKAGE, PROGRAMNAME_LOCALEDIR);
bind_textdomain_codeset(GETTEXT_PACKAGE, "UTF-8");
textdomain(GETTEXT_PACKAGE);</pre></div>
<div class="autotoc"><ul>
<li>
<span class="label">25.2.1. </span><a class="xref" href="#sec-i18n-gettext" title="How gettext works">How gettext works</a>
</li>
<li>
<span class="label">25.2.2. </span><a class="xref" href="#sec-i18n-testing" title="Testing and adding translations">Testing and adding translations</a>
</li>
<li>
<span class="label">25.2.3. </span><a class="xref" href="#sec-i18n-resources" title="Resources">Resources</a>
</li>
</ul></div>
<div class="division sect2">
<a name="sec-i18n-gettext"><!--sec-i18n-gettext--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">25.2.1. </span>How gettext works</span></h4></div>
<p class="para block block-first">
      The <span class="application">intltool-update</span> or
      <span class="application">xgettext</span> script extracts the strings
      and puts them in a <span class="filename" dir="ltr">mypackage.pot</span> file.
      The translators of your application create their translations by
      first copying this <span class="filename" dir="ltr">.pot</span> file to a
      <span class="filename" dir="ltr">localename.po</span> file. A locale identifies a
      language and an encoding for that language, including date and numerical
      formats. Later, when the text in your source code has changed, the
      <span class="application">msgmerge</span> or <span class="application">intltool-update</span>
      script is used to update the <span class="filename" dir="ltr">localename.po</span> files from
      the regenerated <span class="filename" dir="ltr">.pot</span> file.
    </p>
<p class="para block">
      At install time, the <span class="filename" dir="ltr">.po</span> files are converted to
      a binary format (with the extension <span class="filename" dir="ltr">.mo</span>) and
      placed in a system-wide directory for locale files, for example
      <span class="filename" dir="ltr">/usr/share/locale/</span>.
    </p>
<p class="para block">
      When the application runs, the <span class="application">gettext</span>
      library checks the system-wide directory to see if there is a
      <span class="filename" dir="ltr">.mo</span> file for the user's locale environment
      (you can set the locale with, for instance, "export LANG=de_DE.UTF-8"
      from a bash console). Later, when the program reaches a
      <span class="literal" dir="ltr">gettext</span> call, it looks for a translation of a
      particular string. If none is found, the original string is used.
    </p>
</div>
<div class="division sect2">
<a name="sec-i18n-testing"><!--sec-i18n-testing--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">25.2.2. </span>Testing and adding translations</span></h4></div>
<p class="para block block-first">
      To convince yourself that you've done well, you may wish to add a
      translation for a new locale. In order to do that, go to the
      <span class="filename" dir="ltr">po</span> subdirectory of your project and
      execute the following command:
    </p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">intltool-update --pot</pre></div>
<p class="para block">
      That will create a file named <span class="filename" dir="ltr">programname.pot</span>.
      Now copy that file to <span class="filename" dir="ltr">languagecode.po</span>, such as
      <span class="filename" dir="ltr">de.po</span> or <span class="filename" dir="ltr">hu.po</span>. Also add
      that language code to <span class="literal" dir="ltr">LINGUAS</span>. The
      <span class="filename" dir="ltr">.po</span> file contains a header and a list of English strings,
      with space for the translated strings to be entered. Make sure you set the
      encoding of the <span class="filename" dir="ltr">.po</span> file (specified in the header, but
      also as content) to <span class="literal" dir="ltr">UTF-8</span>.
    </p>
<div class="admonition block note block-indent"><div class="note-inner">
      <p class="para block block-first">
      It's possible that certain strings will be marked as
      <span class="literal" dir="ltr">fuzzy</span> in the <span class="filename" dir="ltr">.po</span> file.
      These translations will not substitute the original string. To make
      them appear, simply remove the <span class="literal" dir="ltr">fuzzy</span> tag.
      </p>
    </div></div>
</div>
<div class="division sect2">
<a name="sec-i18n-resources"><!--sec-i18n-resources--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">25.2.3. </span>Resources</span></h4></div>
<p class="para block block-first">
      More information about what lies behind the internationalization and localization process
      is presented and demonstrated in:

      <div class="block list itemizedlist"><ul class="itemizedlist">
<li class="li-first">
          <span class="para">
            <a class="ulink" href="https://wiki.gnome.org/TranslationProject/DevGuidelines" title="https://wiki.gnome.org/TranslationProject/DevGuidelines">
              L10N Guidelines for Developers</a>
          </span>
        </li>
<li>
          <span class="para">
            <a class="ulink" href="http://bazaar.launchpad.net/~intltool/intltool/trunk/view/head:/README" title="http://bazaar.launchpad.net/~intltool/intltool/trunk/view/head:/README">Intltool README</a>
          </span>
        </li>
<li>
          <span class="para">
            <a class="ulink" href="https://wiki.gnome.org/TranslationProject/GitHowTo" title="https://wiki.gnome.org/TranslationProject/GitHowTo">How to use Git for GNOME translators</a>
          </span>
        </li>
<li>
          <span class="para">
            <a class="ulink" href="http://www.gnu.org/software/gettext/manual/gettext.html" title="http://www.gnu.org/software/gettext/manual/gettext.html">gettext manual</a>
          </span>
        </li>
<li>
          <span class="para">
            <a class="ulink" href="http://ftp.gnome.org/pub/GNOME/sources/gtkmm_hello/" title="http://ftp.gnome.org/pub/GNOME/sources/gtkmm_hello/"><span class="literal" dir="ltr">gtkmm_hello</span> example package</a>
          </span>
        </li>
<li>
          <span class="para">
            <a class="ulink" href="http://ftp.gnome.org/pub/GNOME/sources/gnomemm_hello/" title="http://ftp.gnome.org/pub/GNOME/sources/gnomemm_hello/"><span class="literal" dir="ltr">gnomemm_hello</span> example package</a>
          </span>
        </li>
</ul></div>
    </p>
</div>
</div>
<div class="division sect1">
<a name="sec-i18n-expecting-utf8"><!--sec-i18n-expecting-utf8--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">25.3. </span>Expecting UTF8</span></h3></div>
<p class="para block block-first">
A properly internationalized application will not make assumptions about the
number of bytes in a character. That means that you shouldn't use pointer
arithmetic to step through the characters in a string, and it means you
shouldn't use <span class="classname" dir="ltr">std::string</span> or standard C functions such
as <span class="function">strlen()</span> because they make the same assumption.
</p>
<p class="para block">
However, you probably already avoid bare char* arrays and pointer arithmetic by
using <span class="classname" dir="ltr">std::string</span>, so you just need to start using
<span class="classname" dir="ltr">Glib::ustring</span> instead. See the <a class="link" href="#sec-basics-ustring" title="Glib::ustring">Basics</a> chapter about
<span class="classname" dir="ltr">Glib::ustring</span>.
</p>
<div class="autotoc"><ul><li>
<span class="label">25.3.1. </span><a class="xref" href="#i18n-ustring-iostreams" title="Glib::ustring and std::iostreams">Glib::ustring and std::iostreams</a>
</li></ul></div>
<div class="division sect2">
<a name="i18n-ustring-iostreams"><!--i18n-ustring-iostreams--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">25.3.1. </span>Glib::ustring and std::iostreams</span></h4></div>
<p class="para block block-first">
Unfortunately, the integration with the standard iostreams is not completely
foolproof. <span class="application">gtkmm</span> converts <span class="classname" dir="ltr">Glib::ustring</span>s to a
locale-specific encoding (which usually is not UTF-8) if you output them to an
<span class="classname" dir="ltr">ostream</span> with <span class="function">operator&lt;&lt;</span>.
Likewise, retrieving <span class="classname" dir="ltr">Glib::ustring</span>s from
<span class="classname" dir="ltr">istream</span> with <span class="function">operator&gt;&gt;</span>
causes a conversion in the opposite direction. But this scheme breaks down if
you go through a <span class="classname" dir="ltr">std::string</span>, e.g. by inputting text
from a stream to a <span class="classname" dir="ltr">std::string</span> and then implicitly
converting it to a <span class="classname" dir="ltr">Glib::ustring</span>. If the string
contained non-ASCII characters and the current locale is not UTF-8 encoded, the
result is a corrupted <span class="classname" dir="ltr">Glib::ustring</span>. You can work around
this with a manual conversion. For instance, to retrieve the
<span class="classname" dir="ltr">std::string</span> from a <span class="classname" dir="ltr">ostringstream</span>:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">std::locale::global(std::locale("")); // Set the global locale to the user's preferred locale.
                                      // Usually unnecessary here, because Glib::init()
                                      // or Gtk::Application::create() does it for you.
std::ostringstream output;
output &lt;&lt; percentage &lt;&lt; " % done";
label-&gt;set_text(Glib::locale_to_utf8(output.str()));</pre></div>
</div>
</div>
<div class="division sect1">
<a name="sec-i18n-pitfalls"><!--sec-i18n-pitfalls--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">25.4. </span>Pitfalls</span></h3></div>
<p class="para block block-first">There are a few common mistakes that you would discover eventually yourself. But this section might help you to avoid them.</p>
<div class="autotoc"><ul>
<li>
<span class="label">25.4.1. </span><a class="xref" href="#i18n-string-semantics" title="Same strings, different semantics">Same strings, different semantics</a>
</li>
<li>
<span class="label">25.4.2. </span><a class="xref" href="#i18n-composition" title="Composition of strings">Composition of strings</a>
</li>
<li>
<span class="label">25.4.3. </span><a class="xref" href="#i18n-display-size" title="Assuming the displayed size of strings">Assuming the displayed size of strings</a>
</li>
<li>
<span class="label">25.4.4. </span><a class="xref" href="#i18n-unusual-words" title="Unusual words">Unusual words</a>
</li>
<li>
<span class="label">25.4.5. </span><a class="xref" href="#i18n-non-ascii-characters" title="Using non-ASCII characters in strings">Using non-ASCII characters in strings</a>
</li>
</ul></div>
<div class="division sect2">
<a name="i18n-string-semantics"><!--i18n-string-semantics--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">25.4.1. </span>Same strings, different semantics</span></h4></div>
<p class="para block block-first">Sometimes two English strings are identical but have different meanings in
different contexts, so they would probably not be identical when translated. Since the English strings are
          used as look-up keys, this causes problems.</p>
<p class="para block">
In these cases, you should add extra characters to the strings. For instance,
use <span class="literal" dir="ltr">"jumps[noun]"</span> and <span class="literal" dir="ltr">"jumps[verb]"</span>
instead of just <span class="literal" dir="ltr">"jumps"</span> and strip them again outside the
<span class="function">gettext</span> call. If you add extra characters you should also
add a comment for the translators before the <span class="function">gettext</span> call.
Such comments will be shown in the <span class="filename" dir="ltr">.po</span> files. For
instance:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">// note to translators: don't translate the "[noun]" part - it is
// just here to distinguish the string from another "jumps" string
text = strip(gettext("jumps[noun]"), "[noun]");</pre></div>
<p class="para block">
If you use <span class="application">Glib</span>'s support macros, it's easier. Use
<span class="function">C_()</span> instead of <span class="function">_()</span>. For instance:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">GLib::ustring text(C_("noun", "jumps"));</pre></div>
</div>
<div class="division sect2">
<a name="i18n-composition"><!--i18n-composition--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">25.4.2. </span>Composition of strings</span></h4></div>
<p class="para block block-first">
C programmers use <span class="function">sprintf()</span> to compose and concatenate
strings. C++ favours streams, but unfortunately, this approach makes
translation difficult, because each fragment of text is translated separately,
without allowing the translators to rearrange them according to the grammar of
the language.</p>
<p class="para block">For instance, this code would be problematic:</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">std::cout &lt;&lt; _("Current amount: ") &lt;&lt; amount
          &lt;&lt; _(" Future: ") &lt;&lt; future &lt;&lt; std::endl;

label.set_text(_("Really delete ") + filename + _(" now?"));</pre></div>
<p class="para block">
So you should either avoid this situation or use
<a class="ulink" href="http://developer.gnome.org/glibmm/unstable/classGlib_1_1ustring.html" title="http://developer.gnome.org/glibmm/unstable/classGlib_1_1ustring.html"><span class="function">Glib::ustring::compose()</span></a>
which supports syntax such as:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">std::cout &lt;&lt; Glib::ustring::compose(
             _("Current amount: %1 Future: %2"), amount, future) &lt;&lt; std::endl;

label.set_text(Glib::ustring::compose(_("Really delete %1 now?"), filename));</pre></div>
</div>
<div class="division sect2">
<a name="i18n-display-size"><!--i18n-display-size--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">25.4.3. </span>Assuming the displayed size of strings</span></h4></div>
<p class="para block block-first">You never know how much space a string will take on screen when translated. It might very possibly be twice the size of the original English string. Luckily, most <span class="application">gtkmm</span> widgets will expand at runtime to the required size.</p>
</div>
<div class="division sect2">
<a name="i18n-unusual-words"><!--i18n-unusual-words--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">25.4.4. </span>Unusual words</span></h4></div>
<p class="para block block-first">You should avoid cryptic abbreviations, slang, or jargon.
          They are usually difficult to translate, and are often difficult
for even native speakers to understand. For instance, prefer "application" to "app"</p>
</div>
<div class="division sect2">
<a name="i18n-non-ascii-characters"><!--i18n-non-ascii-characters--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">25.4.5. </span>Using non-ASCII characters in strings</span></h4></div>
<p class="para block block-first">
Currently, <span class="application">gettext</span> does not support non-ASCII
characters (i.e. any characters with a code above 127) in source code. For
instance, you cannot use the copyright sign (©).
</p>
<p class="para block">To work around this, you could write a comment in the
          source code just before the string, telling the translators to
          use the special character if it is available in their languages. For English, you could then make an American English
          <span class="filename" dir="ltr">en_US.po</span> translation which used that special character.</p>
</div>
</div>
<div class="division sect1">
<a name="sec-i18n-getting-help-with-translations"><!--sec-i18n-getting-help-with-translations--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">25.5. </span>Getting help with translations</span></h3></div>
<p class="para block block-first">If your program is free software, there is a whole <span class="literal" dir="ltr">GNOME</span>
        subproject devoted to helping you make translations, the
        <a class="ulink" href="https://wiki.gnome.org/TranslationProject/" title="https://wiki.gnome.org/TranslationProject/"><span class="literal" dir="ltr">GNOME</span>
        Translation Project</a>.</p>
<p class="para block">The way it works is that you upload your source code to a git
        repository where translators can access it, then contact the gnome-i18n
        mailing list and ask to have your program added to the
        <a class="ulink" href="http://l10n.gnome.org/module/" title="http://l10n.gnome.org/module/">list of modules to translate</a>.</p>
<p class="para block">Then you make sure you update the file
        <span class="filename" dir="ltr">POTFILES.in</span> in the
        <span class="filename" dir="ltr">po/</span> subdirectory
        (<span class="command" dir="ltr">intltool-update -m</span> can help with this) so
        that the translators always access updated
        <span class="filename" dir="ltr">myprogram.pot</span> files, and simply freeze
        the strings at least a couple of days before you make a new
        release, announcing it on gnome-i18n. Depending on the number
        of strings your program contains and how popular it is, the
        translations will then start to tick in as
        <span class="filename" dir="ltr">languagename.po</span> files.</p>
<p class="para block">Note that most language teams only consist of 1-3 persons,
        so if your program contains a lot of strings, it might last a
        while before anyone has the time to look at it. Also, most
        translators do not want to waste their time (translating is
        a very time-consuming task) so if they do not assess your
        project as being really serious (in the sense that it is
        polished and being maintained) they may decide to spend their
        time on some other project.</p>
</div>
</div>
<div class="division chapter">
<a name="chapter-customwidgets"><!--chapter-customwidgets--></a><div class="header"><h2 class="chapter title"><span class="title"><span class="label">26. </span>Custom Widgets</span></h2></div>
<p class="para block block-first"><span class="application">gtkmm</span> makes it very easy to derive new widgets by inheriting from an
      existing widget class, either by deriving from a container and adding child
      widgets, or by deriving from a single-item widget, and changing its behaviour.
      But you might occasionally find that no suitable starting point already exists.
      In this case, you can implement a widget from scratch.</p>
<div class="autotoc"><ul>
<li>
<span class="label">26.1. </span><a class="xref" href="#sec-custom-containers" title="Custom Containers">Custom Containers</a>
</li>
<li>
<span class="label">26.2. </span><a class="xref" href="#sec-custom-widgets" title="Custom Widgets">Custom Widgets</a>
</li>
</ul></div>
<div class="division sect1">
<a name="sec-custom-containers"><!--sec-custom-containers--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">26.1. </span>Custom Containers</span></h3></div>
<p class="para block block-first">When deriving a custom container widget directly from <span class="classname" dir="ltr">Gtk::Widget</span>,
      you should override the following virtual methods:
    <div class="block list itemizedlist"><ul class="itemizedlist">
<li class="li-first"><span class="para"><span class="methodname" dir="ltr">get_request_mode_vfunc()</span>: Return what <span class="literal" dir="ltr">Gtk::SizeRequestMode</span> is preferred by the container.</span></li>
<li><span class="para"><span class="methodname" dir="ltr">measure_vfunc()</span>: Calculate the minimum and natural width or height of the container.</span></li>
<li><span class="para"><span class="methodname" dir="ltr">on_size_allocate()</span>: Position the child widgets, given the height and width that the container has actually been given.</span></li>
</ul></div>
    </p>
<p class="para block">The <span class="methodname" dir="ltr">get_request_mode_vfunc()</span>,
        <span class="methodname" dir="ltr">measure_vfunc()</span>, and
        <span class="methodname" dir="ltr">on_size_allocate()</span> virtual methods control the
        layout of the child widgets. For instance, if your container has 2
        child widgets, with one below the other, your
        <span class="methodname" dir="ltr">get_request_mode_vfunc()</span> might request
        height-for-width layout. Then your
        <span class="methodname" dir="ltr">measure_vfunc()</span>
        might report the maximum of the widths of the child widgets when asked
        to report width, and it might report the sum of their heights when asked
        to report height. If you want padding between
        the child widgets then you would add that to the width and height too.
        Your widget's container will use this result to ensure that your widget
        gets enough space, and not less. By examining each widget's parent, and
        its parent, this logic will eventually decide the size of the top-level
        window.</p>
<p class="para block">You are not guaranteed to get the <span class="literal" dir="ltr">Gtk::SizeRequestMode</span>
        that you request. Therefore <span class="methodname" dir="ltr">measure_vfunc()</span> must
        return sensible values for all reasonable values of its input parameters.
        For a description of <span class="methodname" dir="ltr">measure_vfunc()</span>'s parameters see
        also the description of <span class="methodname" dir="ltr">Gtk::Widget::measure()</span>, which
        may be better documented than <span class="methodname" dir="ltr">measure_vfunc()</span>.</p>
<p class="para block"><span class="methodname" dir="ltr">on_size_allocate()</span> receives the actual
       height and width that the parent container has decided to give to your
       widget. This might be more than the minimum, or even more than the natural
       size, for instance if the
       top-level window has been expanded. You might choose to ignore the extra
       space and leave a blank area, or you might choose to expand your child
       widgets to fill the space, or you might choose to expand the padding
       between your widgets. It's your container, so you decide.</p>
<div class="autotoc"><ul><li>
<span class="label">26.1.1. </span><a class="xref" href="#custom-container-example" title="Example">Example</a>
</li></ul></div>
<div class="division sect2">
<a name="custom-container-example"><!--custom-container-example--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">26.1.1. </span>Example</span></h4></div>
<p class="para block block-first">This example implements a container with two child widgets, one above
        the other. Of course, in this case it would be far simpler just to use
        a vertical <span class="classname" dir="ltr">Gtk::Box</span> or <span class="classname" dir="ltr">Gtk::Grid</span>.</p>
<div class=" block figure block-indent">
<a name="figure-custom-container"><!--figure-custom-container--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 26-1</span> </span>Custom Container</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/custom_container.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/custom/custom_container/" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/custom/custom_container/">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;
#include "mycontainer.h"

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_button_quit();

  //Child widgets:
  Gtk::Box m_VBox;
  Gtk::Button m_Button_One;
  Gtk::Label m_Label_Two;
  // A restriction with MyContainer is that it must be deleted before
  // its children, meaning that it must be declared after its children.
  MyContainer m_MyContainer;
  Gtk::Box m_ButtonBox;
  Gtk::Button m_Button_Quit;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">mycontainer.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_CUSTOM_CONTAINER_MYCONTAINER_H
#define GTKMM_CUSTOM_CONTAINER_MYCONTAINER_H

#include &lt;gtkmm/widget.h&gt;

class MyContainer : public Gtk::Widget
{
public:
  MyContainer();
  virtual ~MyContainer();

  void set_child_widgets(Gtk::Widget&amp; child_one, Gtk::Widget&amp; child_two);

protected:

  //Overrides:
  Gtk::SizeRequestMode get_request_mode_vfunc() const override;
  void measure_vfunc(Gtk::Orientation orientation, int for_size, int&amp; minimum, int&amp; natural,
    int&amp; minimum_baseline, int&amp; natural_baseline) const override;
  void size_allocate_vfunc(int width, int height, int baseline) override;
#if 0
  void forall_vfunc(const ForeachSlot&amp; slot) override;

  void on_add(Gtk::Widget* child) override;
  void on_remove(Gtk::Widget* child) override;
  GType child_type_vfunc() const override;
#endif
  Gtk::Widget* m_child_one;
  Gtk::Widget* m_child_two;
};

#endif //GTKMM_CUSTOM_CONTAINER_MYCONTAINER_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;gtkmm/application.h&gt;

int main(int argc, char *argv[])
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  //Shows the window and returns when it is closed.
  return app-&gt;make_window_and_run&lt;ExampleWindow&gt;(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include &lt;iostream&gt;
#include "examplewindow.h"

ExampleWindow::ExampleWindow()
: m_VBox(Gtk::Orientation::VERTICAL),
  m_Button_One("Child One"),
  m_Label_Two("Child 2", Gtk::Align::END, Gtk::Align::CENTER),
  m_Button_Quit("Quit")
{
  set_title("Custom Container example");
  set_default_size(400, 200);

  m_VBox.set_margin(6);
  set_child(m_VBox);

  //Add the child widgets to the custom container:
  m_MyContainer.set_child_widgets(m_Button_One, m_Label_Two);
  m_MyContainer.set_expand();

  m_VBox.append(m_MyContainer);
  m_VBox.append(m_ButtonBox);

  m_ButtonBox.append(m_Button_Quit);
  m_ButtonBox.set_margin(6);
  m_Button_Quit.set_hexpand(true);
  m_Button_Quit.set_halign(Gtk::Align::END);
  m_Button_Quit.signal_clicked().connect( sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_quit) );
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_button_quit()
{
  hide();
}

</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">mycontainer.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include &lt;iostream&gt;
#include &lt;algorithm&gt; // std::max
#include "mycontainer.h"

MyContainer::MyContainer()
: m_child_one(nullptr), m_child_two(nullptr)
{
}

MyContainer::~MyContainer()
{
  if (m_child_one)
    m_child_one-&gt;unparent();

  if (m_child_two)
    m_child_two-&gt;unparent();
}

void MyContainer::set_child_widgets(Gtk::Widget&amp; child_one,
        Gtk::Widget&amp; child_two)
{
  m_child_one = &amp;child_one;
  m_child_two = &amp;child_two;

  m_child_one-&gt;set_parent(*this);
  m_child_two-&gt;set_parent(*this);
}

// This example container is a simplified vertical Box with at most two children.
Gtk::SizeRequestMode MyContainer::get_request_mode_vfunc() const
{
  return Gtk::SizeRequestMode::HEIGHT_FOR_WIDTH;
}

// Discover the total amount of minimum space and natural space needed by
// this container and its children.
void MyContainer::measure_vfunc(Gtk::Orientation orientation, int for_size,
  int&amp; minimum, int&amp; natural, int&amp; minimum_baseline, int&amp; natural_baseline) const
{
  // Don't use baseline alignment.
  minimum_baseline = -1;
  natural_baseline = -1;

  int dummy_minimum_baseline = 0;
  int dummy_natural_baseline = 0;

  if (orientation == Gtk::Orientation::HORIZONTAL)
  {
    int height_per_child = for_size;

    if (for_size &gt;= 0)
    {
      int nvis_children = 0;

      // Get number of visible children.
      if (m_child_one &amp;&amp; m_child_one-&gt;get_visible())
        ++nvis_children;
      if (m_child_two &amp;&amp; m_child_two-&gt;get_visible())
        ++nvis_children;

      // Divide the height equally among the visible children.
      if (nvis_children &gt; 0)
        height_per_child = for_size / nvis_children;
    }

    int child_minimum_width[2] = {0, 0};
    int child_natural_width[2] = {0, 0};

    if (m_child_one &amp;&amp; m_child_one-&gt;get_visible())
      m_child_one-&gt;measure(orientation, height_per_child, child_minimum_width[0],
        child_natural_width[0], dummy_minimum_baseline, dummy_natural_baseline);

    if (m_child_two &amp;&amp; m_child_two-&gt;get_visible())
      m_child_two-&gt;measure(orientation, height_per_child, child_minimum_width[1],
        child_natural_width[1], dummy_minimum_baseline, dummy_natural_baseline);

    // Request a width equal to the width of the widest visible child.
    minimum = std::max(child_minimum_width[0], child_minimum_width[1]);
    natural = std::max(child_natural_width[0], child_natural_width[1]);
  }
  else // Gtk::Orientation::VERTICAL
  {
    int child_minimum_height[2] = {0, 0};
    int child_natural_height[2] = {0, 0};
    int nvis_children = 0;

    if (m_child_one &amp;&amp; m_child_one-&gt;get_visible())
    {
      ++nvis_children;
      m_child_one-&gt;measure(orientation, for_size, child_minimum_height[0],
        child_natural_height[0], dummy_minimum_baseline, dummy_natural_baseline);
    }

    if (m_child_two &amp;&amp; m_child_two-&gt;get_visible())
    {
      ++nvis_children;
      m_child_two-&gt;measure(orientation, for_size, child_minimum_height[1],
        child_natural_height[1], dummy_minimum_baseline, dummy_natural_baseline);
    }

    // The allocated height will be divided equally among the visible children.
    // Request a height equal to the number of visible children times the height
    // of the highest child.
    minimum = nvis_children * std::max(child_minimum_height[0],
                                       child_minimum_height[1]);
    natural = nvis_children * std::max(child_natural_height[0],
                                       child_natural_height[1]);
  }
}

void MyContainer::size_allocate_vfunc(int width, int height, int  baseline)
{
  //Do something with the space that we have actually been given:
  //(We will not be given heights or widths less than we have requested, though
  //we might get more.)

  //Get number of visible children.
  const bool visible_one = m_child_one &amp;&amp; m_child_one-&gt;get_visible();
  const bool visible_two = m_child_two &amp;&amp; m_child_two-&gt;get_visible();
  int nvis_children = 0;
  if (visible_one)
    ++nvis_children;
  if (visible_two)
    ++nvis_children;

  if (nvis_children &lt;= 0)
  {
    // No visible child.
    return;
  }

  //Assign space to the children:
  Gtk::Allocation child_allocation_one;
  Gtk::Allocation child_allocation_two;

  //Place the first child at the top-left:
  child_allocation_one.set_x(0);
  child_allocation_one.set_y(0);

  //Make it take up the full width available:
  child_allocation_one.set_width(width);

  if (visible_one)
  {
    //Divide the height equally among the visible children.
    child_allocation_one.set_height(height / nvis_children);
    m_child_one-&gt;size_allocate(child_allocation_one, baseline);
  }
  else
    child_allocation_one.set_height(0);

  //Place the second child below the first child:
  child_allocation_two.set_x(0);
  child_allocation_two.set_y(child_allocation_one.get_height());

  //Make it take up the full width available:
  child_allocation_two.set_width(width);

  //Make it take up the remaining height:
  child_allocation_two.set_height(height - child_allocation_one.get_height());

  if (visible_two)
  {
    m_child_two-&gt;size_allocate(child_allocation_two, baseline);
  }
}
#if 0
void MyContainer::forall_vfunc(const ForeachSlot&amp; slot)
{
  if (m_child_one)
    slot(*m_child_one);

  if (m_child_two)
    slot(*m_child_two);
}

void MyContainer::on_add(Gtk::Widget* child)
{
  if(!m_child_one)
  {
    m_child_one = child;
    m_child_one-&gt;set_parent(*this);
  }
  else if(!m_child_two)
  {
    m_child_two = child;
    m_child_two-&gt;set_parent(*this);
  }
}

void MyContainer::on_remove(Gtk::Widget* child)
{
  if(child)
  {
    const bool visible = child-&gt;get_visible();
    bool found = false;

    if(child == m_child_one)
    {
      m_child_one = nullptr;
      found = true;
    }
    else if(child == m_child_two)
    {
      m_child_two = nullptr;
      found = true;
    }

    if(found)
    {
      child-&gt;unparent();

      if(visible)
        queue_resize();
    }
  }
}

GType MyContainer::child_type_vfunc() const
{
  //If there is still space for one widget, then report the type of widget that
  //may be added.
  if(!m_child_one || !m_child_two)
    return Gtk::Widget::get_type();
  else
  {
    //No more widgets may be added.
    return G_TYPE_NONE;
  }
}
#endif
</pre></div>
</div>
</div>
<div class="division sect1">
<a name="sec-custom-widgets"><!--sec-custom-widgets--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">26.2. </span>Custom Widgets</span></h3></div>
<p class="para block block-first">By deriving directly from <span class="classname" dir="ltr">Gtk::Widget</span> you can
        do all the drawing for your widget directly, instead of just arranging
        child widgets. For instance, a <span class="classname" dir="ltr">Gtk::Label</span> draws
        the text of the label, but does not do this by using other
        widgets.</p>
<p class="para block">When deriving from <span class="classname" dir="ltr">Gtk::Widget</span>, you should
        override the following virtual methods. The methods marked (optional)
        need not be overridden in all custom widgets. The base class's methods
        may be appropriate.
    <div class="block list itemizedlist"><ul class="itemizedlist">
<li class="li-first"><span class="para"><span class="methodname" dir="ltr">get_request_mode_vfunc()</span>: (optional) Return what <span class="literal" dir="ltr">Gtk::SizeRequestMode</span> is preferred by the widget.</span></li>
<li><span class="para"><span class="methodname" dir="ltr">measure_vfunc()</span>: Calculate the minimum and natural width or height of the widget.</span></li>
<li><span class="para"><span class="methodname" dir="ltr">on_size_allocate()</span>: Position the widget, given the height and width that it has actually been given.</span></li>
<li><span class="para"><span class="methodname" dir="ltr">on_realize()</span>: Associate a <span class="classname" dir="ltr">Gdk::Surface</span> with the widget.</span></li>
<li><span class="para"><span class="methodname" dir="ltr">on_unrealize()</span>: (optional) Break the association with the <span class="classname" dir="ltr">Gdk::Surface</span>. </span></li>
<li><span class="para"><span class="methodname" dir="ltr">on_map()</span>: (optional)</span></li>
<li><span class="para"><span class="methodname" dir="ltr">on_unmap()</span>: (optional)</span></li>
<li><span class="para"><span class="methodname" dir="ltr">snapshot_vfunc()</span>: Create a render node, e.g. a <span class="classname" dir="ltr">Cairo::Context</span> node, and draw on it.</span></li>
</ul></div>
    </p>
<p class="para block">The first 3 methods in the previous table are also overridden in custom
        containers. They are briefly described in the
        <a class="link" href="#sec-custom-containers" title="Custom Containers">Custom Containers</a> section.
    </p>
<div class="autotoc"><ul>
<li>
<span class="label">26.2.1. </span><a class="xref" href="#custom-init-functions" title="Class Init and Instance Init Functions">Class Init and Instance Init Functions</a>
</li>
<li>
<span class="label">26.2.2. </span><a class="xref" href="#custom-style-information" title="Custom Style Information">Custom Style Information</a>
</li>
<li>
<span class="label">26.2.3. </span><a class="xref" href="#custom-widget-example" title="Example">Example</a>
</li>
</ul></div>
<div class="division sect2">
<a name="custom-init-functions"><!--custom-init-functions--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">26.2.1. </span>Class Init and Instance Init Functions</span></h4></div>
<p class="para block block-first">Some <span class="application">GTK</span> functions, if called at all, must be
called from the class init function. Some other <span class="application">GTK</span>
functions, if called, must be called from the instance init function.
If your custom widget must call any of those functions, you can derive a class
from <span class="classname" dir="ltr">Glib::ExtraClassInit</span> and derive your custom class
from that class. The following example shows how that's done.</p>
</div>
<div class="division sect2">
<a name="custom-style-information"><!--custom-style-information--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">26.2.2. </span>Custom Style Information</span></h4></div>
<p class="para block block-first">Your widget class, whether it's derived directly from
<span class="classname" dir="ltr">Gtk::Widget</span> or from another widget class,
can read some style information from a CSS (Cascading Style Sheets) file. The users
of your widget, or the users of an application program with your widget, can then
modify the style of your widget without modifying the source code. Useful classes
are <span class="classname" dir="ltr">Gtk::StyleContext</span> and <span class="classname" dir="ltr">Gtk::CssProvider</span>.
With the methods of <span class="classname" dir="ltr">Gtk::StyleContext</span> you can read the values
of your widget's style information. CSS files are described in the documentation of
<span class="application">GTK</span>. The following example shows a simple use of
<span class="methodname" dir="ltr">Gtk::StyleContext::get_padding()</span>.</p>
</div>
<div class="division sect2">
<a name="custom-widget-example"><!--custom-widget-example--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">26.2.3. </span>Example</span></h4></div>
<p class="para block block-first">This example implements a widget which draws Penrose triangles.</p>
<div class=" block figure block-indent">
<a name="figure-custom-widget"><!--figure-custom-widget--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 26-2</span> </span>Custom Widget</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/custom_widget.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/custom/custom_widget/" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/custom/custom_widget/">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;
#include "mywidget.h"

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_button_quit();

  //Child widgets:
  Gtk::Grid m_Grid;
  MyWidget m_MyWidgetS1;
  MyWidget m_MyWidgetS2;
  Gtk::Box m_ButtonBox;
  Gtk::Button m_Button_Quit;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">mywidget.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_CUSTOM_WIDGET_MYWIDGET_H
#define GTKMM_CUSTOM_WIDGET_MYWIDGET_H

#include &lt;gtkmm/widget.h&gt;
#include &lt;gtkmm/cssprovider.h&gt;
#include "myextrainit.h"

class MyWidget
:
public MyExtraInit,
public Gtk::Widget
{
public:
  MyWidget();
  virtual ~MyWidget();

protected:

  //Overrides:
  Gtk::SizeRequestMode get_request_mode_vfunc() const override;
  void measure_vfunc(Gtk::Orientation orientation, int for_size, int&amp; minimum, int&amp; natural,
    int&amp; minimum_baseline, int&amp; natural_baseline) const override;
  void on_map() override;
  void on_unmap() override;
  void on_realize() override;
  void on_unrealize() override;
  void snapshot_vfunc(const Glib::RefPtr&lt;Gtk::Snapshot&gt;&amp; snapshot) override;

  //Signal handler:
  void on_parsing_error(const Glib::RefPtr&lt;const Gtk::CssSection&gt;&amp; section, const Glib::Error&amp; error);

  Gtk::Border m_padding;
  Glib::RefPtr&lt;Gtk::CssProvider&gt; m_refCssProvider;
};

#endif //GTKMM_CUSTOM_WIDGET_MYWIDGET_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">myextrainit.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_CUSTOM_WIDGET_MYEXTRAINIT_H
#define GTKMM_CUSTOM_WIDGET_MYEXTRAINIT_H

#include &lt;glibmm/extraclassinit.h&gt;
#include &lt;glibmm/ustring.h&gt;

// Calls gtk_widget_class_set_css_name() in the class init function
// and gtk_set_has_window() in the instance init function.
class MyExtraInit : public Glib::ExtraClassInit
{
public:
  MyExtraInit(const Glib::ustring&amp; css_name);

private:
  Glib::ustring m_css_name;
};

#endif //GTKMM_CUSTOM_WIDGET_MYEXTRAINIT_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;gtkmm/application.h&gt;

int main(int argc, char *argv[])
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  //Shows the window and returns when it is closed.
  return app-&gt;make_window_and_run&lt;ExampleWindow&gt;(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"

ExampleWindow::ExampleWindow()
: m_Button_Quit("Quit")
{
  set_title("Custom Widget example");
  set_default_size(600, 400);

  m_Grid.set_margin(6);
  m_Grid.set_row_spacing(10);
  m_Grid.set_column_spacing(10);

  set_child(m_Grid);

  m_Grid.attach(m_MyWidgetS1, 0, 0);
  m_Grid.attach(m_MyWidgetS2, 1, 1);

  m_Grid.attach(m_ButtonBox, 0, 2, 2, 1);

  m_ButtonBox.append(m_Button_Quit);
  m_ButtonBox.set_margin(6);
  m_Button_Quit.set_hexpand(true);
  m_Button_Quit.set_halign(Gtk::Align::END);
  m_Button_Quit.signal_clicked().connect( sigc::mem_fun(*this, &amp;ExampleWindow::on_button_quit) );
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_button_quit()
{
  hide();
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">myextrainit.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "myextrainit.h"
#include &lt;gtkmm/widget.h&gt;
#include &lt;gtk/gtk.h&gt;

namespace
{
using BaseObjectType = GtkWidget;
using BaseClassType = GtkWidgetClass;

// Extra class init function.
void class_init_function(void* g_class, void* class_data)
{
  g_return_if_fail(GTK_IS_WIDGET_CLASS(g_class));

  const auto klass = static_cast&lt;BaseClassType*&gt;(g_class);
  const auto css_name = static_cast&lt;Glib::ustring*&gt;(class_data);

  gtk_widget_class_set_css_name(klass, css_name-&gt;c_str());
}

// Extra instance init function.
void instance_init_function(GTypeInstance* instance, void* /* g_class */)
{
  g_return_if_fail(GTK_IS_WIDGET(instance));

  // Nothing to do here.
  // This extra instance init function just shows how such a function can
  // be added to a custom widget, if necessary.
}

} // anonymous namespace

MyExtraInit::MyExtraInit(const Glib::ustring&amp; css_name)
:
Glib::ExtraClassInit(class_init_function, &amp;m_css_name, instance_init_function),
m_css_name(css_name)
{
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">mywidget.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "mywidget.h"
#include &lt;gdkmm/general.h&gt;  // for cairo helper functions
#include &lt;gtkmm/snapshot.h&gt;
#include &lt;iostream&gt;
//#include &lt;gtk/gtkwidget.h&gt; //For GTK_IS_WIDGET()
#include &lt;cstring&gt;


MyWidget::MyWidget() :
  //The GType name will actually be gtkmm__CustomObject_MyWidget
  Glib::ObjectBase("MyWidget"),
  MyExtraInit("my-widget"), // CSS node name, which must be used in the CSS file.
  Gtk::Widget(),
  m_padding()
{
  // Expand, if there is extra space.
  set_expand(true);

  //This shows the GType name.
  std::cout &lt;&lt; "GType name: " &lt;&lt; G_OBJECT_TYPE_NAME(gobj()) &lt;&lt; std::endl;

  //This shows that the GType still derives from GtkWidget:
  //std::cout &lt;&lt; "Gtype is a GtkWidget?:" &lt;&lt; GTK_IS_WIDGET(gobj()) &lt;&lt; std::endl;

  // The CSS name can be set either
  // - for a GType (in this case for your custom class) with gtk_widget_class_set_css_name(), or
  // - for a widget instance with gtk_widget_set_name() (Gtk::Widget::set_name()).
  //
  // gtk_widget_class_set_css_name(), if used, must be called in the class init function.
  // It has not been wrapped in a C++ function.
  // Gtk::Widget::set_name() can be called in a C++ constructor.
  //
  // Another alternative: The custom widget inherits the CSS name "widget" from
  // GtkWidget. That name can be used in the CSS file. This is not a very good
  // alternative. GtkWidget's CSS name is not documented. It can probably be
  // changed or removed in the future.

  m_refCssProvider = Gtk::CssProvider::create();
  auto refStyleContext = get_style_context();
  refStyleContext-&gt;add_provider(m_refCssProvider,
    GTK_STYLE_PROVIDER_PRIORITY_APPLICATION);
  m_refCssProvider-&gt;signal_parsing_error().connect(
    sigc::mem_fun(*this, &amp;MyWidget::on_parsing_error));

  m_refCssProvider-&gt;load_from_path("custom_gtk.css");
}

MyWidget::~MyWidget()
{
}

Gtk::SizeRequestMode MyWidget::get_request_mode_vfunc() const
{
  //Accept the default value supplied by the base class.
  return Gtk::Widget::get_request_mode_vfunc();
}

//Discover the total amount of minimum space and natural space needed by
//this widget.
//Let's make this simple example widget always need minimum 60 by 50 and
//natural 100 by 70.
void MyWidget::measure_vfunc(Gtk::Orientation orientation, int /* for_size */,
  int&amp; minimum, int&amp; natural, int&amp; minimum_baseline, int&amp; natural_baseline) const
{
  if (orientation == Gtk::Orientation::HORIZONTAL)
  {
    minimum = 60;
    natural = 100;
  }
  else
  {
    minimum = 50;
    natural = 70;
  }

  // Don't use baseline alignment.
  minimum_baseline = -1;
  natural_baseline = -1;
}

void MyWidget::on_map()
{
  //Call base class:
  Gtk::Widget::on_map();
}

void MyWidget::on_unmap()
{
  //Call base class:
  Gtk::Widget::on_unmap();
}

void MyWidget::on_realize()
{
  //Get the themed padding from the CSS file:
  m_padding = get_style_context()-&gt;get_padding();
  std::cout &lt;&lt; "m_padding from the theme/css-file is"
    &lt;&lt; ": top=" &lt;&lt; m_padding.get_top()
    &lt;&lt; ", right=" &lt;&lt; m_padding.get_right()
    &lt;&lt; ", bottom=" &lt;&lt; m_padding.get_bottom()
    &lt;&lt; ", left=" &lt;&lt; m_padding.get_left() &lt;&lt; std::endl;

  //Call base class:
  Gtk::Widget::on_realize();
}

void MyWidget::on_unrealize()
{
  //Call base class:
  Gtk::Widget::on_unrealize();
}

void MyWidget::snapshot_vfunc(const Glib::RefPtr&lt;Gtk::Snapshot&gt;&amp; snapshot)
{
  const auto allocation = get_allocation();
  const Gdk::Rectangle rect(0, 0, allocation.get_width(), allocation.get_height());
  auto refStyleContext = get_style_context();

  // Create a cairo context to draw on.
  auto cr = snapshot-&gt;append_cairo(rect);

  // paint the background
  refStyleContext-&gt;render_background(cr,
    -m_padding.get_left(), -m_padding.get_top(), allocation.get_width(), allocation.get_height());

  // draw the foreground
  const double scale_x = 0.001 * (allocation.get_width() - m_padding.get_left() - m_padding.get_right());
  const double scale_y = 0.001 * (allocation.get_height() - m_padding.get_top() - m_padding.get_bottom());
  Gdk::Cairo::set_source_rgba(cr, refStyleContext-&gt;get_color());
  cr-&gt;rectangle(0.0, 0.0, 1000.0*scale_x, 1000.0*scale_y);
  cr-&gt;move_to(155.*scale_x, 165.*scale_y);
  cr-&gt;line_to(155.*scale_x, 838.*scale_y);
  cr-&gt;line_to(265.*scale_x, 900.*scale_y);
  cr-&gt;line_to(849.*scale_x, 564.*scale_y);
  cr-&gt;line_to(849.*scale_x, 438.*scale_y);
  cr-&gt;line_to(265.*scale_x, 100.*scale_y);
  cr-&gt;line_to(155.*scale_x, 165.*scale_y);
  cr-&gt;move_to(265.*scale_x, 100.*scale_y);
  cr-&gt;line_to(265.*scale_x, 652.*scale_y);
  cr-&gt;line_to(526.*scale_x, 502.*scale_y);
  cr-&gt;move_to(369.*scale_x, 411.*scale_y);
  cr-&gt;line_to(633.*scale_x, 564.*scale_y);
  cr-&gt;move_to(369.*scale_x, 286.*scale_y);
  cr-&gt;line_to(369.*scale_x, 592.*scale_y);
  cr-&gt;move_to(369.*scale_x, 286.*scale_y);
  cr-&gt;line_to(849.*scale_x, 564.*scale_y);
  cr-&gt;move_to(633.*scale_x, 564.*scale_y);
  cr-&gt;line_to(155.*scale_x, 838.*scale_y);
  cr-&gt;stroke();
}

void MyWidget::on_parsing_error(const Glib::RefPtr&lt;const Gtk::CssSection&gt;&amp; section, const Glib::Error&amp; error)
{
  std::cerr &lt;&lt; "on_parsing_error(): " &lt;&lt; error.what() &lt;&lt; std::endl;
  if (section)
  {
    const auto file = section-&gt;get_file();
    if (file)
    {
      std::cerr &lt;&lt; "  URI = " &lt;&lt; file-&gt;get_uri() &lt;&lt; std::endl;
    }

    auto start_location = section-&gt;get_start_location();
    auto end_location = section-&gt;get_end_location();
    std::cerr &lt;&lt; "  start_line = " &lt;&lt; start_location.get_lines()+1
              &lt;&lt; ", end_line = " &lt;&lt; end_location.get_lines()+1 &lt;&lt; std::endl;
    std::cerr &lt;&lt; "  start_position = " &lt;&lt; start_location.get_line_chars()
              &lt;&lt; ", end_position = " &lt;&lt; end_location.get_line_chars() &lt;&lt; std::endl;
  }
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">custom_gtk.css</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">/* Example of a CSS style sheet. */

my-widget {
  background-color: rgb(255,0,0);
  color:            rgb(0,0,255);
  padding:          10px 15px 20px 5px; /* top right bottom left */
}
</pre></div>
</div>
</div>
</div>
<div class="division chapter">
<a name="chapter-multi-threaded-programs"><!--chapter-multi-threaded-programs--></a><div class="header"><h2 class="chapter title"><span class="title"><span class="label">27. </span>Multi-threaded programs</span></h2></div>
<div class="autotoc"><ul>
<li>
<span class="label">27.1. </span><a class="xref" href="#sec-the-constraints" title="The constraints">The constraints</a>
</li>
<li>
<span class="label">27.2. </span><a class="xref" href="#sec-using-glib-dispatcher" title="Using Glib::Dispatcher">Using Glib::Dispatcher</a>
</li>
<li>
<span class="label">27.3. </span><a class="xref" href="#sec-multithread-example" title="Example">Example</a>
</li>
</ul></div>
<div class="division sect1">
<a name="sec-the-constraints"><!--sec-the-constraints--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">27.1. </span>The constraints</span></h3></div>
<p class="para block block-first">
Care is required when writing programs based on <span class="application">gtkmm</span> using
multiple threads of execution, arising from the fact that
<span class="application">libsigc++</span>, and in particular
<span class="classname" dir="ltr">sigc::trackable</span>, are not thread-safe. That's
because none of the complex interactions that occur behind the scenes
when using <span class="application">libsigc++</span> are protected by a
mutex or other means of synchronization.
<a name="-noteref-idm140176212139568"></a><sup><a class="footnote" href="#-note-idm140176212139568">1</a></sup>
</p>
<div class="autotoc"><ul><li>
<span class="label">27.1.1. </span><a class="xref" href="#the-rules" title="The rules">The rules</a>
</li></ul></div>
<div class="division sect2">
<a name="the-rules"><!--the-rules--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">27.1.1. </span>The rules</span></h4></div>
<p class="para block block-first">
This requires a number of rules to be observed when writing
multi-threaded programs using <span class="application">gtkmm</span>. These are set out below, but
one point to note is that extra care is required when deriving classes
from <span class="classname" dir="ltr">sigc::trackable</span>, because the effects are
unintuitive (see particularly points 4 and 5 below).
</p>
<div class="block list orderedlist"><ol class="orderedlist">
<li class="li-first">
<p class="para block block-first">
Use <span class="classname" dir="ltr">Glib::Dispatcher</span> to invoke <span class="application">gtkmm</span> functions
from worker threads (this is dealt with in more detail in the next
section).
</p>
</li>
<li>
<p class="para block block-first">
A <span class="classname" dir="ltr">sigc::signal</span> object should be regarded as
owned by the thread which created it. Only that thread should connect
a <span class="classname" dir="ltr">sigc::slot</span> object to the signal object, and
only that thread should <span class="methodname" dir="ltr">emit()</span> or call
<span class="methodname" dir="ltr">operator()()</span> on the signal, or null any
connected <span class="classname" dir="ltr">sigc::slot</span> object. It follows
(amongst other things) that any signal object provided by a <span class="application">gtkmm</span>
widget should only be operated on in the main GUI thread and any
object deriving from <span class="classname" dir="ltr">sigc::trackable</span> having its
non-static methods referenced by slots connected to the signal object
should only be destroyed in that thread.
</p>
</li>
<li>
<p class="para block block-first">
Any <span class="classname" dir="ltr">sigc::connection</span> object should be regarded
as owned by the thread in which the method returning the
<span class="classname" dir="ltr">sigc::connection</span> object was called. Only that
thread should call <span class="classname" dir="ltr">sigc::connection</span> methods on
the object.
</p>
</li>
<li>
<p class="para block block-first">
A <span class="classname" dir="ltr">sigc::slot</span> object created by a call to
<span class="function">sigc::mem_fun()</span> which references a method of a
class deriving from <span class="classname" dir="ltr">sigc::trackable</span> should
never be copied to another thread, nor destroyed by a different thread
than the one which created it.
</p>
</li>
<li>
<p class="para block block-first">
If a particular class object derives from
<span class="classname" dir="ltr">sigc::trackable</span>, only one thread should create
<span class="classname" dir="ltr">sigc::slot</span> objects representing any of the
class's non-static methods by calling
<span class="function">sigc::mem_fun()</span>. The first thread to create such
a slot should be regarded as owning the relevant object for the
purpose of creating further slots referencing <span class="emphasis">any</span>
of its non-static methods using that function, or nulling those slots
by disconnecting them or destroying the trackable object.
</p>
</li>
<li>
<p class="para block block-first">
Although <span class="application">glib</span> is itself thread-safe, any
<span class="application">glibmm</span> wrappers which use
<span class="application">libsigc++</span> will not be. So for example, only
the thread in which a main loop runs should call
<span class="methodname" dir="ltr">Glib::SignalIdle::connect()</span>,
<span class="methodname" dir="ltr">Glib::SignalIO::connect()</span>,
<span class="methodname" dir="ltr">Glib::SignalTimeout::connect()</span>,
<span class="methodname" dir="ltr">Glib::SignalTimeout::connect_seconds</span>
for that main loop, or manipulate any
<span class="classname" dir="ltr">sigc::connection</span> object returned by them.
</p>
<p class="para block">
The connect*_once() variants,
<span class="methodname" dir="ltr">Glib::SignalIdle::connect_once()</span>,
<span class="methodname" dir="ltr">Glib::SignalTimeout::connect_once()</span>,
<span class="methodname" dir="ltr">Glib::SignalTimeout::connect_seconds_once()</span>,
are thread-safe for any case where the slot is not created by a call to
<span class="function">sigc::mem_fun()</span> which represents a method of a class
deriving from <span class="classname" dir="ltr">sigc::trackable</span>.
</p>
</li>
</ol></div>
</div>
</div>
<div class="division sect1">
<a name="sec-using-glib-dispatcher"><!--sec-using-glib-dispatcher--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">27.2. </span>Using Glib::Dispatcher</span></h3></div>
<p class="para block block-first">
The slots connected to <span class="classname" dir="ltr">sigc::signal</span> objects
execute in the thread which calls <span class="methodname" dir="ltr">emit()</span> or
<span class="methodname" dir="ltr">operator()()</span> on the signal.
<span class="classname" dir="ltr">Glib::Dispatcher</span> does not behave this way:
instead its connected slots execute in the thread in which the
<span class="classname" dir="ltr">Glib::Dispatcher</span> object was constructed (which
must have a glib main loop). If a
<span class="classname" dir="ltr">Glib::Dispatcher</span> object is constructed in the
main GUI thread (which will therefore be the receiver thread), any
worker thread can emit on it and have the connected slots safely
execute <span class="application">gtkmm</span> functions.
</p>
<p class="para block">
Some thread safety rules on the use of
<span class="classname" dir="ltr">Glib::Dispatcher</span> still apply. As mentioned, a
<span class="classname" dir="ltr">Glib::Dispatcher</span> object must be constructed in
the receiver thread (the thread in whose main loop it will execute its
connected slots). By default this is the main program thread, although
there is a <span class="classname" dir="ltr">Glib::Dispatcher</span> constructor which
can take the <span class="classname" dir="ltr">Glib::MainContext</span> object of any
thread which has a main loop. Only the receiver thread should call
<span class="methodname" dir="ltr">connect()</span> on the
<span class="classname" dir="ltr">Glib::Dispatcher</span> object, or manipulate any
related <span class="classname" dir="ltr">sigc::connection</span> object, unless
additional synchronization is employed. However, any worker thread can
safely emit on the <span class="classname" dir="ltr">Glib::Dispatcher</span> object
without any locking once the receiver thread has connected the slots,
provided that it is constructed before the worker thread is started
(if it is constructed after the thread has started, additional
synchronization will normally be required to ensure visibility).
</p>
<p class="para block">
Aside from the fact that connected slots always execute in the
receiver thread, <span class="classname" dir="ltr">Glib::Dispatcher</span> objects are
similar to <span class="classname" dir="ltr">sigc::signal&lt;void()&gt;</span> objects.
They therefore cannot pass unbound arguments nor return a value. The
best way to pass unbound arguments is with a thread-safe
(asynchronous) queue. At the time of writing
<span class="application">glibmm</span> does not have one, although most
people writing multi-threaded code will have one available to them
(they are relatively easy to write although there are subtleties in
combining thread safety with strong exception safety).
</p>
<p class="para block">
A <span class="classname" dir="ltr">Glib::Dispatcher</span> object can be emitted on by
the receiver thread as well as by a worker thread, although this
should be done within reasonable bounds. On unix-like systems
<span class="classname" dir="ltr">Glib::Dispatcher</span> objects share a single common
pipe, which could in theory at least fill up on a very heavily loaded
system running a program with a very large number of
<span class="classname" dir="ltr">Dispatcher</span> objects in use. Were the pipe to
fill up before the receiver thread's main loop has had an opportunity
to read from it to empty it, and the receiver thread attempt to emit
and so write to it when it is in that condition, the receiver thread
would block on the write, so deadlocking. Where the receiver thread is
to emit, a normal <span class="classname" dir="ltr">sigc::signal&lt;void()&gt;</span>
object could of course be used instead.
</p>
</div>
<div class="division sect1">
<a name="sec-multithread-example"><!--sec-multithread-example--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">27.3. </span>Example</span></h3></div>
<p class="para block block-first">
This is an example program with two threads, one GUI thread, like in all
<span class="application">gtkmm</span> programs, and one worker thread. The worker thread is created when you
press the <span class="literal" dir="ltr">Start work</span> button. It is deleted when the work is
finished, when you press the <span class="literal" dir="ltr">Stop work</span> button, or when you
press the <span class="literal" dir="ltr">Quit</span> button.
</p>
<p class="para block">
A <span class="classname" dir="ltr">Glib::Dispatcher</span> is used for sending notifications
from the worker thread to the GUI thread. The <span class="classname" dir="ltr">ExampleWorker</span>
class contains data which is accessed by both threads. This data is protected
by a <span class="classname" dir="ltr">std::mutex</span>.
Only the GUI thread updates the GUI.
</p>
<p class="para block">
Compiling and linking a multi-threaded program can require special compiler and
linker options. If you use the <span class="application">g++</span> compiler, add the
<span class="literal" dir="ltr">-pthread</span> option. Other compilers may require other options.
If you build with <span class="application">meson</span>, it handles the multi-threading
complications for you, if you add <span class="function">dependency('threads')</span>.
</p>
<div class=" block figure block-indent">
<a name="figure-multithread"><!--figure-multithread--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 27-1</span> </span>Multi-Threaded Program</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/multithread.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/multithread" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/multithread">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;
#include "exampleworker.h"

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();

  // Called from the worker thread.
  void notify();

private:
  // Signal handlers.
  void on_start_button_clicked();
  void on_stop_button_clicked();
  void on_quit_button_clicked();

  void update_start_stop_buttons();
  void update_widgets();

  // Dispatcher handler.
  void on_notification_from_worker_thread();

  // Member data.
  Gtk::Box m_VBox;
  Gtk::Box m_ButtonBox;
  Gtk::Button m_ButtonStart;
  Gtk::Button m_ButtonStop;
  Gtk::Button m_ButtonQuit;
  Gtk::ProgressBar m_ProgressBar;
  Gtk::ScrolledWindow m_ScrolledWindow;
  Gtk::TextView m_TextView;

  Glib::Dispatcher m_Dispatcher;
  ExampleWorker m_Worker;
  std::thread* m_WorkerThread;
};

#endif // GTKMM_EXAMPLEWINDOW_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">exampleworker.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEWORKER_H
#define GTKMM_EXAMPLEWORKER_H

#include &lt;gtkmm.h&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;

class ExampleWindow;

class ExampleWorker
{
public:
  ExampleWorker();

  // Thread function.
  void do_work(ExampleWindow* caller);

  void get_data(double* fraction_done, Glib::ustring* message) const;
  void stop_work();
  bool has_stopped() const;

private:
  // Synchronizes access to member data.
  mutable std::mutex m_Mutex;

  // Data used by both GUI thread and worker thread.
  bool m_shall_stop;
  bool m_has_stopped;
  double m_fraction_done;
  Glib::ustring m_message;
};

#endif // GTKMM_EXAMPLEWORKER_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;gtkmm/application.h&gt;

int main(int argc, char* argv[])
{
  auto app = Gtk::Application::create("org.gtkmm.example");

  //Shows the window and returns when it is closed.
  return app-&gt;make_window_and_run&lt;ExampleWindow&gt;(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">examplewindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "examplewindow.h"
#include &lt;iostream&gt;

ExampleWindow::ExampleWindow() :
  m_VBox(Gtk::Orientation::VERTICAL, 5),
  m_ButtonBox(Gtk::Orientation::HORIZONTAL),
  m_ButtonStart("Start work"),
  m_ButtonStop("Stop work"),
  m_ButtonQuit("_Quit", /* mnemonic= */ true),
  m_ProgressBar(),
  m_ScrolledWindow(),
  m_TextView(),
  m_Dispatcher(),
  m_Worker(),
  m_WorkerThread(nullptr)
{
  set_title("Multi-threaded example");
  set_default_size(300, 300);

  m_VBox.set_margin(5);
  set_child(m_VBox);

  // Add the ProgressBar.
  m_VBox.append(m_ProgressBar);

  m_ProgressBar.set_text("Fraction done");
  m_ProgressBar.set_show_text();

  // Add the TextView, inside a ScrolledWindow.
  m_ScrolledWindow.set_child(m_TextView);

  // Only show the scrollbars when they are necessary.
  m_ScrolledWindow.set_policy(Gtk::PolicyType::AUTOMATIC, Gtk::PolicyType::AUTOMATIC);
  m_ScrolledWindow.set_expand();

  m_VBox.append(m_ScrolledWindow);

  m_TextView.set_editable(false);

  // Add the buttons to the ButtonBox.
  m_VBox.append(m_ButtonBox);

  m_ButtonBox.append(m_ButtonStart);
  m_ButtonBox.append(m_ButtonStop);
  m_ButtonBox.append(m_ButtonQuit);
  m_ButtonBox.set_margin(5);
  m_ButtonBox.set_spacing(5);
  m_ButtonStart.set_hexpand(true);
  m_ButtonStart.set_halign(Gtk::Align::END);

  // Connect the signal handlers to the buttons.
  m_ButtonStart.signal_clicked().connect(sigc::mem_fun(*this, &amp;ExampleWindow::on_start_button_clicked));
  m_ButtonStop.signal_clicked().connect(sigc::mem_fun(*this, &amp;ExampleWindow::on_stop_button_clicked));
  m_ButtonQuit.signal_clicked().connect(sigc::mem_fun(*this, &amp;ExampleWindow::on_quit_button_clicked));

  // Connect the handler to the dispatcher.
  m_Dispatcher.connect(sigc::mem_fun(*this, &amp;ExampleWindow::on_notification_from_worker_thread));

  // Create a text buffer mark for use in update_widgets().
  auto buffer = m_TextView.get_buffer();
  buffer-&gt;create_mark("last_line", buffer-&gt;end(), /* left_gravity= */ true);

  update_start_stop_buttons();
}

void ExampleWindow::on_start_button_clicked()
{
  if (m_WorkerThread)
  {
    std::cout &lt;&lt; "Can't start a worker thread while another one is running." &lt;&lt; std::endl;
  }
  else
  {
    // Start a new worker thread.
    m_WorkerThread = new std::thread(
      [this]
      {
        m_Worker.do_work(this);
      });
  }
  update_start_stop_buttons();
}

void ExampleWindow::on_stop_button_clicked()
{
  if (!m_WorkerThread)
  {
    std::cout &lt;&lt; "Can't stop a worker thread. None is running." &lt;&lt; std::endl;
  }
  else
  {
   // Order the worker thread to stop.
    m_Worker.stop_work();
    m_ButtonStop.set_sensitive(false);
  }
}

void ExampleWindow::update_start_stop_buttons()
{
  const bool thread_is_running = m_WorkerThread != nullptr;

  m_ButtonStart.set_sensitive(!thread_is_running);
  m_ButtonStop.set_sensitive(thread_is_running);
}

void ExampleWindow::update_widgets()
{
  double fraction_done;
  Glib::ustring message_from_worker_thread;
  m_Worker.get_data(&amp;fraction_done, &amp;message_from_worker_thread);

  m_ProgressBar.set_fraction(fraction_done);

  if (message_from_worker_thread != m_TextView.get_buffer()-&gt;get_text())
  {
    auto buffer = m_TextView.get_buffer();
    buffer-&gt;set_text(message_from_worker_thread);

    // Scroll the last inserted line into view. That's somewhat complicated.
    auto iter = buffer-&gt;end();
    iter.set_line_offset(0); // Beginning of last line
    auto mark = buffer-&gt;get_mark("last_line");
    buffer-&gt;move_mark(mark, iter);
    m_TextView.scroll_to(mark);
    // TextView::scroll_to(iter) is not perfect.
    // We do need a TextMark to always get the last line into view.
  }
}

void ExampleWindow::on_quit_button_clicked()
{
  if (m_WorkerThread)
  {
    // Order the worker thread to stop and wait for it to stop.
    m_Worker.stop_work();
    if (m_WorkerThread-&gt;joinable())
      m_WorkerThread-&gt;join();
  }
  hide();
}

// notify() is called from ExampleWorker::do_work(). It is executed in the worker
// thread. It triggers a call to on_notification_from_worker_thread(), which is
// executed in the GUI thread.
void ExampleWindow::notify()
{
  m_Dispatcher.emit();
}

void ExampleWindow::on_notification_from_worker_thread()
{
  if (m_WorkerThread &amp;&amp; m_Worker.has_stopped())
  {
    // Work is done.
    if (m_WorkerThread-&gt;joinable())
      m_WorkerThread-&gt;join();
    delete m_WorkerThread;
    m_WorkerThread = nullptr;
    update_start_stop_buttons();
  }
  update_widgets();
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">exampleworker.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "exampleworker.h"
#include "examplewindow.h"
#include &lt;sstream&gt;
#include &lt;chrono&gt;

ExampleWorker::ExampleWorker() :
  m_Mutex(),
  m_shall_stop(false),
  m_has_stopped(false),
  m_fraction_done(0.0),
  m_message()
{
}

// Accesses to these data are synchronized by a mutex.
// Some microseconds can be saved by getting all data at once, instead of having
// separate get_fraction_done() and get_message() methods.
void ExampleWorker::get_data(double* fraction_done, Glib::ustring* message) const
{
  std::lock_guard&lt;std::mutex&gt; lock(m_Mutex);

  if (fraction_done)
    *fraction_done = m_fraction_done;

  if (message)
    *message = m_message;
}

void ExampleWorker::stop_work()
{
  std::lock_guard&lt;std::mutex&gt; lock(m_Mutex);
  m_shall_stop = true;
}

bool ExampleWorker::has_stopped() const
{
  std::lock_guard&lt;std::mutex&gt; lock(m_Mutex);
  return m_has_stopped;
}

void ExampleWorker::do_work(ExampleWindow* caller)
{
  {
    std::lock_guard&lt;std::mutex&gt; lock(m_Mutex);
    m_has_stopped = false;
    m_fraction_done = 0.0;
    m_message = "";
  } // The mutex is unlocked here by lock's destructor.

  // Simulate a long calculation.
  for (int i = 0; ; ++i) // do until break
  {
    std::this_thread::sleep_for(std::chrono::milliseconds(250));

    {
      std::lock_guard&lt;std::mutex&gt; lock(m_Mutex);

      m_fraction_done += 0.01;

      if (i % 4 == 3)
      {
        std::ostringstream ostr;
        ostr &lt;&lt; (m_fraction_done * 100.0) &lt;&lt; "% done\n";
        m_message += ostr.str();
      }

      if (m_fraction_done &gt;= 1.0)
      {
        m_message += "Finished";
        break;
      }
      if (m_shall_stop)
      {
        m_message += "Stopped";
        break;
      }
    }

    caller-&gt;notify();
  }

  {
    std::lock_guard&lt;std::mutex&gt; lock(m_Mutex);
    m_shall_stop = false;
    m_has_stopped = true;
  }

  caller-&gt;notify();
}
</pre></div>
</div>
</div>
<div class="division chapter">
<a name="chapter-recommended-techniques"><!--chapter-recommended-techniques--></a><div class="header"><h2 class="chapter title"><span class="title"><span class="label">28. </span>Recommended Techniques</span></h2></div>
<p class="para block block-first">This section is simply a gathering of wisdom, general style guidelines
and hints for creating <span class="application">gtkmm</span> applications.
</p>
<p class="para block">Use GNU <span class="application">autoconf</span> and
    <span class="application">automake</span>! They are your friends :)
    <span class="application">Automake</span> examines C files, determines how they
    depend on each other, and generates a <span class="filename" dir="ltr">Makefile</span> so the
    files can be compiled in the correct order.
    <span class="application">Autoconf</span> permits automatic configuration of
    software installation, handling a large number of system quirks to increase
    portability.
</p>
<p class="para block">Subclass Widgets to better organize your code. You should probably
    subclass your main <span class="classname" dir="ltr">Window</span> at least. Then you can
    make your child Widgets and signal handlers members of that class.
</p>
<p class="para block">Create your own signals instead of passing pointers around. Objects can
    communicate with each other via signals and signal handlers. This is much
    simpler than objects holding pointers to each other and calling each
    other's methods. <span class="application">gtkmm</span>'s classes uses special versions of
    <span class="classname" dir="ltr">sigc::signal</span>, but you should use normal
    <span class="classname" dir="ltr">sigc::signal</span>s, as described in the
    <span class="application">libsigc++</span> documentation.</p>
<div class="autotoc"><ul>
<li>
<span class="label">28.1. </span><a class="xref" href="#sec-application-lifetime" title="Application Lifetime">Application Lifetime</a>
</li>
<li>
<span class="label">28.2. </span><a class="xref" href="#sec-using-a-gtkmm-widget" title="Using a gtkmm widget">Using a <span class="application">gtkmm</span> widget</a>
</li>
</ul></div>
<div class="division sect1">
<a name="sec-application-lifetime"><!--sec-application-lifetime--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">28.1. </span>Application Lifetime</span></h3></div>
<p class="para block block-first">Most applications will have only one <span class="classname" dir="ltr">Window</span>, or
    only one main window. These applications can use the
    <span class="methodname" dir="ltr">Gtk::Application::run(Gtk::Window&amp; window)</span> or
    <span class="methodname" dir="ltr">Gtk::Application::run(Gtk::Window&amp; window, int argc, char** argv)</span>
    overloads. They show the window and return when the window has been hidden.
    This might happen when the user closes the window, or when your code decides to
    <span class="methodname" dir="ltr">hide()</span> the window. You can prevent the user from
    closing the window (for instance, if there are unsaved changes) by
    overriding <span class="methodname" dir="ltr">Gtk::Window::on_delete_event()</span>.</p>
<p class="para block">Most of our examples use this technique.</p>
</div>
<div class="division sect1">
<a name="sec-using-a-gtkmm-widget"><!--sec-using-a-gtkmm-widget--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">28.2. </span>Using a <span class="application">gtkmm</span> widget</span></h3></div>
<p class="para block block-first">
    Our examples all tend to have the same structure. They follow these steps
    for using a <span class="classname" dir="ltr">Widget</span>:
</p>
<p class="para block">

<div class="block list orderedlist"><ol class="orderedlist">
<li class="li-first">
<span class="para">
Declare a variable of the type of <span class="classname" dir="ltr">Widget</span> you wish to
use, generally as member variable of a derived container class. You could also
declare a pointer to the widget type, and then create it with
<span class="literal" dir="ltr">new</span> in your code. Even when using the widget via a pointer,
it's still probably best to make that pointer a member variable of a container
class so that you can access it later.
</span>
</li>
<li>
<span class="para">
 Set the attributes of the widget. If the widget has no default constructor, then you will need to initialize the widget in the initalizer list of your container class's constructor.
</span>
</li>
<li>
<span class="para">
Connect any signals you wish to use to the appropriate handlers.
</span>
</li>
<li>
<span class="para">
Pack the widget into a container using the appropriate call,
e.g. <span class="methodname" dir="ltr">Gtk::Box::append()</span>.
</span>
</li>
</ol></div>

</p>
<p class="para block">
If you don't want all widgets to be shown, call <span class="methodname" dir="ltr">Gtk::Widget::hide()</span>
on the widgets that you don't want to show. If a container widget is hidden, all
of its child widgets are also hidden, even if <span class="methodname" dir="ltr">hide()</span> is
not called on the child widgets.
</p>
</div>
</div>
<div class="division chapter">
<a name="chapter-building-applications"><!--chapter-building-applications--></a><div class="header"><h2 class="chapter title"><span class="title"><span class="label">29. </span>Building applications</span></h2></div>
<p class="para block block-first">
This chapter is similar to the "Building applications" chapter in the
<a class="ulink" href="https://developer.gnome.org/gtk4/unstable/" title="https://developer.gnome.org/gtk4/unstable/">GTK4 Reference Manual</a>.
The same application is built, but <span class="application">gtkmm</span> is used instead of <span class="application">GTK</span>.
</p>
<p class="para block">
An application consists of a number of files:
<div class="block list variablelist"><dl class="variablelist">
<dt class="term dt-first">The binary file</dt>
<dd><p class="para block block-first">This gets installed in <span class="filename" dir="ltr">/usr/bin</span>.</p></dd>
<dt class="term">A desktop file</dt>
<dd><p class="para block block-first">The desktop file provides important information about the application
      to the desktop shell, such as its name, icon, D-Bus name, commandline to launch it,
      etc. It is installed in <span class="filename" dir="ltr">/usr/share/applications</span>.</p></dd>
<dt class="term">An icon</dt>
<dd><p class="para block block-first">The icon gets installed in <span class="filename" dir="ltr">/usr/share/icons/hicolor/48x48/apps</span>,
      where it will be found regardless of the current theme.</p></dd>
<dt class="term">A settings schema</dt>
<dd><p class="para block block-first">If the application uses <span class="classname" dir="ltr">Gio::Settings</span>,
      it will install its schema in <span class="filename" dir="ltr">/usr/share/glib-2.0/schemas</span>,
      so that tools like dconf-editor can find it.</p></dd>
<dt class="term">Other resources</dt>
<dd><p class="para block block-first">Other files, such as <span class="classname" dir="ltr">Gtk::Builder</span> ui files,
      are best loaded from resources stored in the application binary itself. This
      eliminates the need for most of the files that would traditionally be installed
      in an application-specific location in <span class="filename" dir="ltr">/usr/share</span>.</p></dd>
</dl></div>
</p>
<p class="para block">
<span class="application">gtkmm</span> includes application support that is built on top of <span class="classname" dir="ltr">Gio::Application</span>.
In this chapter we'll build a simple application by starting from scratch, adding more
and more pieces over time. Along the way, we'll learn about <span class="classname" dir="ltr">Gtk::Application</span>,
<span class="classname" dir="ltr">Gtk::Builder</span>, resources, menus, settings,
<span class="classname" dir="ltr">Gtk::HeaderBar</span>, <span class="classname" dir="ltr">Gtk::Stack</span>,
<span class="classname" dir="ltr">Gtk::SearchBar</span>, <span class="classname" dir="ltr">Gtk::ListBox</span>, and more.
</p>
<p class="para block">
The full, buildable sources for these examples can be found in the
<span class="filename" dir="ltr">examples/book/buildapp</span> directory of the
<span class="application">gtkmm-documentation</span> source distribution, or online in the
<a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/buildapp" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/buildapp"><span class="application">gtkmm-documentation</span>
git repository</a>. You can build each example separately by using <span class="command" dir="ltr">meson</span>
and <span class="command" dir="ltr">ninja</span> with the <span class="filename" dir="ltr">meson.build</span> file or by using
<span class="command" dir="ltr">make</span> with the <span class="filename" dir="ltr">Makefile.example</span> file. For more
information, see the <span class="filename" dir="ltr">README</span> included in the <span class="filename" dir="ltr">buildapp</span>
directory.
</p>
<div class="autotoc"><ul>
<li>
<span class="label">29.1. </span><a class="xref" href="#sec-buildapp-trivial-app" title="A trivial application">A trivial application</a>
</li>
<li>
<span class="label">29.2. </span><a class="xref" href="#sec-buildapp-populating-window" title="Populating the window">Populating the window</a>
</li>
<li>
<span class="label">29.3. </span><a class="xref" href="#sec-buildapp-opening-files" title="Opening files">Opening files</a>
</li>
<li>
<span class="label">29.4. </span><a class="xref" href="#sec-buildapp-menu" title="A menu">A menu</a>
</li>
<li>
<span class="label">29.5. </span><a class="xref" href="#sec-buildapp-pref-dialog" title="A preference dialog">A preference dialog</a>
</li>
<li>
<span class="label">29.6. </span><a class="xref" href="#sec-buildapp-search-bar" title="Adding a search bar">Adding a search bar</a>
</li>
<li>
<span class="label">29.7. </span><a class="xref" href="#sec-buildapp-side-bar" title="Adding a side bar">Adding a side bar</a>
</li>
<li>
<span class="label">29.8. </span><a class="xref" href="#sec-buildapp-properties" title="Properties">Properties</a>
</li>
<li>
<span class="label">29.9. </span><a class="xref" href="#sec-buildapp-header-bar" title="Header bar">Header bar</a>
</li>
</ul></div>
<div class="division sect1">
<a name="sec-buildapp-trivial-app"><!--sec-buildapp-trivial-app--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">29.1. </span>A trivial application</span></h3></div>
<p class="para block block-first">
When using <span class="classname" dir="ltr">Gtk::Application</span>, the <span class="function">main()</span> function
can be very simple. We just call <span class="methodname" dir="ltr">Gtk::Application::run()</span> on an
instance of our application class.
</p>
<p class="para block">
All the application logic is in the application class, which is a subclass of
<span class="classname" dir="ltr">Gtk::Application</span>. Our example does not yet have any interesting
functionality. All it does is open a window when it is activated without arguments,
and open the files it is given, if it is started with arguments. (Or rather, our
application class tries to open the files, but our subclassed application window
does not yet do what it's told to do.)
</p>
<p class="para block">
To handle these two cases, we override <span class="methodname" dir="ltr">signal_activate()</span>'s
default handler, which gets called when the application is launched without commandline
arguments, and <span class="methodname" dir="ltr">signal_open()</span>'s default handler, which gets
called when the application is launched with commandline arguments.
</p>
<p class="para block"><a class="ulink" href="http://developer.gnome.org/glibmm/unstable/classGio_1_1Application.html" title="http://developer.gnome.org/glibmm/unstable/classGio_1_1Application.html">Gio::Application Reference</a></p>
<p class="para block"><a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Application.html" title="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Application.html">Gtk::Application Reference</a></p>
<p class="para block">
Another important class that is part of the application support in <span class="application">gtkmm</span> is
<span class="classname" dir="ltr">Gtk::ApplicationWindow</span>. It is typically subclassed as well.
Our subclass does not do anything yet, so we will just get an empty window.
</p>
<p class="para block">
As part of the initial setup of our application, we also create an icon and a desktop file.
Note that @bindir@ in the desktop file needs to be replaced with the actual path
to the binary before this desktop file can be used.
</p>
<p class="para block">
Here is what we've achieved so far:
</p>
<div class=" block figure block-indent">
<a name="figure-buildapp-trivial-app"><!--figure-buildapp-trivial-app--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 29-1</span> </span>A trivial application</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/buildapp_trivial_app.png.en"></div>
  </div>
</div>
</div>
<p class="para block">
This does not look very impressive yet, but our application is already presenting itself
on the session bus, it has single-instance semantics, and it accepts files as commandline arguments.
</p>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/buildapp/step1" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/buildapp/step1">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">exampleapplication.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEAPPLICATION_H
#define GTKMM_EXAMPLEAPPLICATION_H

#include &lt;gtkmm.h&gt;

class ExampleAppWindow;

class ExampleApplication: public Gtk::Application
{
protected:
  ExampleApplication();

public:
  static Glib::RefPtr&lt;ExampleApplication&gt; create();

protected:
  // Override default signal handlers:
  void on_activate() override;
  void on_open(const Gio::Application::type_vec_files&amp; files,
    const Glib::ustring&amp; hint) override;

private:
  ExampleAppWindow* create_appwindow();
  void on_hide_window(Gtk::Window* window);
};

#endif /* GTKMM_EXAMPLEAPPLICATION_H */
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">exampleappwindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEAPPWINDOW_H_
#define GTKMM_EXAMPLEAPPWINDOW_H_

#include &lt;gtkmm.h&gt;

class ExampleAppWindow : public Gtk::ApplicationWindow
{
public:
  ExampleAppWindow();

  void open_file_view(const Glib::RefPtr&lt;Gio::File&gt;&amp; file);
};

#endif /* GTKMM_EXAMPLEAPPWINDOW_H */
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "exampleapplication.h"

int main(int argc, char* argv[])
{
  auto application = ExampleApplication::create();

  // Start the application, showing the initial window,
  // and opening extra views for any files that it is asked to open,
  // for instance as a command-line parameter.
  // run() will return when the last window has been closed.
  return application-&gt;run(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">exampleappwindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "exampleappwindow.h"

ExampleAppWindow::ExampleAppWindow()
: Gtk::ApplicationWindow()
{
}

void ExampleAppWindow::open_file_view(const Glib::RefPtr&lt;Gio::File&gt;&amp; /* file */)
{
}

</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">exampleapplication.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "exampleapplication.h"
#include "exampleappwindow.h"

ExampleApplication::ExampleApplication()
: Gtk::Application("org.gtkmm.examples.application", Gio::Application::Flags::HANDLES_OPEN)
{
}

Glib::RefPtr&lt;ExampleApplication&gt; ExampleApplication::create()
{
  return Glib::make_refptr_for_instance&lt;ExampleApplication&gt;(new ExampleApplication());
}

ExampleAppWindow* ExampleApplication::create_appwindow()
{
  auto appwindow = new ExampleAppWindow();

  // Make sure that the application runs for as long this window is still open.
  add_window(*appwindow);

  // A window can be added to an application with Gtk::Application::add_window()
  // or Gtk::Window::set_application(). When all added windows have been hidden
  // or removed, the application stops running (Gtk::Application::run() returns()),
  // unless Gio::Application::hold() has been called.

  // Delete the window when it is hidden.
  appwindow-&gt;signal_hide().connect(sigc::bind(sigc::mem_fun(*this,
    &amp;ExampleApplication::on_hide_window), appwindow));

  return appwindow;
}

void ExampleApplication::on_activate()
{
  // The application has been started, so let's show a window.
  auto appwindow = create_appwindow();
  appwindow-&gt;present();
}

void ExampleApplication::on_open(const Gio::Application::type_vec_files&amp; files,
  const Glib::ustring&amp; /* hint */)
{
  // The application has been asked to open some files,
  // so let's open a new view for each one.
  ExampleAppWindow* appwindow = nullptr;
  auto windows = get_windows();
  if (windows.size() &gt; 0)
    appwindow = dynamic_cast&lt;ExampleAppWindow*&gt;(windows[0]);

  if (!appwindow)
    appwindow = create_appwindow();

  for (const auto&amp; file : files)
    appwindow-&gt;open_file_view(file);

  appwindow-&gt;present();
}

void ExampleApplication::on_hide_window(Gtk::Window* window)
{
  delete window;
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">exampleapp.desktop.in</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">[Desktop Entry]
Type=Application
Name=Gtkmm example
GenericName=Example
Comment=From the "Programming with gtkmm 4" tutorial
Icon=exampleapp
StartupNotify=true
Exec=@bindir@/exampleapp %U
Categories=GNOME;GTK;Utility
</pre></div>
</div>
<div class="division sect1">
<a name="sec-buildapp-populating-window"><!--sec-buildapp-populating-window--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">29.2. </span>Populating the window</span></h3></div>
<p class="para block block-first">
In this step, we use a <span class="classname" dir="ltr">Gtk::Builder</span> instance to associate a
<span class="classname" dir="ltr">Gtk::Builder</span> ui file with our application window class.
</p>
<p class="para block">
Our simple ui file gives the window a title, and puts a <span class="classname" dir="ltr">Gtk::Stack</span>
widget as the main content.
</p>
<p class="para block">
To make use of this file in our application, we revisit our
<span class="classname" dir="ltr">Gtk::ApplicationWindow</span> subclass, and call
<span class="methodname" dir="ltr">Gtk::Builder::create_from_resource()</span> and
<span class="methodname" dir="ltr">Gtk::Builder::get_widget_derived()</span> from the
<span class="methodname" dir="ltr">ExampleAppWindow::create()</span> method to get an instance of
our subclassed <span class="classname" dir="ltr">Gtk::ApplicationWindow</span>. See the 
<a class="link" href="#sec-builder-using-derived-widgets" title="Using derived widgets">Using derived widgets</a> section
for more information about <span class="methodname" dir="ltr">get_widget_derived()</span>.
</p>
<p class="para block">
You may have noticed that we use the <span class="methodname" dir="ltr">_from_resource()</span> variant
of the method that reads the ui file. Now we need to use <span class="application">GLib</span>'s
resource functionality to include the ui file in the binary. This is commonly done by
listing all resources in a .gresource.xml file.
This file has to be converted into a C source file that will be compiled and linked
into the application together with the other source files. To do so, we use the
<span class="application">glib-compile-resources</span> utility:
<div dir="ltr" class=" block screen block-indent"><pre class="screen">$ glib-compile-resources --target=resources.c --generate-source exampleapp.gresource.xml</pre></div>
The <a class="link" href="#sec-gio-resource" title="Gio::Resource and glib-compile-resources">Gio::Resource and glib-compile-resources</a>
section contains more information about resource files. If you build with Meson,
use the <span class="function">compile_resources()</span> function in Meson's 
<a class="ulink" href="https://mesonbuild.com/Gnome-module.html" title="https://mesonbuild.com/Gnome-module.html">GNOME module</a>.
</p>
<p class="para block">
Our application now looks like this:
</p>
<div class=" block figure block-indent">
<a name="figure-buildapp-populating-window"><!--figure-buildapp-populating-window--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 29-2</span> </span>Populating the window</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/buildapp_populating_window.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/buildapp/step2" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/buildapp/step2">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">exampleapplication.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "../step1/exampleapplication.h"
// Equal to the corresponding file in step1
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">exampleappwindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEAPPWINDOW_H_
#define GTKMM_EXAMPLEAPPWINDOW_H_

#include &lt;gtkmm.h&gt;

class ExampleAppWindow : public Gtk::ApplicationWindow
{
public:
  ExampleAppWindow(BaseObjectType* cobject,
    const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; refBuilder);

  static ExampleAppWindow* create();

  void open_file_view(const Glib::RefPtr&lt;Gio::File&gt;&amp; file);

protected:
  Glib::RefPtr&lt;Gtk::Builder&gt; m_refBuilder;
};

#endif /* GTKMM_EXAMPLEAPPWINDOW_H */
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "../step1/main.cc"
// Equal to the corresponding file in step1
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">exampleappwindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "exampleappwindow.h"
#include &lt;stdexcept&gt;

ExampleAppWindow::ExampleAppWindow(BaseObjectType* cobject,
  const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; refBuilder)
: Gtk::ApplicationWindow(cobject),
  m_refBuilder(refBuilder)
{
}

//static
ExampleAppWindow* ExampleAppWindow::create()
{
  // Load the Builder file and instantiate its widgets.
  auto refBuilder = Gtk::Builder::create_from_resource("/org/gtkmm/exampleapp/window.ui");

  auto window = Gtk::Builder::get_widget_derived&lt;ExampleAppWindow&gt;(refBuilder, "app_window");
  if (!window)
    throw std::runtime_error("No \"app_window\" object in window.ui");

  return window;
}

void ExampleAppWindow::open_file_view(const Glib::RefPtr&lt;Gio::File&gt;&amp; /* file */)
{
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">exampleapplication.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "exampleapplication.h"
#include "exampleappwindow.h"
#include &lt;iostream&gt;
#include &lt;exception&gt;

ExampleApplication::ExampleApplication()
: Gtk::Application("org.gtkmm.examples.application", Gio::Application::Flags::HANDLES_OPEN)
{
}

Glib::RefPtr&lt;ExampleApplication&gt; ExampleApplication::create()
{
  return Glib::make_refptr_for_instance&lt;ExampleApplication&gt;(new ExampleApplication());
}

ExampleAppWindow* ExampleApplication::create_appwindow()
{
  auto appwindow = ExampleAppWindow::create();

  // Make sure that the application runs for as long this window is still open.
  add_window(*appwindow);

  // A window can be added to an application with Gtk::Application::add_window()
  // or Gtk::Window::set_application(). When all added windows have been hidden
  // or removed, the application stops running (Gtk::Application::run() returns()),
  // unless Gio::Application::hold() has been called.

  // Delete the window when it is hidden.
  appwindow-&gt;signal_hide().connect(sigc::bind(sigc::mem_fun(*this,
    &amp;ExampleApplication::on_hide_window), appwindow));

  return appwindow;
}

void ExampleApplication::on_activate()
{
  try
  {
    // The application has been started, so let's show a window.
    auto appwindow = create_appwindow();
    appwindow-&gt;present();
  }
  // If create_appwindow() throws an exception (perhaps from Gtk::Builder),
  // no window has been created, no window has been added to the application,
  // and therefore the application will stop running.
  catch (const Glib::Error&amp; ex)
  {
    std::cerr &lt;&lt; "ExampleApplication::on_activate(): " &lt;&lt; ex.what() &lt;&lt; std::endl;
  }
  catch (const std::exception&amp; ex)
  {
    std::cerr &lt;&lt; "ExampleApplication::on_activate(): " &lt;&lt; ex.what() &lt;&lt; std::endl;
  }
}

void ExampleApplication::on_open(const Gio::Application::type_vec_files&amp; files,
  const Glib::ustring&amp; /* hint */)
{
  // The application has been asked to open some files,
  // so let's open a new view for each one.
  ExampleAppWindow* appwindow = nullptr;
  auto windows = get_windows();
  if (windows.size() &gt; 0)
    appwindow = dynamic_cast&lt;ExampleAppWindow*&gt;(windows[0]);

  try
  {
    if (!appwindow)
      appwindow = create_appwindow();

    for (const auto&amp; file : files)
      appwindow-&gt;open_file_view(file);

    appwindow-&gt;present();
  }
  catch (const Glib::Error&amp; ex)
  {
    std::cerr &lt;&lt; "ExampleApplication::on_open(): " &lt;&lt; ex.what() &lt;&lt; std::endl;
  }
  catch (const std::exception&amp; ex)
  {
    std::cerr &lt;&lt; "ExampleApplication::on_open(): " &lt;&lt; ex.what() &lt;&lt; std::endl;
  }
}

void ExampleApplication::on_hide_window(Gtk::Window* window)
{
  delete window;
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">exampleapp.gresource.xml</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;gresources&gt;
  &lt;gresource prefix="/org/gtkmm/exampleapp"&gt;
    &lt;file preprocess="xml-stripblanks"&gt;window.ui&lt;/file&gt;
  &lt;/gresource&gt;
&lt;/gresources&gt;
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">window.ui</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;interface&gt;
  &lt;object class="GtkApplicationWindow" id="app_window"&gt;
    &lt;property name="title" translatable="yes"&gt;Example Application&lt;/property&gt;
    &lt;property name="default-width"&gt;600&lt;/property&gt;
    &lt;property name="default-height"&gt;400&lt;/property&gt;
    &lt;property name="hide-on-close"&gt;True&lt;/property&gt;
    &lt;child&gt;
      &lt;object class="GtkBox" id="content_box"&gt;
        &lt;property name="orientation"&gt;vertical&lt;/property&gt;
        &lt;child&gt;
          &lt;object class="GtkStack" id="stack"/&gt;
        &lt;/child&gt;
      &lt;/object&gt;
    &lt;/child&gt;
  &lt;/object&gt;
&lt;/interface&gt;
</pre></div>
</div>
<div class="division sect1">
<a name="sec-buildapp-opening-files"><!--sec-buildapp-opening-files--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">29.3. </span>Opening files</span></h3></div>
<p class="para block block-first">
In this step, we make our application show the contents of all the files that it is
given on the commandline.
</p>
<p class="para block">
To this end, we add a data member to our application window and keep a pointer to the
<span class="classname" dir="ltr">Gtk::Stack</span> there. We get the pointer with a call to
<span class="methodname" dir="ltr">Gtk::Builder::get_widget()</span> in the application window's constructor.
</p>
<p class="para block">
Now we revisit the <span class="methodname" dir="ltr">ExampleAppWindow::open_file_view()</span> method
that is called for each commandline argument, and construct a <span class="classname" dir="ltr">Gtk::TextView</span>
that we then add as a page to the stack.
</p>
<p class="para block">
Lastly, we add a <span class="classname" dir="ltr">Gtk::StackSwitcher</span> to the titlebar area
in the ui file, and we tell it to display information about our stack.
</p>
<p class="para block">
The stack switcher gets all its information it needs to display tabs from
the stack that it belongs to. Here, we are passing the label to show for
each file as the last argument to the <span class="methodname" dir="ltr">Gtk::Stack::add()</span>
method.
</p>
<p class="para block">
Our application is beginning to take shape:
</p>
<div class=" block figure block-indent">
<a name="figure-buildapp-opening-files"><!--figure-buildapp-opening-files--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 29-3</span> </span>Opening files</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/buildapp_opening_files.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/buildapp/step3" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/buildapp/step3">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">exampleapplication.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "../step1/exampleapplication.h"
// Equal to the corresponding file in step1
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">exampleappwindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEAPPWINDOW_H_
#define GTKMM_EXAMPLEAPPWINDOW_H_

#include &lt;gtkmm.h&gt;

class ExampleAppWindow : public Gtk::ApplicationWindow
{
public:
  ExampleAppWindow(BaseObjectType* cobject,
    const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; refBuilder);

  static ExampleAppWindow* create();

  void open_file_view(const Glib::RefPtr&lt;Gio::File&gt;&amp; file);

protected:
  Glib::RefPtr&lt;Gtk::Builder&gt; m_refBuilder;
  Gtk::Stack* m_stack;
};

#endif /* GTKMM_EXAMPLEAPPWINDOW_H */
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "../step1/main.cc"
// Equal to the corresponding file in step1
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">exampleappwindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "exampleappwindow.h"
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;

ExampleAppWindow::ExampleAppWindow(BaseObjectType* cobject,
  const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; refBuilder)
: Gtk::ApplicationWindow(cobject),
  m_refBuilder(refBuilder),
  m_stack(nullptr)
{
  m_stack = m_refBuilder-&gt;get_widget&lt;Gtk::Stack&gt;("stack");
  if (!m_stack)
    throw std::runtime_error("No \"stack\" object in window.ui");
}

//static
ExampleAppWindow* ExampleAppWindow::create()
{
  // Load the Builder file and instantiate its widgets.
  auto refBuilder = Gtk::Builder::create_from_resource("/org/gtkmm/exampleapp/window.ui");

  auto window = Gtk::Builder::get_widget_derived&lt;ExampleAppWindow&gt;(refBuilder, "app_window");
  if (!window)
    throw std::runtime_error("No \"app_window\" object in window.ui");

  return window;
}

void ExampleAppWindow::open_file_view(const Glib::RefPtr&lt;Gio::File&gt;&amp; file)
{
  const Glib::ustring basename = file-&gt;get_basename();

  auto scrolled = Gtk::make_managed&lt;Gtk::ScrolledWindow&gt;();
  scrolled-&gt;set_expand(true);
  auto view = Gtk::make_managed&lt;Gtk::TextView&gt;();
  view-&gt;set_editable(false);
  view-&gt;set_cursor_visible(false);
  scrolled-&gt;set_child(*view);
  m_stack-&gt;add(*scrolled, basename, basename);

  try
  {
    char* contents = nullptr;
    gsize length = 0;
    
    file-&gt;load_contents(contents, length);
    view-&gt;get_buffer()-&gt;set_text(contents, contents+length);
    g_free(contents);
  }
  catch (const Glib::Error&amp; ex)
  {
    std::cout &lt;&lt; "ExampleAppWindow::open_file_view(\"" &lt;&lt; file-&gt;get_parse_name()
      &lt;&lt; "\"):\n  " &lt;&lt; ex.what() &lt;&lt; std::endl;
  }
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">exampleapplication.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "../step2/exampleapplication.cc"
// Equal to the corresponding file in step2
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">window.ui</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;interface&gt;
  &lt;object class="GtkApplicationWindow" id="app_window"&gt;
    &lt;property name="title" translatable="yes"&gt;Example Application&lt;/property&gt;
    &lt;property name="default-width"&gt;600&lt;/property&gt;
    &lt;property name="default-height"&gt;400&lt;/property&gt;
    &lt;property name="hide-on-close"&gt;True&lt;/property&gt;
    &lt;child type="titlebar"&gt;
      &lt;object class="GtkHeaderBar" id="header"&gt;
        &lt;child type="title"&gt;
          &lt;object class="GtkStackSwitcher" id="tabs"&gt;
            &lt;property name="stack"&gt;stack&lt;/property&gt;
          &lt;/object&gt;
        &lt;/child&gt;
      &lt;/object&gt;
    &lt;/child&gt;
    &lt;child&gt;
      &lt;object class="GtkBox" id="content_box"&gt;
        &lt;property name="orientation"&gt;vertical&lt;/property&gt;
        &lt;child&gt;
          &lt;object class="GtkStack" id="stack"/&gt;
        &lt;/child&gt;
      &lt;/object&gt;
    &lt;/child&gt;
  &lt;/object&gt;
&lt;/interface&gt;
</pre></div>
</div>
<div class="division sect1">
<a name="sec-buildapp-menu"><!--sec-buildapp-menu--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">29.4. </span>A menu</span></h3></div>
<p class="para block block-first">
The menu is shown at the right side of the headerbar. It is meant to collect
infrequently used actions that affect the whole application.
</p>
<p class="para block">
Just like the application window, we specify our menu in a ui file, and add it
as a resource to our binary.
</p>
<p class="para block">
To make the menu appear, we have to load the ui file and associate the
resulting menu model with the menu button that we've added to the headerbar.
Since menus work by activating <span class="classname" dir="ltr">Gio::Action</span>s, we also
have to add a suitable set of actions to our application.
</p>
<p class="para block">
Adding the actions is best done in the <span class="methodname" dir="ltr">on_startup()</span> default
signal handler, which is guaranteed to be called once for each primary application instance.
</p>
<p class="para block">
Our preferences menu item does not do anything yet, but the Quit menu item is fully
functional. It can also be activated by the usual Ctrl-Q shortcut. The shortcut
is added with <span class="methodname" dir="ltr">Gtk::Application::set_accel_for_action()</span>.
</p>
<p class="para block">
The menu looks like this:
</p>
<div class=" block figure block-indent">
<a name="figure-buildapp-menu"><!--figure-buildapp-menu--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 29-4</span> </span>A menu</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/buildapp_menu.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/buildapp/step4" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/buildapp/step4">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">exampleapplication.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEAPPLICATION_H
#define GTKMM_EXAMPLEAPPLICATION_H

#include &lt;gtkmm.h&gt;

class ExampleAppWindow;

class ExampleApplication: public Gtk::Application
{
protected:
  ExampleApplication();

public:
  static Glib::RefPtr&lt;ExampleApplication&gt; create();

protected:
  // Override default signal handlers:
  void on_startup() override;
  void on_activate() override;
  void on_open(const Gio::Application::type_vec_files&amp; files,
    const Glib::ustring&amp; hint) override;

private:
  ExampleAppWindow* create_appwindow();
  void on_hide_window(Gtk::Window* window);
  void on_action_preferences();
  void on_action_quit();
};

#endif /* GTKMM_EXAMPLEAPPLICATION_H */
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">exampleappwindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEAPPWINDOW_H_
#define GTKMM_EXAMPLEAPPWINDOW_H_

#include &lt;gtkmm.h&gt;

class ExampleAppWindow : public Gtk::ApplicationWindow
{
public:
  ExampleAppWindow(BaseObjectType* cobject,
    const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; refBuilder);

  static ExampleAppWindow* create();

  void open_file_view(const Glib::RefPtr&lt;Gio::File&gt;&amp; file);

protected:
  Glib::RefPtr&lt;Gtk::Builder&gt; m_refBuilder;
  Gtk::Stack* m_stack;
  Gtk::MenuButton* m_gears;
};

#endif /* GTKMM_EXAMPLEAPPWINDOW_H */
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "../step1/main.cc"
// Equal to the corresponding file in step1
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">exampleappwindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "exampleappwindow.h"
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;

ExampleAppWindow::ExampleAppWindow(BaseObjectType* cobject,
  const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; refBuilder)
: Gtk::ApplicationWindow(cobject),
  m_refBuilder(refBuilder),
  m_stack(nullptr),
  m_gears(nullptr)
{
  // Get widgets from the Gtk::Builder file.
  m_stack = m_refBuilder-&gt;get_widget&lt;Gtk::Stack&gt;("stack");
  if (!m_stack)
    throw std::runtime_error("No \"stack\" object in window.ui");

  m_gears = m_refBuilder-&gt;get_widget&lt;Gtk::MenuButton&gt;("gears");
  if (!m_gears)
    throw std::runtime_error("No \"gears\" object in window.ui");

  // Connect the menu to the MenuButton m_gears.
  // (The connection between action and menu item is specified in gears_menu.ui.)
  auto menu_builder = Gtk::Builder::create_from_resource("/org/gtkmm/exampleapp/gears_menu.ui");
  auto menu = menu_builder-&gt;get_object&lt;Gio::MenuModel&gt;("menu");
  if (!menu)
    throw std::runtime_error("No \"menu\" object in gears_menu.ui");

  m_gears-&gt;set_menu_model(menu);
}

//static
ExampleAppWindow* ExampleAppWindow::create()
{
  // Load the Builder file and instantiate its widgets.
  auto refBuilder = Gtk::Builder::create_from_resource("/org/gtkmm/exampleapp/window.ui");

  auto window = Gtk::Builder::get_widget_derived&lt;ExampleAppWindow&gt;(refBuilder, "app_window");
  if (!window)
    throw std::runtime_error("No \"app_window\" object in window.ui");

  return window;
}

void ExampleAppWindow::open_file_view(const Glib::RefPtr&lt;Gio::File&gt;&amp; file)
{
  const Glib::ustring basename = file-&gt;get_basename();

  auto scrolled = Gtk::make_managed&lt;Gtk::ScrolledWindow&gt;();
  scrolled-&gt;set_expand(true);
  auto view = Gtk::make_managed&lt;Gtk::TextView&gt;();
  view-&gt;set_editable(false);
  view-&gt;set_cursor_visible(false);
  scrolled-&gt;set_child(*view);
  m_stack-&gt;add(*scrolled, basename, basename);

  try
  {
    char* contents = nullptr;
    gsize length = 0;
    
    file-&gt;load_contents(contents, length);
    view-&gt;get_buffer()-&gt;set_text(contents, contents+length);
    g_free(contents);
  }
  catch (const Glib::Error&amp; ex)
  {
    std::cout &lt;&lt; "ExampleAppWindow::open_file_view(\"" &lt;&lt; file-&gt;get_parse_name()
      &lt;&lt; "\"):\n  " &lt;&lt; ex.what() &lt;&lt; std::endl;
  }
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">exampleapplication.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "exampleapplication.h"
#include "exampleappwindow.h"
#include &lt;iostream&gt;
#include &lt;exception&gt;

ExampleApplication::ExampleApplication()
: Gtk::Application("org.gtkmm.examples.application", Gio::Application::Flags::HANDLES_OPEN)
{
}

Glib::RefPtr&lt;ExampleApplication&gt; ExampleApplication::create()
{
  return Glib::make_refptr_for_instance&lt;ExampleApplication&gt;(new ExampleApplication());
}

ExampleAppWindow* ExampleApplication::create_appwindow()
{
  auto appwindow = ExampleAppWindow::create();

  // Make sure that the application runs for as long this window is still open.
  add_window(*appwindow);

  // A window can be added to an application with Gtk::Application::add_window()
  // or Gtk::Window::set_application(). When all added windows have been hidden
  // or removed, the application stops running (Gtk::Application::run() returns()),
  // unless Gio::Application::hold() has been called.

  // Delete the window when it is hidden.
  appwindow-&gt;signal_hide().connect(sigc::bind(sigc::mem_fun(*this,
    &amp;ExampleApplication::on_hide_window), appwindow));

  return appwindow;
}

void ExampleApplication::on_startup()
{
  // Call the base class's implementation.
  Gtk::Application::on_startup();

  // Add actions and keyboard accelerators for the menu.
  add_action("preferences", sigc::mem_fun(*this, &amp;ExampleApplication::on_action_preferences));
  add_action("quit", sigc::mem_fun(*this, &amp;ExampleApplication::on_action_quit));
  set_accel_for_action("app.quit", "&lt;Ctrl&gt;Q");
}

void ExampleApplication::on_activate()
{
  try
  {
    // The application has been started, so let's show a window.
    auto appwindow = create_appwindow();
    appwindow-&gt;present();
  }
  // If create_appwindow() throws an exception (perhaps from Gtk::Builder),
  // no window has been created, no window has been added to the application,
  // and therefore the application will stop running.
  catch (const Glib::Error&amp; ex)
  {
    std::cerr &lt;&lt; "ExampleApplication::on_activate(): " &lt;&lt; ex.what() &lt;&lt; std::endl;
  }
  catch (const std::exception&amp; ex)
  {
    std::cerr &lt;&lt; "ExampleApplication::on_activate(): " &lt;&lt; ex.what() &lt;&lt; std::endl;
  }
}

void ExampleApplication::on_open(const Gio::Application::type_vec_files&amp; files,
  const Glib::ustring&amp; /* hint */)
{
  // The application has been asked to open some files,
  // so let's open a new view for each one.
  ExampleAppWindow* appwindow = nullptr;
  auto windows = get_windows();
  if (windows.size() &gt; 0)
    appwindow = dynamic_cast&lt;ExampleAppWindow*&gt;(windows[0]);

  try
  {
    if (!appwindow)
      appwindow = create_appwindow();

    for (const auto&amp; file : files)
      appwindow-&gt;open_file_view(file);

    appwindow-&gt;present();
  }
  catch (const Glib::Error&amp; ex)
  {
    std::cerr &lt;&lt; "ExampleApplication::on_open(): " &lt;&lt; ex.what() &lt;&lt; std::endl;
  }
  catch (const std::exception&amp; ex)
  {
    std::cerr &lt;&lt; "ExampleApplication::on_open(): " &lt;&lt; ex.what() &lt;&lt; std::endl;
  }
}

void ExampleApplication::on_hide_window(Gtk::Window* window)
{
  delete window;
}

void ExampleApplication::on_action_preferences()
{

}

void ExampleApplication::on_action_quit()
{
  // Gio::Application::quit() will make Gio::Application::run() return,
  // but it's a crude way of ending the program. The window is not removed
  // from the application. Neither the window's nor the application's
  // destructors will be called, because there will be remaining reference
  // counts in both of them. If we want the destructors to be called, we
  // must remove the window from the application. One way of doing this
  // is to hide the window. See comment in create_appwindow().
  auto windows = get_windows();
  for (auto window : windows)
    window-&gt;hide();

  // Not really necessary, when Gtk::Widget::hide() is called, unless
  // Gio::Application::hold() has been called without a corresponding call
  // to Gio::Application::release().
  quit();
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">exampleapp.gresource.xml</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;gresources&gt;
  &lt;gresource prefix="/org/gtkmm/exampleapp"&gt;
    &lt;file preprocess="xml-stripblanks"&gt;window.ui&lt;/file&gt;
    &lt;file preprocess="xml-stripblanks"&gt;gears_menu.ui&lt;/file&gt;
  &lt;/gresource&gt;
&lt;/gresources&gt;
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">gears_menu.ui</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;interface&gt;
  &lt;menu id="menu"&gt;
    &lt;section&gt;
      &lt;item&gt;
        &lt;attribute name="label" translatable="yes"&gt;_Preferences&lt;/attribute&gt;
        &lt;attribute name="action"&gt;app.preferences&lt;/attribute&gt;
      &lt;/item&gt;
    &lt;/section&gt;
    &lt;section&gt;
      &lt;item&gt;
        &lt;attribute name="label" translatable="yes"&gt;_Quit&lt;/attribute&gt;
        &lt;attribute name="action"&gt;app.quit&lt;/attribute&gt;
      &lt;/item&gt;
    &lt;/section&gt;
  &lt;/menu&gt;
&lt;/interface&gt;
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">window.ui</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;interface&gt;
  &lt;object class="GtkApplicationWindow" id="app_window"&gt;
    &lt;property name="title" translatable="yes"&gt;Example Application&lt;/property&gt;
    &lt;property name="default-width"&gt;600&lt;/property&gt;
    &lt;property name="default-height"&gt;400&lt;/property&gt;
    &lt;property name="hide-on-close"&gt;True&lt;/property&gt;
    &lt;child type="titlebar"&gt;
      &lt;object class="GtkHeaderBar" id="header"&gt;
        &lt;child type="title"&gt;
          &lt;object class="GtkStackSwitcher" id="tabs"&gt;
            &lt;property name="stack"&gt;stack&lt;/property&gt;
          &lt;/object&gt;
        &lt;/child&gt;
        &lt;child type="end"&gt;
          &lt;object class="GtkMenuButton" id="gears"&gt;
            &lt;property name="direction"&gt;none&lt;/property&gt;
          &lt;/object&gt;
        &lt;/child&gt;
      &lt;/object&gt;
    &lt;/child&gt;
    &lt;child&gt;
      &lt;object class="GtkBox" id="content_box"&gt;
        &lt;property name="orientation"&gt;vertical&lt;/property&gt;
        &lt;child&gt;
          &lt;object class="GtkStack" id="stack"/&gt;
        &lt;/child&gt;
      &lt;/object&gt;
    &lt;/child&gt;
  &lt;/object&gt;
&lt;/interface&gt;
</pre></div>
</div>
<div class="division sect1">
<a name="sec-buildapp-pref-dialog"><!--sec-buildapp-pref-dialog--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">29.5. </span>A preference dialog</span></h3></div>
<p class="para block block-first">
A typical application will have some preferences that should be remembered from one run
to the next. Even for our simple example application, we may want to change the font
that is used for the content.
</p>
<p class="para block">
We are going to use <span class="classname" dir="ltr">Gio::Settings</span> to store our preferences.
<span class="classname" dir="ltr">Gio::Settings</span> requires a schema that describes our settings,
in our case the <span class="filename" dir="ltr">org.gtkmm.exampleapp.gschema.xml</span> file.
</p>
<p class="para block">
Before we can make use of this schema in our application, we need to compile it into
the binary form that <span class="classname" dir="ltr">Gio::Settings</span> expects. GIO provides macros
to do this in autotools-based projects. See the description of
<a class="ulink" href="https://developer.gnome.org/gio/stable/GSettings.html" title="https://developer.gnome.org/gio/stable/GSettings.html">GSettings</a>.
Meson provides the <span class="function">compile_schemas()</span> function in the
<a class="ulink" href="https://mesonbuild.com/Gnome-module.html" title="https://mesonbuild.com/Gnome-module.html">GNOME module</a>.
</p>
<p class="para block">
Next, we need to connect our settings to the widgets that they are supposed to control.
One convenient way to do this is to use <span class="methodname" dir="ltr">Gio::Settings::bind()</span>
to bind settings keys to object properties, as we do for the transition setting in
<span class="classname" dir="ltr">ExampleAppWindow</span>'s constructor.
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">m_settings = Gio::Settings::create("org.gtkmm.exampleapp");
m_settings-&gt;bind("transition", m_stack-&gt;property_transition_type());
</pre></div>
<p class="para block">
The code to connect the font setting is a little more involved, since it corresponds to
an object property in a <span class="classname" dir="ltr">Gtk::TextTag</span> that we must first create.
The code is in <span class="methodname" dir="ltr">ExampleAppWindow::open_file_view()</span>.
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">auto tag = buffer-&gt;create_tag();
m_settings-&gt;bind("font", tag-&gt;property_font());
buffer-&gt;apply_tag(tag, buffer-&gt;begin(), buffer-&gt;end());
</pre></div>
<p class="para block">
At this point, the application will already react if you change one of the settings,
e.g. using the <span class="command" dir="ltr">gsettings</span> commandline tool. Of course, we expect
the application to provide a preference dialog for these. So lets do that now.
Our preference dialog will be a subclass of <span class="classname" dir="ltr">Gtk::Dialog</span>, and
we'll use the same techniques that we've already seen in <span class="classname" dir="ltr">ExampleAppWindow</span>:
a <span class="classname" dir="ltr">Gtk::Builder</span> ui file and settings bindings.
</p>
<p class="para block">
When we've created the <span class="filename" dir="ltr">prefs.ui</span> file and the <span class="classname" dir="ltr">ExampleAppPrefs</span>
class, we revisit the <span class="methodname" dir="ltr">ExampleApplication::on_action_preferences()</span>
method in our application class, and make it open a new preference dialog.
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">auto prefs_dialog = ExampleAppPrefs::create(*get_active_window());
prefs_dialog-&gt;present();
</pre></div>
<p class="para block">
After all this work, our application can now show a preference dialog like this:
</p>
<div class=" block figure block-indent">
<a name="figure-buildapp-pref-dialog"><!--figure-buildapp-pref-dialog--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 29-5</span> </span>An preference dialog</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/buildapp_pref_dialog.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/buildapp/step5" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/buildapp/step5">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">exampleapplication.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "../step4/exampleapplication.h"
// Equal to the corresponding file in step4
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">exampleappprefs.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEAPPPREFS_H_
#define GTKMM_EXAMPLEAPPPREFS_H_

#include &lt;gtkmm.h&gt;

class ExampleAppPrefs : public Gtk::Dialog
{
public:
  ExampleAppPrefs(BaseObjectType* cobject,
    const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; refBuilder);

  static ExampleAppPrefs* create(Gtk::Window&amp; parent);

protected:
  Glib::RefPtr&lt;Gtk::Builder&gt; m_refBuilder;
  Glib::RefPtr&lt;Gio::Settings&gt; m_settings;
  Gtk::FontButton* m_font;
  Gtk::ComboBoxText* m_transition;
};

#endif /* GTKMM_EXAMPLEAPPPREFS_H_ */
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">exampleappwindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEAPPWINDOW_H_
#define GTKMM_EXAMPLEAPPWINDOW_H_

#include &lt;gtkmm.h&gt;

class ExampleAppWindow : public Gtk::ApplicationWindow
{
public:
  ExampleAppWindow(BaseObjectType* cobject,
    const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; refBuilder);

  static ExampleAppWindow* create();

  void open_file_view(const Glib::RefPtr&lt;Gio::File&gt;&amp; file);

protected:
  Glib::RefPtr&lt;Gtk::Builder&gt; m_refBuilder;
  Glib::RefPtr&lt;Gio::Settings&gt; m_settings;
  Gtk::Stack* m_stack;
  Gtk::MenuButton* m_gears;
};

#endif /* GTKMM_EXAMPLEAPPWINDOW_H */
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "exampleapplication.h"

int main(int argc, char* argv[])
{
  // Since this example is running uninstalled, we have to help it find its
  // schema. This is *not* necessary in a properly installed application.
  Glib::setenv ("GSETTINGS_SCHEMA_DIR", ".", false);

  auto application = ExampleApplication::create();

  // Start the application, showing the initial window,
  // and opening extra views for any files that it is asked to open,
  // for instance as a command-line parameter.
  // run() will return when the last window has been closed.
  return application-&gt;run(argc, argv);
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">exampleappwindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "exampleappwindow.h"
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;

ExampleAppWindow::ExampleAppWindow(BaseObjectType* cobject,
  const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; refBuilder)
: Gtk::ApplicationWindow(cobject),
  m_refBuilder(refBuilder),
  m_settings(),
  m_stack(nullptr),
  m_gears(nullptr)
{
  // Get widgets from the Gtk::Builder file.
  m_stack = m_refBuilder-&gt;get_widget&lt;Gtk::Stack&gt;("stack");
  if (!m_stack)
    throw std::runtime_error("No \"stack\" object in window.ui");

  m_gears = m_refBuilder-&gt;get_widget&lt;Gtk::MenuButton&gt;("gears");
  if (!m_gears)
    throw std::runtime_error("No \"gears\" object in window.ui");

  // Bind settings.
  m_settings = Gio::Settings::create("org.gtkmm.exampleapp");
  m_settings-&gt;bind("transition", m_stack-&gt;property_transition_type());

  // Connect the menu to the MenuButton m_gears.
  // (The connection between action and menu item is specified in gears_menu.ui.)
  auto menu_builder = Gtk::Builder::create_from_resource("/org/gtkmm/exampleapp/gears_menu.ui");
  auto menu = menu_builder-&gt;get_object&lt;Gio::MenuModel&gt;("menu");
  if (!menu)
    throw std::runtime_error("No \"menu\" object in gears_menu.ui");

  m_gears-&gt;set_menu_model(menu);
}

//static
ExampleAppWindow* ExampleAppWindow::create()
{
  // Load the Builder file and instantiate its widgets.
  auto refBuilder = Gtk::Builder::create_from_resource("/org/gtkmm/exampleapp/window.ui");

  auto window = Gtk::Builder::get_widget_derived&lt;ExampleAppWindow&gt;(refBuilder, "app_window");
  if (!window)
    throw std::runtime_error("No \"app_window\" object in window.ui");

  return window;
}

void ExampleAppWindow::open_file_view(const Glib::RefPtr&lt;Gio::File&gt;&amp; file)
{
  const Glib::ustring basename = file-&gt;get_basename();

  auto scrolled = Gtk::make_managed&lt;Gtk::ScrolledWindow&gt;();
  scrolled-&gt;set_expand(true);
  auto view = Gtk::make_managed&lt;Gtk::TextView&gt;();
  view-&gt;set_editable(false);
  view-&gt;set_cursor_visible(false);
  scrolled-&gt;set_child(*view);
  m_stack-&gt;add(*scrolled, basename, basename);

  auto buffer = view-&gt;get_buffer();
  try
  {
    char* contents = nullptr;
    gsize length = 0;
    
    file-&gt;load_contents(contents, length);
    buffer-&gt;set_text(contents, contents+length);
    g_free(contents);
  }
  catch (const Glib::Error&amp; ex)
  {
    std::cout &lt;&lt; "ExampleAppWindow::open_file_view(\"" &lt;&lt; file-&gt;get_parse_name()
      &lt;&lt; "\"):\n  " &lt;&lt; ex.what() &lt;&lt; std::endl;
  }

  auto tag = buffer-&gt;create_tag();
  m_settings-&gt;bind("font", tag-&gt;property_font());
  buffer-&gt;apply_tag(tag, buffer-&gt;begin(), buffer-&gt;end());
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">exampleappprefs.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "exampleappprefs.h"
#include "exampleappwindow.h"
#include &lt;stdexcept&gt;

ExampleAppPrefs::ExampleAppPrefs(BaseObjectType* cobject,
  const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; refBuilder)
: Gtk::Dialog(cobject),
  m_refBuilder(refBuilder),
  m_settings(),
  m_font(nullptr),
  m_transition(nullptr)
{
  m_font = m_refBuilder-&gt;get_widget&lt;Gtk::FontButton&gt;("font");
  if (!m_font)
    throw std::runtime_error("No \"font\" object in prefs.ui");

  m_transition = m_refBuilder-&gt;get_widget&lt;Gtk::ComboBoxText&gt;("transition");
  if (!m_transition)
    throw std::runtime_error("No \"transition\" object in prefs.ui");

  m_settings = Gio::Settings::create("org.gtkmm.exampleapp");
  m_settings-&gt;bind("font", m_font-&gt;property_font());
  m_settings-&gt;bind("transition", m_transition-&gt;property_active_id());
}

//static
ExampleAppPrefs* ExampleAppPrefs::create(Gtk::Window&amp; parent)
{
  // Load the Builder file and instantiate its widgets.
  auto refBuilder = Gtk::Builder::create_from_resource("/org/gtkmm/exampleapp/prefs.ui");

  auto dialog = Gtk::Builder::get_widget_derived&lt;ExampleAppPrefs&gt;(refBuilder, "prefs_dialog");
  if (!dialog)
    throw std::runtime_error("No \"prefs_dialog\" object in prefs.ui");

  dialog-&gt;set_transient_for(parent);

  return dialog;
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">exampleapplication.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "exampleapplication.h"
#include "exampleappwindow.h"
#include "exampleappprefs.h"
#include &lt;iostream&gt;
#include &lt;exception&gt;

ExampleApplication::ExampleApplication()
: Gtk::Application("org.gtkmm.examples.application", Gio::Application::Flags::HANDLES_OPEN)
{
}

Glib::RefPtr&lt;ExampleApplication&gt; ExampleApplication::create()
{
  return Glib::make_refptr_for_instance&lt;ExampleApplication&gt;(new ExampleApplication());
}

ExampleAppWindow* ExampleApplication::create_appwindow()
{
  auto appwindow = ExampleAppWindow::create();

  // Make sure that the application runs for as long this window is still open.
  add_window(*appwindow);

  // A window can be added to an application with Gtk::Application::add_window()
  // or Gtk::Window::set_application(). When all added windows have been hidden
  // or removed, the application stops running (Gtk::Application::run() returns()),
  // unless Gio::Application::hold() has been called.

  // Delete the window when it is hidden.
  appwindow-&gt;signal_hide().connect(sigc::bind(sigc::mem_fun(*this,
    &amp;ExampleApplication::on_hide_window), appwindow));

  return appwindow;
}

void ExampleApplication::on_startup()
{
  // Call the base class's implementation.
  Gtk::Application::on_startup();

  // Add actions and keyboard accelerators for the menu.
  add_action("preferences", sigc::mem_fun(*this, &amp;ExampleApplication::on_action_preferences));
  add_action("quit", sigc::mem_fun(*this, &amp;ExampleApplication::on_action_quit));
  set_accel_for_action("app.quit", "&lt;Ctrl&gt;Q");
}

void ExampleApplication::on_activate()
{
  try
  {
    // The application has been started, so let's show a window.
    auto appwindow = create_appwindow();
    appwindow-&gt;present();
  }
  // If create_appwindow() throws an exception (perhaps from Gtk::Builder),
  // no window has been created, no window has been added to the application,
  // and therefore the application will stop running.
  catch (const Glib::Error&amp; ex)
  {
    std::cerr &lt;&lt; "ExampleApplication::on_activate(): " &lt;&lt; ex.what() &lt;&lt; std::endl;
  }
  catch (const std::exception&amp; ex)
  {
    std::cerr &lt;&lt; "ExampleApplication::on_activate(): " &lt;&lt; ex.what() &lt;&lt; std::endl;
  }
}

void ExampleApplication::on_open(const Gio::Application::type_vec_files&amp; files,
  const Glib::ustring&amp; /* hint */)
{
  // The application has been asked to open some files,
  // so let's open a new view for each one.
  ExampleAppWindow* appwindow = nullptr;
  auto windows = get_windows();
  if (windows.size() &gt; 0)
    appwindow = dynamic_cast&lt;ExampleAppWindow*&gt;(windows[0]);

  try
  {
    if (!appwindow)
      appwindow = create_appwindow();

    for (const auto&amp; file : files)
      appwindow-&gt;open_file_view(file);

    appwindow-&gt;present();
  }
  catch (const Glib::Error&amp; ex)
  {
    std::cerr &lt;&lt; "ExampleApplication::on_open(): " &lt;&lt; ex.what() &lt;&lt; std::endl;
  }
  catch (const std::exception&amp; ex)
  {
    std::cerr &lt;&lt; "ExampleApplication::on_open(): " &lt;&lt; ex.what() &lt;&lt; std::endl;
  }
}

void ExampleApplication::on_hide_window(Gtk::Window* window)
{
  delete window;
}

void ExampleApplication::on_action_preferences()
{
  try
  {
    auto prefs_dialog = ExampleAppPrefs::create(*get_active_window());
    prefs_dialog-&gt;present();

    // Delete the dialog when it is hidden.
    prefs_dialog-&gt;signal_hide().connect(sigc::bind(sigc::mem_fun(*this,
      &amp;ExampleApplication::on_hide_window), prefs_dialog));
  }
  catch (const Glib::Error&amp; ex)
  {
    std::cerr &lt;&lt; "ExampleApplication::on_action_preferences(): " &lt;&lt; ex.what() &lt;&lt; std::endl;
  }
  catch (const std::exception&amp; ex)
  {
    std::cerr &lt;&lt; "ExampleApplication::on_action_preferences(): " &lt;&lt; ex.what() &lt;&lt; std::endl;
  }
}

void ExampleApplication::on_action_quit()
{
  // Gio::Application::quit() will make Gio::Application::run() return,
  // but it's a crude way of ending the program. The window is not removed
  // from the application. Neither the window's nor the application's
  // destructors will be called, because there will be remaining reference
  // counts in both of them. If we want the destructors to be called, we
  // must remove the window from the application. One way of doing this
  // is to hide the window. See comment in create_appwindow().
  auto windows = get_windows();
  for (auto window : windows)
    window-&gt;hide();

  // Not really necessary, when Gtk::Widget::hide() is called, unless
  // Gio::Application::hold() has been called without a corresponding call
  // to Gio::Application::release().
  quit();
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">exampleapp.gresource.xml</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;gresources&gt;
  &lt;gresource prefix="/org/gtkmm/exampleapp"&gt;
    &lt;file preprocess="xml-stripblanks"&gt;window.ui&lt;/file&gt;
    &lt;file preprocess="xml-stripblanks"&gt;gears_menu.ui&lt;/file&gt;
    &lt;file preprocess="xml-stripblanks"&gt;prefs.ui&lt;/file&gt;
  &lt;/gresource&gt;
&lt;/gresources&gt;
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">prefs.ui</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;interface&gt;
  &lt;object class="GtkDialog" id="prefs_dialog"&gt;
    &lt;property name="title" translatable="yes"&gt;Preferences&lt;/property&gt;
    &lt;property name="resizable"&gt;False&lt;/property&gt;
    &lt;property name="modal"&gt;True&lt;/property&gt;
    &lt;child internal-child="content_area"&gt;
      &lt;object class="GtkBox" id="content_area"&gt;
        &lt;child&gt;
          &lt;object class="GtkGrid" id="grid"&gt;
            &lt;property name="margin-start"&gt;12&lt;/property&gt;
            &lt;property name="margin-end"&gt;12&lt;/property&gt;
            &lt;property name="margin-top"&gt;12&lt;/property&gt;
            &lt;property name="margin-bottom"&gt;12&lt;/property&gt;
            &lt;property name="row-spacing"&gt;12&lt;/property&gt;
            &lt;property name="column-spacing"&gt;12&lt;/property&gt;
            &lt;child&gt;
              &lt;object class="GtkLabel" id="fontlabel"&gt;
                &lt;property name="label"&gt;_Font:&lt;/property&gt;
                &lt;property name="use-underline"&gt;True&lt;/property&gt;
                &lt;property name="mnemonic-widget"&gt;font&lt;/property&gt;
                &lt;property name="xalign"&gt;1&lt;/property&gt;
                &lt;layout&gt;
                  &lt;property name="column"&gt;0&lt;/property&gt;
                  &lt;property name="row"&gt;0&lt;/property&gt;
                &lt;/layout&gt;
              &lt;/object&gt;
            &lt;/child&gt;
            &lt;child&gt;
              &lt;object class="GtkFontButton" id="font"&gt;
                &lt;layout&gt;
                  &lt;property name="column"&gt;1&lt;/property&gt;
                  &lt;property name="row"&gt;0&lt;/property&gt;
                &lt;/layout&gt;
              &lt;/object&gt;
            &lt;/child&gt;
            &lt;child&gt;
              &lt;object class="GtkLabel" id="transitionlabel"&gt;
                &lt;property name="label"&gt;_Transition:&lt;/property&gt;
                &lt;property name="use-underline"&gt;True&lt;/property&gt;
                &lt;property name="mnemonic-widget"&gt;transition&lt;/property&gt;
                &lt;property name="xalign"&gt;1&lt;/property&gt;
                &lt;layout&gt;
                  &lt;property name="column"&gt;0&lt;/property&gt;
                  &lt;property name="row"&gt;1&lt;/property&gt;
                &lt;/layout&gt;
              &lt;/object&gt;
            &lt;/child&gt;
            &lt;child&gt;
              &lt;object class="GtkComboBoxText" id="transition"&gt;
                &lt;items&gt;
                  &lt;item translatable="yes" id="none"&gt;None&lt;/item&gt;
                  &lt;item translatable="yes" id="crossfade"&gt;Fade&lt;/item&gt;
                  &lt;item translatable="yes" id="slide-left-right"&gt;Slide&lt;/item&gt;
                &lt;/items&gt;
                &lt;layout&gt;
                  &lt;property name="column"&gt;1&lt;/property&gt;
                  &lt;property name="row"&gt;1&lt;/property&gt;
                &lt;/layout&gt;
              &lt;/object&gt;
            &lt;/child&gt;
          &lt;/object&gt;
        &lt;/child&gt;
      &lt;/object&gt;
    &lt;/child&gt;
  &lt;/object&gt;
&lt;/interface&gt;
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">org.gtkmm.exampleapp.gschema.xml</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;schemalist&gt;
  &lt;schema path="/org/gtkmm/exampleapp/" id="org.gtkmm.exampleapp"&gt;
    &lt;key name="font" type="s"&gt;
      &lt;default&gt;'Monospace 12'&lt;/default&gt;
      &lt;summary&gt;Font&lt;/summary&gt;
      &lt;description&gt;The font to be used for content.&lt;/description&gt;
    &lt;/key&gt;
    &lt;key name="transition" type="s"&gt;
      &lt;choices&gt;
        &lt;choice value='none'/&gt;
        &lt;choice value='crossfade'/&gt;
        &lt;choice value='slide-left-right'/&gt;
      &lt;/choices&gt;
      &lt;default&gt;'none'&lt;/default&gt;
      &lt;summary&gt;Transition&lt;/summary&gt;
      &lt;description&gt;The transition to use when switching tabs.&lt;/description&gt;
    &lt;/key&gt;
  &lt;/schema&gt;
&lt;/schemalist&gt;
</pre></div>
</div>
<div class="division sect1">
<a name="sec-buildapp-search-bar"><!--sec-buildapp-search-bar--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">29.6. </span>Adding a search bar</span></h3></div>
<p class="para block block-first">
We continue to flesh out the functionality of our application. For now, we add search.
<span class="application">gtkmm</span> supports this with <span class="classname" dir="ltr">Gtk::SearchEntry</span> and <span class="classname" dir="ltr">Gtk::SearchBar</span>.
The search bar is a widget that can slide in from the top to present a search entry.
</p>
<p class="para block">
We add a toggle button to the header bar, which can be used to slide out the search bar
below the header bar. The new widgets are added in the <span class="filename" dir="ltr">window.ui</span> file.
</p>
<p class="para block">
Implementing the search needs quite a few code changes that we are not going to completely
go over here. The central piece of the search implementation is a signal handler that
listens for text changes in the search entry, shown here without error handling.
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">void ExampleAppWindow::on_search_text_changed()
{
  const auto text = m_searchentry-&gt;get_text();
  auto tab = dynamic_cast&lt;Gtk::ScrolledWindow*&gt;(m_stack-&gt;get_visible_child());
  auto view = dynamic_cast&lt;Gtk::TextView*&gt;(tab-&gt;get_child());

  // Very simple-minded search implementation.
  auto buffer = view-&gt;get_buffer();
  Gtk::TextIter match_start;
  Gtk::TextIter match_end;
  if (buffer-&gt;begin().forward_search(text, Gtk::TextSearchFlags::CASE_INSENSITIVE,
      match_start, match_end))
  {
    buffer-&gt;select_range(match_start, match_end);
    view-&gt;scroll_to(match_start);
  }
}
</pre></div>
<p class="para block">
With the search bar, our application now looks like this:
</p>
<div class=" block figure block-indent">
<a name="figure-buildapp-search-bar"><!--figure-buildapp-search-bar--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 29-6</span> </span>Adding a search bar</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/buildapp_search_bar.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/buildapp/step6" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/buildapp/step6">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">exampleapplication.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "../step4/exampleapplication.h"
// Equal to the corresponding file in step4
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">exampleappprefs.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "../step5/exampleappprefs.h"
// Equal to the corresponding file in step5
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">exampleappwindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEAPPWINDOW_H_
#define GTKMM_EXAMPLEAPPWINDOW_H_

#include &lt;gtkmm.h&gt;

class ExampleAppWindow : public Gtk::ApplicationWindow
{
public:
  ExampleAppWindow(BaseObjectType* cobject,
    const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; refBuilder);

  static ExampleAppWindow* create();

  void open_file_view(const Glib::RefPtr&lt;Gio::File&gt;&amp; file);

protected:
  // Signal handlers
  void on_search_text_changed();
  void on_visible_child_changed();

  Glib::RefPtr&lt;Gtk::Builder&gt; m_refBuilder;
  Glib::RefPtr&lt;Gio::Settings&gt; m_settings;
  Gtk::Stack* m_stack;
  Gtk::ToggleButton* m_search;
  Gtk::SearchBar* m_searchbar;
  Gtk::SearchEntry* m_searchentry;
  Gtk::MenuButton* m_gears;
  Glib::RefPtr&lt;Glib::Binding&gt; m_prop_binding;
};

#endif /* GTKMM_EXAMPLEAPPWINDOW_H */
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "../step5/main.cc"
// Equal to the corresponding file in step5
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">exampleappwindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "exampleappwindow.h"
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;

ExampleAppWindow::ExampleAppWindow(BaseObjectType* cobject,
  const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; refBuilder)
: Gtk::ApplicationWindow(cobject),
  m_refBuilder(refBuilder),
  m_settings(),
  m_stack(nullptr),
  m_search(nullptr),
  m_searchbar(nullptr),
  m_searchentry(nullptr),
  m_gears(nullptr),
  m_prop_binding()
{
  // Get widgets from the Gtk::Builder file.
  m_stack = m_refBuilder-&gt;get_widget&lt;Gtk::Stack&gt;("stack");
  if (!m_stack)
    throw std::runtime_error("No \"stack\" object in window.ui");

  m_search = m_refBuilder-&gt;get_widget&lt;Gtk::ToggleButton&gt;("search");
  if (!m_search)
    throw std::runtime_error("No \"search\" object in window.ui");

  m_searchbar = m_refBuilder-&gt;get_widget&lt;Gtk::SearchBar&gt;("searchbar");
  if (!m_searchbar)
    throw std::runtime_error("No \"searchbar\" object in window.ui");

  m_searchentry = m_refBuilder-&gt;get_widget&lt;Gtk::SearchEntry&gt;("searchentry");
  if (!m_searchentry)
    throw std::runtime_error("No \"searchentry\" object in window.ui");

  m_gears = m_refBuilder-&gt;get_widget&lt;Gtk::MenuButton&gt;("gears");
  if (!m_gears)
    throw std::runtime_error("No \"gears\" object in window.ui");

  // Bind settings.
  m_settings = Gio::Settings::create("org.gtkmm.exampleapp");
  m_settings-&gt;bind("transition", m_stack-&gt;property_transition_type());

  // Bind properties.
  m_prop_binding = Glib::Binding::bind_property(m_search-&gt;property_active(),
    m_searchbar-&gt;property_search_mode_enabled(), Glib::Binding::Flags::BIDIRECTIONAL);

  // Connect signal handlers.
  m_searchentry-&gt;signal_search_changed().connect(
    sigc::mem_fun(*this, &amp;ExampleAppWindow::on_search_text_changed));
  m_stack-&gt;property_visible_child().signal_changed().connect(
    sigc::mem_fun(*this, &amp;ExampleAppWindow::on_visible_child_changed));

  // Connect the menu to the MenuButton m_gears.
  // (The connection between action and menu item is specified in gears_menu.ui.)
  auto menu_builder = Gtk::Builder::create_from_resource("/org/gtkmm/exampleapp/gears_menu.ui");
  auto menu = menu_builder-&gt;get_object&lt;Gio::MenuModel&gt;("menu");
  if (!menu)
    throw std::runtime_error("No \"menu\" object in gears_menu.ui");

  m_gears-&gt;set_menu_model(menu);
}

//static
ExampleAppWindow* ExampleAppWindow::create()
{
  // Load the Builder file and instantiate its widgets.
  auto refBuilder = Gtk::Builder::create_from_resource("/org/gtkmm/exampleapp/window.ui");

  auto window = Gtk::Builder::get_widget_derived&lt;ExampleAppWindow&gt;(refBuilder, "app_window");
  if (!window)
    throw std::runtime_error("No \"app_window\" object in window.ui");

  return window;
}

void ExampleAppWindow::open_file_view(const Glib::RefPtr&lt;Gio::File&gt;&amp; file)
{
  const Glib::ustring basename = file-&gt;get_basename();

  auto scrolled = Gtk::make_managed&lt;Gtk::ScrolledWindow&gt;();
  scrolled-&gt;set_expand(true);
  auto view = Gtk::make_managed&lt;Gtk::TextView&gt;();
  view-&gt;set_editable(false);
  view-&gt;set_cursor_visible(false);
  scrolled-&gt;set_child(*view);
  m_stack-&gt;add(*scrolled, basename, basename);

  auto buffer = view-&gt;get_buffer();
  try
  {
    char* contents = nullptr;
    gsize length = 0;
    
    file-&gt;load_contents(contents, length);
    buffer-&gt;set_text(contents, contents+length);
    g_free(contents);
  }
  catch (const Glib::Error&amp; ex)
  {
    std::cout &lt;&lt; "ExampleAppWindow::open_file_view(\"" &lt;&lt; file-&gt;get_parse_name()
      &lt;&lt; "\"):\n  " &lt;&lt; ex.what() &lt;&lt; std::endl;
    return;
  }

  auto tag = buffer-&gt;create_tag();
  m_settings-&gt;bind("font", tag-&gt;property_font());
  buffer-&gt;apply_tag(tag, buffer-&gt;begin(), buffer-&gt;end());

  m_search-&gt;set_sensitive(true);
}

void ExampleAppWindow::on_search_text_changed()
{
  const auto text = m_searchentry-&gt;get_text();
  if (text.empty())
    return;

  auto tab = dynamic_cast&lt;Gtk::ScrolledWindow*&gt;(m_stack-&gt;get_visible_child());
  if (!tab)
  {
    std::cout &lt;&lt; "ExampleAppWindow::on_search_text_changed(): No visible child." &lt;&lt; std::endl;
    return;
  }

  auto view = dynamic_cast&lt;Gtk::TextView*&gt;(tab-&gt;get_child());
  if (!view)
  {
    std::cout &lt;&lt; "ExampleAppWindow::on_search_text_changed(): No visible text view." &lt;&lt; std::endl;
    return;
  }

  // Very simple-minded search implementation.
  auto buffer = view-&gt;get_buffer();
  Gtk::TextIter match_start;
  Gtk::TextIter match_end;
  if (buffer-&gt;begin().forward_search(text, Gtk::TextSearchFlags::CASE_INSENSITIVE,
      match_start, match_end))
  {
    buffer-&gt;select_range(match_start, match_end);
    view-&gt;scroll_to(match_start);
  }
}

void ExampleAppWindow::on_visible_child_changed()
{
  m_searchbar-&gt;set_search_mode(false);
}

</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">exampleappprefs.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "../step5/exampleappprefs.cc"
// Equal to the corresponding file in step5
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">exampleapplication.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "../step5/exampleapplication.cc"
// Equal to the corresponding file in step5
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">window.ui</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;interface&gt;
  &lt;object class="GtkApplicationWindow" id="app_window"&gt;
    &lt;property name="title" translatable="yes"&gt;Example Application&lt;/property&gt;
    &lt;property name="default-width"&gt;600&lt;/property&gt;
    &lt;property name="default-height"&gt;400&lt;/property&gt;
    &lt;property name="hide-on-close"&gt;True&lt;/property&gt;
    &lt;child type="titlebar"&gt;
      &lt;object class="GtkHeaderBar" id="header"&gt;
        &lt;child type="title"&gt;
          &lt;object class="GtkStackSwitcher" id="tabs"&gt;
            &lt;property name="stack"&gt;stack&lt;/property&gt;
          &lt;/object&gt;
        &lt;/child&gt;
        &lt;child type="end"&gt;
          &lt;object class="GtkMenuButton" id="gears"&gt;
            &lt;property name="direction"&gt;none&lt;/property&gt;
          &lt;/object&gt;
        &lt;/child&gt;
        &lt;child type="end"&gt;
          &lt;object class="GtkToggleButton" id="search"&gt;
            &lt;property name="sensitive"&gt;False&lt;/property&gt;
            &lt;property name="icon-name"&gt;edit-find-symbolic&lt;/property&gt;
          &lt;/object&gt;
        &lt;/child&gt;
      &lt;/object&gt;
    &lt;/child&gt;
    &lt;child&gt;
      &lt;object class="GtkBox" id="content_box"&gt;
        &lt;property name="orientation"&gt;vertical&lt;/property&gt;
        &lt;child&gt;
          &lt;object class="GtkSearchBar" id="searchbar"&gt;
            &lt;child&gt;
              &lt;object class="GtkSearchEntry" id="searchentry"&gt;
              &lt;/object&gt;
            &lt;/child&gt;
          &lt;/object&gt;
        &lt;/child&gt;
        &lt;child&gt;
          &lt;object class="GtkStack" id="stack"&gt;
            &lt;property name="transition-duration"&gt;500&lt;/property&gt;
          &lt;/object&gt;
        &lt;/child&gt;
      &lt;/object&gt;
    &lt;/child&gt;
  &lt;/object&gt;
&lt;/interface&gt;
</pre></div>
</div>
<div class="division sect1">
<a name="sec-buildapp-side-bar"><!--sec-buildapp-side-bar--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">29.7. </span>Adding a side bar</span></h3></div>
<p class="para block block-first">
As another piece of functionality, we are adding a sidebar, which demonstrates
<span class="classname" dir="ltr">Gtk::Revealer</span> and <span class="classname" dir="ltr">Gtk::ListBox</span>.
The new widgets are added in the <span class="filename" dir="ltr">window.ui</span> file.
</p>
<p class="para block">
The code to populate the sidebar with buttons for the words found in each
file is a little too involved to go into here. But we'll look at the code
to add a checkbutton for the new feature to the menu. A menu item is added to
the ui file <span class="filename" dir="ltr">gears_menu.ui</span>.
</p>
<p class="para block">
To connect the menu item to the new <span class="literal" dir="ltr">show-words</span> setting, we use a
<span class="classname" dir="ltr">Gio::Action</span> corresponding to the given <span class="classname" dir="ltr">Gio::Settings</span>
key. In <span class="classname" dir="ltr">ExampleAppWindow</span>'s constructor:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">// Connect the menu to the MenuButton m_gears, and bind the show-words setting
// to the win.show-words action and the "Words" menu item.
// (The connection between action and menu item is specified in gears_menu.ui.)
auto menu_builder = Gtk::Builder::create_from_resource("/org/gtkmm/exampleapp/gears_menu.ui");
auto menu = menu_builder-&gt;get_object&lt;Gio::MenuModel&gt;("menu");
m_gears-&gt;set_menu_model(menu);
add_action(m_settings-&gt;create_action("show-words"));
</pre></div>
<p class="para block">
What our application looks like now:
</p>
<div class=" block figure block-indent">
<a name="figure-buildapp-side-bar"><!--figure-buildapp-side-bar--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 29-7</span> </span>Adding a side bar</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/buildapp_side_bar.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/buildapp/step7" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/buildapp/step7">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">exampleapplication.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "../step4/exampleapplication.h"
// Equal to the corresponding file in step4
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">exampleappprefs.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "../step5/exampleappprefs.h"
// Equal to the corresponding file in step5
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">exampleappwindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEAPPWINDOW_H_
#define GTKMM_EXAMPLEAPPWINDOW_H_

#include &lt;gtkmm.h&gt;

class ExampleAppWindow : public Gtk::ApplicationWindow
{
public:
  ExampleAppWindow(BaseObjectType* cobject,
    const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; refBuilder);

  static ExampleAppWindow* create();

  void open_file_view(const Glib::RefPtr&lt;Gio::File&gt;&amp; file);

protected:
  // Signal handlers
  void on_search_text_changed();
  void on_visible_child_changed();
  void on_find_word(const Gtk::Button* button);
  void on_reveal_child_changed();

  void update_words();

  Glib::RefPtr&lt;Gtk::Builder&gt; m_refBuilder;
  Glib::RefPtr&lt;Gio::Settings&gt; m_settings;
  Gtk::Stack* m_stack;
  Gtk::ToggleButton* m_search;
  Gtk::SearchBar* m_searchbar;
  Gtk::SearchEntry* m_searchentry;
  Gtk::MenuButton* m_gears;
  Gtk::Revealer* m_sidebar;
  Gtk::ListBox* m_words;
  Glib::RefPtr&lt;Glib::Binding&gt; m_prop_binding;
};

#endif /* GTKMM_EXAMPLEAPPWINDOW_H */
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "../step5/main.cc"
// Equal to the corresponding file in step5
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">exampleappwindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "exampleappwindow.h"
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;set&gt;

ExampleAppWindow::ExampleAppWindow(BaseObjectType* cobject,
  const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; refBuilder)
: Gtk::ApplicationWindow(cobject),
  m_refBuilder(refBuilder),
  m_settings(),
  m_stack(nullptr),
  m_search(nullptr),
  m_searchbar(nullptr),
  m_searchentry(nullptr),
  m_gears(nullptr),
  m_sidebar(nullptr),
  m_words(nullptr),
  m_prop_binding()
{
  // Get widgets from the Gtk::Builder file.
  m_stack = m_refBuilder-&gt;get_widget&lt;Gtk::Stack&gt;("stack");
  if (!m_stack)
    throw std::runtime_error("No \"stack\" object in window.ui");

  m_search = m_refBuilder-&gt;get_widget&lt;Gtk::ToggleButton&gt;("search");
  if (!m_search)
    throw std::runtime_error("No \"search\" object in window.ui");

  m_searchbar = m_refBuilder-&gt;get_widget&lt;Gtk::SearchBar&gt;("searchbar");
  if (!m_searchbar)
    throw std::runtime_error("No \"searchbar\" object in window.ui");

  m_searchentry = m_refBuilder-&gt;get_widget&lt;Gtk::SearchEntry&gt;("searchentry");
  if (!m_searchentry)
    throw std::runtime_error("No \"searchentry\" object in window.ui");

  m_gears = m_refBuilder-&gt;get_widget&lt;Gtk::MenuButton&gt;("gears");
  if (!m_gears)
    throw std::runtime_error("No \"gears\" object in window.ui");

  m_sidebar = m_refBuilder-&gt;get_widget&lt;Gtk::Revealer&gt;("sidebar");
  if (!m_sidebar)
    throw std::runtime_error("No \"sidebar\" object in window.ui");

  m_words = m_refBuilder-&gt;get_widget&lt;Gtk::ListBox&gt;("words");
  if (!m_words)
    throw std::runtime_error("No \"words\" object in window.ui");

  // Bind settings.
  m_settings = Gio::Settings::create("org.gtkmm.exampleapp");
  m_settings-&gt;bind("transition", m_stack-&gt;property_transition_type());
  m_settings-&gt;bind("show-words", m_sidebar-&gt;property_reveal_child());

  // Bind properties.
  m_prop_binding = Glib::Binding::bind_property(m_search-&gt;property_active(),
    m_searchbar-&gt;property_search_mode_enabled(), Glib::Binding::Flags::BIDIRECTIONAL);

  // Connect signal handlers.
  m_searchentry-&gt;signal_search_changed().connect(
    sigc::mem_fun(*this, &amp;ExampleAppWindow::on_search_text_changed));
  m_stack-&gt;property_visible_child().signal_changed().connect(
    sigc::mem_fun(*this, &amp;ExampleAppWindow::on_visible_child_changed));
  m_sidebar-&gt;property_reveal_child().signal_changed().connect(
    sigc::mem_fun(*this, &amp;ExampleAppWindow::on_reveal_child_changed));

  // Connect the menu to the MenuButton m_gears, and bind the show-words setting
  // to the win.show-words action and the "Words" menu item.
  // (The connection between action and menu item is specified in gears_menu.ui.)
  auto menu_builder = Gtk::Builder::create_from_resource("/org/gtkmm/exampleapp/gears_menu.ui");
  auto menu = menu_builder-&gt;get_object&lt;Gio::MenuModel&gt;("menu");
  if (!menu)
    throw std::runtime_error("No \"menu\" object in gears_menu.ui");

  m_gears-&gt;set_menu_model(menu);
  add_action(m_settings-&gt;create_action("show-words"));
}

//static
ExampleAppWindow* ExampleAppWindow::create()
{
  // Load the Builder file and instantiate its widgets.
  auto refBuilder = Gtk::Builder::create_from_resource("/org/gtkmm/exampleapp/window.ui");

  auto window = Gtk::Builder::get_widget_derived&lt;ExampleAppWindow&gt;(refBuilder, "app_window");
  if (!window)
    throw std::runtime_error("No \"app_window\" object in window.ui");

  return window;
}

void ExampleAppWindow::open_file_view(const Glib::RefPtr&lt;Gio::File&gt;&amp; file)
{
  const Glib::ustring basename = file-&gt;get_basename();

  auto scrolled = Gtk::make_managed&lt;Gtk::ScrolledWindow&gt;();
  scrolled-&gt;set_expand(true);
  auto view = Gtk::make_managed&lt;Gtk::TextView&gt;();
  view-&gt;set_editable(false);
  view-&gt;set_cursor_visible(false);
  scrolled-&gt;set_child(*view);
  m_stack-&gt;add(*scrolled, basename, basename);

  auto buffer = view-&gt;get_buffer();
  try
  {
    char* contents = nullptr;
    gsize length = 0;
    
    file-&gt;load_contents(contents, length);
    buffer-&gt;set_text(contents, contents+length);
    g_free(contents);
  }
  catch (const Glib::Error&amp; ex)
  {
    std::cout &lt;&lt; "ExampleAppWindow::open_file_view(\"" &lt;&lt; file-&gt;get_parse_name()
      &lt;&lt; "\"):\n  " &lt;&lt; ex.what() &lt;&lt; std::endl;
    return;
  }

  auto tag = buffer-&gt;create_tag();
  m_settings-&gt;bind("font", tag-&gt;property_font());
  buffer-&gt;apply_tag(tag, buffer-&gt;begin(), buffer-&gt;end());

  m_search-&gt;set_sensitive(true);
  update_words();
}

void ExampleAppWindow::on_search_text_changed()
{
  const auto text = m_searchentry-&gt;get_text();
  if (text.empty())
    return;

  auto tab = dynamic_cast&lt;Gtk::ScrolledWindow*&gt;(m_stack-&gt;get_visible_child());
  if (!tab)
  {
    std::cout &lt;&lt; "ExampleAppWindow::on_search_text_changed(): No visible child." &lt;&lt; std::endl;
    return;
  }

  auto view = dynamic_cast&lt;Gtk::TextView*&gt;(tab-&gt;get_child());
  if (!view)
  {
    std::cout &lt;&lt; "ExampleAppWindow::on_search_text_changed(): No visible text view." &lt;&lt; std::endl;
    return;
  }

  // Very simple-minded search implementation.
  auto buffer = view-&gt;get_buffer();
  Gtk::TextIter match_start;
  Gtk::TextIter match_end;
  if (buffer-&gt;begin().forward_search(text, Gtk::TextSearchFlags::CASE_INSENSITIVE,
      match_start, match_end))
  {
    buffer-&gt;select_range(match_start, match_end);
    view-&gt;scroll_to(match_start);
  }
}

void ExampleAppWindow::on_visible_child_changed()
{
  m_searchbar-&gt;set_search_mode(false);
  update_words();
}

void ExampleAppWindow::on_find_word(const Gtk::Button* button)
{
  m_searchentry-&gt;set_text(button-&gt;get_label());
}

void ExampleAppWindow::on_reveal_child_changed()
{
  update_words();
}

void ExampleAppWindow::update_words()
{
  auto tab = dynamic_cast&lt;Gtk::ScrolledWindow*&gt;(m_stack-&gt;get_visible_child());
  if (!tab)
    return;

  auto view = dynamic_cast&lt;Gtk::TextView*&gt;(tab-&gt;get_child());
  if (!view)
  {
    std::cout &lt;&lt; "ExampleAppWindow::update_words(): No visible text view." &lt;&lt; std::endl;
    return;
  }
  auto buffer = view-&gt;get_buffer();

  // Find all words in the text buffer.
  std::set&lt;Glib::ustring&gt; words;
  auto start = buffer-&gt;begin();
  Gtk::TextIter end;
  while (start)
  {
    while (start &amp;&amp; !start.starts_word())
      ++start;

    if (!start)
      break;

    end = start;
    end.forward_word_end();
    if (start == end)
      break;

    auto word = buffer-&gt;get_text(start, end, false);
    words.insert(word.lowercase());
    start = end;
  }

  // Remove old children from the ListBox.
  while (auto child = m_words-&gt;get_first_child())
    m_words-&gt;remove(*child);

  // Add new child buttons, one per unique word.
  for (const auto&amp; word : words)
  {
    auto row = Gtk::make_managed&lt;Gtk::Button&gt;(word);
    row-&gt;signal_clicked().connect(sigc::bind(sigc::mem_fun(*this,
      &amp;ExampleAppWindow::on_find_word), row));
    m_words-&gt;append(*row);
  }
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">exampleappprefs.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "../step5/exampleappprefs.cc"
// Equal to the corresponding file in step5
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">exampleapplication.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "../step5/exampleapplication.cc"
// Equal to the corresponding file in step5
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">gears_menu.ui</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;interface&gt;
  &lt;menu id="menu"&gt;
    &lt;section&gt;
      &lt;item&gt;
        &lt;attribute name="label" translatable="yes"&gt;_Words&lt;/attribute&gt;
        &lt;attribute name="action"&gt;win.show-words&lt;/attribute&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;attribute name="label" translatable="yes"&gt;_Preferences&lt;/attribute&gt;
        &lt;attribute name="action"&gt;app.preferences&lt;/attribute&gt;
      &lt;/item&gt;
    &lt;/section&gt;
    &lt;section&gt;
      &lt;item&gt;
        &lt;attribute name="label" translatable="yes"&gt;_Quit&lt;/attribute&gt;
        &lt;attribute name="action"&gt;app.quit&lt;/attribute&gt;
      &lt;/item&gt;
    &lt;/section&gt;
  &lt;/menu&gt;
&lt;/interface&gt;
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">window.ui</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;interface&gt;
  &lt;object class="GtkApplicationWindow" id="app_window"&gt;
    &lt;property name="title" translatable="yes"&gt;Example Application&lt;/property&gt;
    &lt;property name="default-width"&gt;600&lt;/property&gt;
    &lt;property name="default-height"&gt;400&lt;/property&gt;
    &lt;property name="hide-on-close"&gt;True&lt;/property&gt;
    &lt;child type="titlebar"&gt;
      &lt;object class="GtkHeaderBar" id="header"&gt;
        &lt;child type="title"&gt;
          &lt;object class="GtkStackSwitcher" id="tabs"&gt;
            &lt;property name="stack"&gt;stack&lt;/property&gt;
          &lt;/object&gt;
        &lt;/child&gt;
        &lt;child type="end"&gt;
          &lt;object class="GtkToggleButton" id="search"&gt;
            &lt;property name="sensitive"&gt;False&lt;/property&gt;
            &lt;property name="icon-name"&gt;edit-find-symbolic&lt;/property&gt;
          &lt;/object&gt;
        &lt;/child&gt;
        &lt;child type="end"&gt;
          &lt;object class="GtkMenuButton" id="gears"&gt;
            &lt;property name="direction"&gt;none&lt;/property&gt;
          &lt;/object&gt;
        &lt;/child&gt;
      &lt;/object&gt;
    &lt;/child&gt;
    &lt;child&gt;
      &lt;object class="GtkBox" id="content_box"&gt;
        &lt;property name="orientation"&gt;vertical&lt;/property&gt;
        &lt;child&gt;
          &lt;object class="GtkSearchBar" id="searchbar"&gt;
            &lt;child&gt;
              &lt;object class="GtkSearchEntry" id="searchentry"&gt;
              &lt;/object&gt;
            &lt;/child&gt;
          &lt;/object&gt;
        &lt;/child&gt;
        &lt;child&gt;
          &lt;object class="GtkBox" id="hbox"&gt;
            &lt;child&gt;
              &lt;object class="GtkRevealer" id="sidebar"&gt;
                &lt;property name="transition-type"&gt;slide-right&lt;/property&gt;
                &lt;child&gt;
                 &lt;object class="GtkScrolledWindow" id="sidebar-sw"&gt;
                   &lt;property name="hscrollbar-policy"&gt;never&lt;/property&gt;
                   &lt;child&gt;
                     &lt;object class="GtkListBox" id="words"&gt;
                       &lt;property name="selection-mode"&gt;none&lt;/property&gt;
                     &lt;/object&gt;
                   &lt;/child&gt;
                 &lt;/object&gt;
                &lt;/child&gt;
              &lt;/object&gt;
            &lt;/child&gt;
            &lt;child&gt;
              &lt;object class="GtkStack" id="stack"&gt;
                &lt;property name="transition-duration"&gt;500&lt;/property&gt;
              &lt;/object&gt;
            &lt;/child&gt;
          &lt;/object&gt;
        &lt;/child&gt;
      &lt;/object&gt;
    &lt;/child&gt;
  &lt;/object&gt;
&lt;/interface&gt;
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">org.gtkmm.exampleapp.gschema.xml</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;schemalist&gt;
  &lt;schema path="/org/gtkmm/exampleapp/" id="org.gtkmm.exampleapp"&gt;
    &lt;key name="font" type="s"&gt;
      &lt;default&gt;'Monospace 12'&lt;/default&gt;
      &lt;summary&gt;Font&lt;/summary&gt;
      &lt;description&gt;The font to be used for content.&lt;/description&gt;
    &lt;/key&gt;
    &lt;key name="transition" type="s"&gt;
      &lt;choices&gt;
        &lt;choice value='none'/&gt;
        &lt;choice value='crossfade'/&gt;
        &lt;choice value='slide-left-right'/&gt;
      &lt;/choices&gt;
      &lt;default&gt;'none'&lt;/default&gt;
      &lt;summary&gt;Transition&lt;/summary&gt;
      &lt;description&gt;The transition to use when switching tabs.&lt;/description&gt;
    &lt;/key&gt;
    &lt;key name="show-words" type="b"&gt;
      &lt;default&gt;false&lt;/default&gt;
      &lt;summary&gt;Show words&lt;/summary&gt;
      &lt;description&gt;Whether to show a word list in the sidebar.&lt;/description&gt;
    &lt;/key&gt;
  &lt;/schema&gt;
&lt;/schemalist&gt;
</pre></div>
</div>
<div class="division sect1">
<a name="sec-buildapp-properties"><!--sec-buildapp-properties--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">29.8. </span>Properties</span></h3></div>
<p class="para block block-first">
Widgets and other objects have many useful properties. Here we show some ways to use
them in new and flexible ways, by wrapping them in actions with <span class="classname" dir="ltr">Gio::PropertyAction</span>
or by binding them with <span class="classname" dir="ltr">Glib::Binding</span>.
</p>
<p class="para block">
To set this up, we add two labels to the header bar in our <span class="filename" dir="ltr">window.ui</span> file,
named <span class="literal" dir="ltr">lines_label</span> and <span class="literal" dir="ltr">lines</span>, and get pointers to them
in the application window's constructor, as we've seen a couple of times by now.
We add a new "Lines" menu item to the gears menu, which triggers the
<span class="literal" dir="ltr">show-lines</span> action.
</p>
<p class="para block">
To make this menu item do something, we create a property action for the <span class="literal" dir="ltr">visible</span>
property of the <span class="literal" dir="ltr">lines</span> label, and add it to the actions of the window.
The effect of this is that the visibility of the label gets toggled every time the action
is activated.
Since we want both labels to appear and disappear together, we bind the <span class="literal" dir="ltr">visible</span>
property of the <span class="literal" dir="ltr">lines_label</span> widget to the same property of the
<span class="literal" dir="ltr">lines</span> widget.
In <span class="classname" dir="ltr">ExampleAppWindow</span>'s constructor:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">add_action(Gio::PropertyAction::create("show-lines", m_lines-&gt;property_visible()));
m_binding_lines_visible = Glib::Binding::bind_property(m_lines-&gt;property_visible(),
  m_lines_label-&gt;property_visible());

</pre></div>
<p class="para block">
We also need a function that counts the lines of the currently active tab, and updates
the <span class="literal" dir="ltr">lines</span> label. See the full source if you are interested in the details.
</p>
<p class="para block">
This brings our example application to this appearance:
</p>
<div class=" block figure block-indent">
<a name="figure-buildapp-properties"><!--figure-buildapp-properties--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 29-8</span> </span>Properties</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/buildapp_properties.png.en"></div>
  </div>
</div>
</div>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/buildapp/step8" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/buildapp/step8">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">exampleapplication.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "../step4/exampleapplication.h"
// Equal to the corresponding file in step4
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">exampleappprefs.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "../step5/exampleappprefs.h"
// Equal to the corresponding file in step5
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">exampleappwindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLEAPPWINDOW_H_
#define GTKMM_EXAMPLEAPPWINDOW_H_

#include &lt;gtkmm.h&gt;

class ExampleAppWindow : public Gtk::ApplicationWindow
{
public:
  ExampleAppWindow(BaseObjectType* cobject,
    const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; refBuilder);

  static ExampleAppWindow* create();

  void open_file_view(const Glib::RefPtr&lt;Gio::File&gt;&amp; file);

protected:
  // Signal handlers
  void on_search_text_changed();
  void on_visible_child_changed();
  void on_find_word(const Gtk::Button* button);
  void on_reveal_child_changed();

  void update_words();
  void update_lines();

  Glib::RefPtr&lt;Gtk::Builder&gt; m_refBuilder;
  Glib::RefPtr&lt;Gio::Settings&gt; m_settings;
  Gtk::Stack* m_stack;
  Gtk::ToggleButton* m_search;
  Gtk::SearchBar* m_searchbar;
  Gtk::SearchEntry* m_searchentry;
  Gtk::MenuButton* m_gears;
  Gtk::Revealer* m_sidebar;
  Gtk::ListBox* m_words;
  Gtk::Label* m_lines;
  Gtk::Label* m_lines_label;
  Glib::RefPtr&lt;Glib::Binding&gt; m_binding_search_enabled;
  Glib::RefPtr&lt;Glib::Binding&gt; m_binding_lines_visible;
};

#endif /* GTKMM_EXAMPLEAPPWINDOW_H */
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "../step5/main.cc"
// Equal to the corresponding file in step5
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">exampleappwindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "exampleappwindow.h"
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;set&gt;

ExampleAppWindow::ExampleAppWindow(BaseObjectType* cobject,
  const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; refBuilder)
: Gtk::ApplicationWindow(cobject),
  m_refBuilder(refBuilder),
  m_settings(),
  m_stack(nullptr),
  m_search(nullptr),
  m_searchbar(nullptr),
  m_searchentry(nullptr),
  m_gears(nullptr),
  m_sidebar(nullptr),
  m_words(nullptr),
  m_lines(nullptr),
  m_lines_label(nullptr),
  m_binding_search_enabled(),
  m_binding_lines_visible()
{
  // Get widgets from the Gtk::Builder file.
  m_stack = m_refBuilder-&gt;get_widget&lt;Gtk::Stack&gt;("stack");
  if (!m_stack)
    throw std::runtime_error("No \"stack\" object in window.ui");

  m_search = m_refBuilder-&gt;get_widget&lt;Gtk::ToggleButton&gt;("search");
  if (!m_search)
    throw std::runtime_error("No \"search\" object in window.ui");

  m_searchbar = m_refBuilder-&gt;get_widget&lt;Gtk::SearchBar&gt;("searchbar");
  if (!m_searchbar)
    throw std::runtime_error("No \"searchbar\" object in window.ui");

  m_searchentry = m_refBuilder-&gt;get_widget&lt;Gtk::SearchEntry&gt;("searchentry");
  if (!m_searchentry)
    throw std::runtime_error("No \"searchentry\" object in window.ui");

  m_gears = m_refBuilder-&gt;get_widget&lt;Gtk::MenuButton&gt;("gears");
  if (!m_gears)
    throw std::runtime_error("No \"gears\" object in window.ui");

  m_sidebar = m_refBuilder-&gt;get_widget&lt;Gtk::Revealer&gt;("sidebar");
  if (!m_sidebar)
    throw std::runtime_error("No \"sidebar\" object in window.ui");

  m_words = m_refBuilder-&gt;get_widget&lt;Gtk::ListBox&gt;("words");
  if (!m_words)
    throw std::runtime_error("No \"words\" object in window.ui");

  m_lines = m_refBuilder-&gt;get_widget&lt;Gtk::Label&gt;("lines");
  if (!m_lines)
    throw std::runtime_error("No \"lines\" object in window.ui");

  m_lines_label = m_refBuilder-&gt;get_widget&lt;Gtk::Label&gt;("lines_label");
  if (!m_lines_label)
    throw std::runtime_error("No \"lines_label\" object in window.ui");

  // Bind settings.
  m_settings = Gio::Settings::create("org.gtkmm.exampleapp");
  m_settings-&gt;bind("transition", m_stack-&gt;property_transition_type());
  m_settings-&gt;bind("show-words", m_sidebar-&gt;property_reveal_child());

  // Bind properties of the search button to the search bar.
  m_binding_search_enabled = Glib::Binding::bind_property(m_search-&gt;property_active(),
    m_searchbar-&gt;property_search_mode_enabled(), Glib::Binding::Flags::BIDIRECTIONAL);

  // Connect signal handlers.
  m_searchentry-&gt;signal_search_changed().connect(
    sigc::mem_fun(*this, &amp;ExampleAppWindow::on_search_text_changed));
  m_stack-&gt;property_visible_child().signal_changed().connect(
    sigc::mem_fun(*this, &amp;ExampleAppWindow::on_visible_child_changed));
  m_sidebar-&gt;property_reveal_child().signal_changed().connect(
    sigc::mem_fun(*this, &amp;ExampleAppWindow::on_reveal_child_changed));

  // Connect the menu to the MenuButton m_gears, and bind the show-words setting
  // to the win.show-words action and the "Words" menu item.
  // (The connection between action and menu item is specified in gears_menu.ui.)
  auto menu_builder = Gtk::Builder::create_from_resource("/org/gtkmm/exampleapp/gears_menu.ui");
  auto menu = menu_builder-&gt;get_object&lt;Gio::MenuModel&gt;("menu");
  if (!menu)
    throw std::runtime_error("No \"menu\" object in gears_menu.ui");

  m_gears-&gt;set_menu_model(menu);
  add_action(m_settings-&gt;create_action("show-words"));

  // Bind the "visible" property of m_lines to the win.show-lines action, to
  // the "Lines" menu item and to the "visible" property of m_lines_label.
  add_action(Gio::PropertyAction::create("show-lines", m_lines-&gt;property_visible()));
  m_binding_lines_visible = Glib::Binding::bind_property(m_lines-&gt;property_visible(),
    m_lines_label-&gt;property_visible());
}

//static
ExampleAppWindow* ExampleAppWindow::create()
{
  // Load the Builder file and instantiate its widgets.
  auto refBuilder = Gtk::Builder::create_from_resource("/org/gtkmm/exampleapp/window.ui");

  auto window = Gtk::Builder::get_widget_derived&lt;ExampleAppWindow&gt;(refBuilder, "app_window");
  if (!window)
    throw std::runtime_error("No \"app_window\" object in window.ui");

  return window;
}

void ExampleAppWindow::open_file_view(const Glib::RefPtr&lt;Gio::File&gt;&amp; file)
{
  const Glib::ustring basename = file-&gt;get_basename();

  auto scrolled = Gtk::make_managed&lt;Gtk::ScrolledWindow&gt;();
  scrolled-&gt;set_expand(true);
  auto view = Gtk::make_managed&lt;Gtk::TextView&gt;();
  view-&gt;set_editable(false);
  view-&gt;set_cursor_visible(false);
  scrolled-&gt;set_child(*view);
  m_stack-&gt;add(*scrolled, basename, basename);

  auto buffer = view-&gt;get_buffer();
  try
  {
    char* contents = nullptr;
    gsize length = 0;
    
    file-&gt;load_contents(contents, length);
    buffer-&gt;set_text(contents, contents+length);
    g_free(contents);
  }
  catch (const Glib::Error&amp; ex)
  {
    std::cout &lt;&lt; "ExampleAppWindow::open_file_view(\"" &lt;&lt; file-&gt;get_parse_name()
      &lt;&lt; "\"):\n  " &lt;&lt; ex.what() &lt;&lt; std::endl;
    return;
  }

  auto tag = buffer-&gt;create_tag();
  m_settings-&gt;bind("font", tag-&gt;property_font());
  buffer-&gt;apply_tag(tag, buffer-&gt;begin(), buffer-&gt;end());

  m_search-&gt;set_sensitive(true);
  update_words();
  update_lines();
}

void ExampleAppWindow::on_search_text_changed()
{
  const auto text = m_searchentry-&gt;get_text();
  if (text.empty())
    return;

  auto tab = dynamic_cast&lt;Gtk::ScrolledWindow*&gt;(m_stack-&gt;get_visible_child());
  if (!tab)
  {
    std::cout &lt;&lt; "ExampleAppWindow::on_search_text_changed(): No visible child." &lt;&lt; std::endl;
    return;
  }

  auto view = dynamic_cast&lt;Gtk::TextView*&gt;(tab-&gt;get_child());
  if (!view)
  {
    std::cout &lt;&lt; "ExampleAppWindow::on_search_text_changed(): No visible text view." &lt;&lt; std::endl;
    return;
  }

  // Very simple-minded search implementation.
  auto buffer = view-&gt;get_buffer();
  Gtk::TextIter match_start;
  Gtk::TextIter match_end;
  if (buffer-&gt;begin().forward_search(text, Gtk::TextSearchFlags::CASE_INSENSITIVE,
      match_start, match_end))
  {
    buffer-&gt;select_range(match_start, match_end);
    view-&gt;scroll_to(match_start);
  }
}

void ExampleAppWindow::on_visible_child_changed()
{
  m_searchbar-&gt;set_search_mode(false);
  update_words();
  update_lines();  
}

void ExampleAppWindow::on_find_word(const Gtk::Button* button)
{
  m_searchentry-&gt;set_text(button-&gt;get_label());
}

void ExampleAppWindow::on_reveal_child_changed()
{
  update_words();
}

void ExampleAppWindow::update_words()
{
  auto tab = dynamic_cast&lt;Gtk::ScrolledWindow*&gt;(m_stack-&gt;get_visible_child());
  if (!tab)
    return;

  auto view = dynamic_cast&lt;Gtk::TextView*&gt;(tab-&gt;get_child());
  if (!view)
  {
    std::cout &lt;&lt; "ExampleAppWindow::update_words(): No visible text view." &lt;&lt; std::endl;
    return;
  }
  auto buffer = view-&gt;get_buffer();

  // Find all words in the text buffer.
  std::set&lt;Glib::ustring&gt; words;
  auto start = buffer-&gt;begin();
  Gtk::TextIter end;
  while (start)
  {
    while (start &amp;&amp; !start.starts_word())
      ++start;

    if (!start)
      break;

    end = start;
    end.forward_word_end();
    if (start == end)
      break;

    auto word = buffer-&gt;get_text(start, end, false);
    words.insert(word.lowercase());
    start = end;
  }

  // Remove old children from the ListBox.
  while (auto child = m_words-&gt;get_first_child())
    m_words-&gt;remove(*child);

  // Add new child buttons, one per unique word.
  for (const auto&amp; word : words)
  {
    auto row = Gtk::make_managed&lt;Gtk::Button&gt;(word);
    row-&gt;signal_clicked().connect(sigc::bind(sigc::mem_fun(*this,
      &amp;ExampleAppWindow::on_find_word), row));
    m_words-&gt;append(*row);
  }
}

void ExampleAppWindow::update_lines()
{
  auto tab = dynamic_cast&lt;Gtk::ScrolledWindow*&gt;(m_stack-&gt;get_visible_child());
  if (!tab)
    return;

  auto view = dynamic_cast&lt;Gtk::TextView*&gt;(tab-&gt;get_child());
  if (!view)
  {
    std::cout &lt;&lt; "ExampleAppWindow::update_lines(): No visible text view." &lt;&lt; std::endl;
    return;
  }
  auto buffer = view-&gt;get_buffer();

  int count = 0;
  auto iter = buffer-&gt;begin();
  while (iter)
  {
    ++count;
    if (!iter.forward_line())
      break;
  }
  m_lines-&gt;set_text(Glib::ustring::format(count));
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">exampleappprefs.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "../step5/exampleappprefs.cc"
// Equal to the corresponding file in step5
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">exampleapplication.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "../step5/exampleapplication.cc"
// Equal to the corresponding file in step5
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">gears_menu.ui</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;interface&gt;
  &lt;menu id="menu"&gt;
    &lt;section&gt;
      &lt;item&gt;
        &lt;attribute name="label" translatable="yes"&gt;_Words&lt;/attribute&gt;
        &lt;attribute name="action"&gt;win.show-words&lt;/attribute&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;attribute name="label" translatable="yes"&gt;_Lines&lt;/attribute&gt;
        &lt;attribute name="action"&gt;win.show-lines&lt;/attribute&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;attribute name="label" translatable="yes"&gt;_Preferences&lt;/attribute&gt;
        &lt;attribute name="action"&gt;app.preferences&lt;/attribute&gt;
      &lt;/item&gt;
    &lt;/section&gt;
    &lt;section&gt;
      &lt;item&gt;
        &lt;attribute name="label" translatable="yes"&gt;_Quit&lt;/attribute&gt;
        &lt;attribute name="action"&gt;app.quit&lt;/attribute&gt;
      &lt;/item&gt;
    &lt;/section&gt;
  &lt;/menu&gt;
&lt;/interface&gt;
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">window.ui</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;interface&gt;
  &lt;object class="GtkApplicationWindow" id="app_window"&gt;
    &lt;property name="title" translatable="yes"&gt;Example Application&lt;/property&gt;
    &lt;property name="default-width"&gt;600&lt;/property&gt;
    &lt;property name="default-height"&gt;400&lt;/property&gt;
    &lt;property name="hide-on-close"&gt;True&lt;/property&gt;
    &lt;child type="titlebar"&gt;
      &lt;object class="GtkHeaderBar" id="header"&gt;
        &lt;child&gt;
          &lt;object class="GtkLabel" id="lines_label"&gt;
            &lt;property name="visible"&gt;False&lt;/property&gt;
            &lt;property name="label" translatable="yes"&gt;Lines:&lt;/property&gt;
          &lt;/object&gt;
        &lt;/child&gt;
        &lt;child&gt;
          &lt;object class="GtkLabel" id="lines"&gt;
            &lt;property name="visible"&gt;False&lt;/property&gt;
          &lt;/object&gt;
        &lt;/child&gt;
        &lt;child type="title"&gt;
          &lt;object class="GtkStackSwitcher" id="tabs"&gt;
            &lt;property name="stack"&gt;stack&lt;/property&gt;
          &lt;/object&gt;
        &lt;/child&gt;
        &lt;child type="end"&gt;
          &lt;object class="GtkToggleButton" id="search"&gt;
            &lt;property name="sensitive"&gt;False&lt;/property&gt;
            &lt;property name="icon-name"&gt;edit-find-symbolic&lt;/property&gt;
          &lt;/object&gt;
        &lt;/child&gt;
        &lt;child type="end"&gt;
          &lt;object class="GtkMenuButton" id="gears"&gt;
            &lt;property name="direction"&gt;none&lt;/property&gt;
          &lt;/object&gt;
        &lt;/child&gt;
      &lt;/object&gt;
    &lt;/child&gt;
    &lt;child&gt;
      &lt;object class="GtkBox" id="content_box"&gt;
        &lt;property name="orientation"&gt;vertical&lt;/property&gt;
        &lt;child&gt;
          &lt;object class="GtkSearchBar" id="searchbar"&gt;
            &lt;child&gt;
              &lt;object class="GtkSearchEntry" id="searchentry"&gt;
              &lt;/object&gt;
            &lt;/child&gt;
          &lt;/object&gt;
        &lt;/child&gt;
        &lt;child&gt;
          &lt;object class="GtkBox" id="hbox"&gt;
            &lt;child&gt;
              &lt;object class="GtkRevealer" id="sidebar"&gt;
                &lt;property name="transition-type"&gt;slide-right&lt;/property&gt;
                &lt;child&gt;
                  &lt;object class="GtkScrolledWindow" id="sidebar-sw"&gt;
                    &lt;property name="hscrollbar-policy"&gt;never&lt;/property&gt;
                    &lt;child&gt;
                      &lt;object class="GtkListBox" id="words"&gt;
                        &lt;property name="selection-mode"&gt;none&lt;/property&gt;
                      &lt;/object&gt;
                    &lt;/child&gt;
                  &lt;/object&gt;
                &lt;/child&gt;
              &lt;/object&gt;
            &lt;/child&gt;
            &lt;child&gt;
              &lt;object class="GtkStack" id="stack"&gt;
                &lt;property name="transition-duration"&gt;500&lt;/property&gt;
              &lt;/object&gt;
            &lt;/child&gt;
          &lt;/object&gt;
        &lt;/child&gt;
      &lt;/object&gt;
    &lt;/child&gt;
  &lt;/object&gt;
&lt;/interface&gt;
</pre></div>
</div>
<div class="division sect1">
<a name="sec-buildapp-header-bar"><!--sec-buildapp-header-bar--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">29.9. </span>Header bar</span></h3></div>
<p class="para block block-first">
Our application already uses a <span class="classname" dir="ltr">Gtk::HeaderBar</span> instead of
a 'normal' window titlebar. The header bar is a direct child of the window,
and its type is <span class="literal" dir="ltr">titlebar</span>. This is set in the
<span class="filename" dir="ltr">window.ui</span> file.
</p>
<p class="para block">
Here we'll just make two small changes to the header bar. The <span class="literal" dir="ltr">decoration-layout</span>
property is set in the <span class="filename" dir="ltr">window.ui</span> file, to show only the close
button, and hide the minimize and maximize buttons. We also include an icon in the
resource file, and set up this icon as the window icon.
In <span class="classname" dir="ltr">ExampleAppWindow</span>'s constructor:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">Gtk::IconTheme::get_for_display(get_display())-&gt;add_resource_path("/org/gtkmm/exampleapp");
set_icon_name("exampleapp");

</pre></div>
<p class="para block">
Here is how the application now looks:
</p>
<div class=" block figure block-indent">
<a name="figure-buildapp-header-bar"><!--figure-buildapp-header-bar--></a><div class="block block-first title title-formal"><span class="title"><span class="label"><span style="font-style: italic; ">Figure 29-9</span> </span>Header bar</span></div>
<div class="figure-inner">
  
  <div class=" block screenshot block-first">
    <div class="graphic"><img src="figures/buildapp_header_bar.png.en"></div>
  </div>
</div>
</div>
<p class="para block">
The <span class="filename" dir="ltr">window.ui</span> file sets a header bar title, but this title is not shown.
That's because the stack switcher is a child of type <span class="literal" dir="ltr">title</span>. The stack
switcher becomes a custom title that hides the title label.
</p>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/buildapp/step9" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/buildapp/step9">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">exampleapplication.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "../step4/exampleapplication.h"
// Equal to the corresponding file in step4
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">exampleappprefs.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "../step5/exampleappprefs.h"
// Equal to the corresponding file in step5
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">exampleappwindow.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "../step8/exampleappwindow.h"
// Equal to the corresponding file in step8
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "../step5/main.cc"
// Equal to the corresponding file in step5
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">exampleappwindow.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "exampleappwindow.h"
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;set&gt;

ExampleAppWindow::ExampleAppWindow(BaseObjectType* cobject,
  const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; refBuilder)
: Gtk::ApplicationWindow(cobject),
  m_refBuilder(refBuilder),
  m_settings(),
  m_stack(nullptr),
  m_search(nullptr),
  m_searchbar(nullptr),
  m_searchentry(nullptr),
  m_gears(nullptr),
  m_sidebar(nullptr),
  m_words(nullptr),
  m_lines(nullptr),
  m_lines_label(nullptr),
  m_binding_search_enabled(),
  m_binding_lines_visible()
{
  // Get widgets from the Gtk::Builder file.
  m_stack = m_refBuilder-&gt;get_widget&lt;Gtk::Stack&gt;("stack");
  if (!m_stack)
    throw std::runtime_error("No \"stack\" object in window.ui");

  m_search = m_refBuilder-&gt;get_widget&lt;Gtk::ToggleButton&gt;("search");
  if (!m_search)
    throw std::runtime_error("No \"search\" object in window.ui");

  m_searchbar = m_refBuilder-&gt;get_widget&lt;Gtk::SearchBar&gt;("searchbar");
  if (!m_searchbar)
    throw std::runtime_error("No \"searchbar\" object in window.ui");

  m_searchentry = m_refBuilder-&gt;get_widget&lt;Gtk::SearchEntry&gt;("searchentry");
  if (!m_searchentry)
    throw std::runtime_error("No \"searchentry\" object in window.ui");

  m_gears = m_refBuilder-&gt;get_widget&lt;Gtk::MenuButton&gt;("gears");
  if (!m_gears)
    throw std::runtime_error("No \"gears\" object in window.ui");

  m_sidebar = m_refBuilder-&gt;get_widget&lt;Gtk::Revealer&gt;("sidebar");
  if (!m_sidebar)
    throw std::runtime_error("No \"sidebar\" object in window.ui");

  m_words = m_refBuilder-&gt;get_widget&lt;Gtk::ListBox&gt;("words");
  if (!m_words)
    throw std::runtime_error("No \"words\" object in window.ui");

  m_lines = m_refBuilder-&gt;get_widget&lt;Gtk::Label&gt;("lines");
  if (!m_lines)
    throw std::runtime_error("No \"lines\" object in window.ui");

  m_lines_label = m_refBuilder-&gt;get_widget&lt;Gtk::Label&gt;("lines_label");
  if (!m_lines_label)
    throw std::runtime_error("No \"lines_label\" object in window.ui");

  // Bind settings.
  m_settings = Gio::Settings::create("org.gtkmm.exampleapp");
  m_settings-&gt;bind("transition", m_stack-&gt;property_transition_type());
  m_settings-&gt;bind("show-words", m_sidebar-&gt;property_reveal_child());

  // Bind properties of the search button to the search bar.
  m_binding_search_enabled = Glib::Binding::bind_property(m_search-&gt;property_active(),
    m_searchbar-&gt;property_search_mode_enabled(), Glib::Binding::Flags::BIDIRECTIONAL);

  // Connect signal handlers.
  m_searchentry-&gt;signal_search_changed().connect(
    sigc::mem_fun(*this, &amp;ExampleAppWindow::on_search_text_changed));
  m_stack-&gt;property_visible_child().signal_changed().connect(
    sigc::mem_fun(*this, &amp;ExampleAppWindow::on_visible_child_changed));
  m_sidebar-&gt;property_reveal_child().signal_changed().connect(
    sigc::mem_fun(*this, &amp;ExampleAppWindow::on_reveal_child_changed));

  // Connect the menu to the MenuButton m_gears, and bind the show-words setting
  // to the win.show-words action and the "Words" menu item.
  // (The connection between action and menu item is specified in gears_menu.ui.)
  auto menu_builder = Gtk::Builder::create_from_resource("/org/gtkmm/exampleapp/gears_menu.ui");
  auto menu = menu_builder-&gt;get_object&lt;Gio::MenuModel&gt;("menu");
  if (!menu)
    throw std::runtime_error("No \"menu\" object in gears_menu.ui");

  m_gears-&gt;set_menu_model(menu);
  add_action(m_settings-&gt;create_action("show-words"));

  // Bind the "visible" property of m_lines to the win.show-lines action, to
  // the "Lines" menu item and to the "visible" property of m_lines_label.
  add_action(Gio::PropertyAction::create("show-lines", m_lines-&gt;property_visible()));
  m_binding_lines_visible = Glib::Binding::bind_property(m_lines-&gt;property_visible(),
    m_lines_label-&gt;property_visible());

  // Set the window icon.
  Gtk::IconTheme::get_for_display(get_display())-&gt;add_resource_path("/org/gtkmm/exampleapp");
  set_icon_name("exampleapp");
}

//static
ExampleAppWindow* ExampleAppWindow::create()
{
  // Load the Builder file and instantiate its widgets.
  auto refBuilder = Gtk::Builder::create_from_resource("/org/gtkmm/exampleapp/window.ui");

  auto window = Gtk::Builder::get_widget_derived&lt;ExampleAppWindow&gt;(refBuilder, "app_window");
  if (!window)
    throw std::runtime_error("No \"app_window\" object in window.ui");

  return window;
}

void ExampleAppWindow::open_file_view(const Glib::RefPtr&lt;Gio::File&gt;&amp; file)
{
  const Glib::ustring basename = file-&gt;get_basename();

  auto scrolled = Gtk::make_managed&lt;Gtk::ScrolledWindow&gt;();
  scrolled-&gt;set_expand(true);
  auto view = Gtk::make_managed&lt;Gtk::TextView&gt;();
  view-&gt;set_editable(false);
  view-&gt;set_cursor_visible(false);
  scrolled-&gt;set_child(*view);
  m_stack-&gt;add(*scrolled, basename, basename);

  auto buffer = view-&gt;get_buffer();
  try
  {
    char* contents = nullptr;
    gsize length = 0;
    
    file-&gt;load_contents(contents, length);
    buffer-&gt;set_text(contents, contents+length);
    g_free(contents);
  }
  catch (const Glib::Error&amp; ex)
  {
    std::cout &lt;&lt; "ExampleAppWindow::open_file_view(\"" &lt;&lt; file-&gt;get_parse_name()
      &lt;&lt; "\"):\n  " &lt;&lt; ex.what() &lt;&lt; std::endl;
    return;
  }

  auto tag = buffer-&gt;create_tag();
  m_settings-&gt;bind("font", tag-&gt;property_font());
  buffer-&gt;apply_tag(tag, buffer-&gt;begin(), buffer-&gt;end());

  m_search-&gt;set_sensitive(true);
  update_words();
  update_lines();
}

void ExampleAppWindow::on_search_text_changed()
{
  const auto text = m_searchentry-&gt;get_text();
  if (text.empty())
    return;

  auto tab = dynamic_cast&lt;Gtk::ScrolledWindow*&gt;(m_stack-&gt;get_visible_child());
  if (!tab)
  {
    std::cout &lt;&lt; "ExampleAppWindow::on_search_text_changed(): No visible child." &lt;&lt; std::endl;
    return;
  }

  auto view = dynamic_cast&lt;Gtk::TextView*&gt;(tab-&gt;get_child());
  if (!view)
  {
    std::cout &lt;&lt; "ExampleAppWindow::on_search_text_changed(): No visible text view." &lt;&lt; std::endl;
    return;
  }

  // Very simple-minded search implementation.
  auto buffer = view-&gt;get_buffer();
  Gtk::TextIter match_start;
  Gtk::TextIter match_end;
  if (buffer-&gt;begin().forward_search(text, Gtk::TextSearchFlags::CASE_INSENSITIVE,
      match_start, match_end))
  {
    buffer-&gt;select_range(match_start, match_end);
    view-&gt;scroll_to(match_start);
  }
}

void ExampleAppWindow::on_visible_child_changed()
{
  m_searchbar-&gt;set_search_mode(false);
  update_words();
  update_lines();  
}

void ExampleAppWindow::on_find_word(const Gtk::Button* button)
{
  m_searchentry-&gt;set_text(button-&gt;get_label());
}

void ExampleAppWindow::on_reveal_child_changed()
{
  update_words();
}

void ExampleAppWindow::update_words()
{
  auto tab = dynamic_cast&lt;Gtk::ScrolledWindow*&gt;(m_stack-&gt;get_visible_child());
  if (!tab)
    return;

  auto view = dynamic_cast&lt;Gtk::TextView*&gt;(tab-&gt;get_child());
  if (!view)
  {
    std::cout &lt;&lt; "ExampleAppWindow::update_words(): No visible text view." &lt;&lt; std::endl;
    return;
  }
  auto buffer = view-&gt;get_buffer();

  // Find all words in the text buffer.
  std::set&lt;Glib::ustring&gt; words;
  auto start = buffer-&gt;begin();
  Gtk::TextIter end;
  while (start)
  {
    while (start &amp;&amp; !start.starts_word())
      ++start;

    if (!start)
      break;

    end = start;
    end.forward_word_end();
    if (start == end)
      break;

    auto word = buffer-&gt;get_text(start, end, false);
    words.insert(word.lowercase());
    start = end;
  }

  // Remove old children from the ListBox.
  while (auto child = m_words-&gt;get_first_child())
    m_words-&gt;remove(*child);

  // Add new child buttons, one per unique word.
  for (const auto&amp; word : words)
  {
    auto row = Gtk::make_managed&lt;Gtk::Button&gt;(word);
    row-&gt;signal_clicked().connect(sigc::bind(sigc::mem_fun(*this,
      &amp;ExampleAppWindow::on_find_word), row));
    m_words-&gt;append(*row);
  }
}

void ExampleAppWindow::update_lines()
{
  auto tab = dynamic_cast&lt;Gtk::ScrolledWindow*&gt;(m_stack-&gt;get_visible_child());
  if (!tab)
    return;

  auto view = dynamic_cast&lt;Gtk::TextView*&gt;(tab-&gt;get_child());
  if (!view)
  {
    std::cout &lt;&lt; "ExampleAppWindow::update_lines(): No visible text view." &lt;&lt; std::endl;
    return;
  }
  auto buffer = view-&gt;get_buffer();

  int count = 0;
  auto iter = buffer-&gt;begin();
  while (iter)
  {
    ++count;
    if (!iter.forward_line())
      break;
  }
  m_lines-&gt;set_text(Glib::ustring::format(count));
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">exampleappprefs.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "../step5/exampleappprefs.cc"
// Equal to the corresponding file in step5
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">exampleapplication.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "../step5/exampleapplication.cc"
// Equal to the corresponding file in step5
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">exampleapp.gresource.xml</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;gresources&gt;
  &lt;gresource prefix="/org/gtkmm/exampleapp"&gt;
    &lt;file preprocess="xml-stripblanks"&gt;window.ui&lt;/file&gt;
    &lt;file preprocess="xml-stripblanks"&gt;gears_menu.ui&lt;/file&gt;
    &lt;file preprocess="xml-stripblanks"&gt;prefs.ui&lt;/file&gt;
    &lt;file&gt;exampleapp.png&lt;/file&gt;
  &lt;/gresource&gt;
&lt;/gresources&gt;
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">window.ui</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;interface&gt;
  &lt;object class="GtkApplicationWindow" id="app_window"&gt;
    &lt;property name="title" translatable="yes"&gt;Example Application&lt;/property&gt;
    &lt;property name="default-width"&gt;600&lt;/property&gt;
    &lt;property name="default-height"&gt;400&lt;/property&gt;
    &lt;property name="hide-on-close"&gt;True&lt;/property&gt;
    &lt;child type="titlebar"&gt;
      &lt;object class="GtkHeaderBar" id="header"&gt;
        &lt;property name="decoration-layout"&gt;icon:close&lt;/property&gt;
        &lt;child&gt;
          &lt;object class="GtkLabel" id="lines_label"&gt;
            &lt;property name="visible"&gt;False&lt;/property&gt;
            &lt;property name="label" translatable="yes"&gt;Lines:&lt;/property&gt;
          &lt;/object&gt;
        &lt;/child&gt;
        &lt;child&gt;
          &lt;object class="GtkLabel" id="lines"&gt;
            &lt;property name="visible"&gt;False&lt;/property&gt;
          &lt;/object&gt;
        &lt;/child&gt;
        &lt;child type="title"&gt;
          &lt;object class="GtkStackSwitcher" id="tabs"&gt;
            &lt;property name="stack"&gt;stack&lt;/property&gt;
          &lt;/object&gt;
        &lt;/child&gt;
        &lt;child type="end"&gt;
          &lt;object class="GtkToggleButton" id="search"&gt;
            &lt;property name="sensitive"&gt;False&lt;/property&gt;
            &lt;property name="icon-name"&gt;edit-find-symbolic&lt;/property&gt;
          &lt;/object&gt;
        &lt;/child&gt;
        &lt;child type="end"&gt;
          &lt;object class="GtkMenuButton" id="gears"&gt;
            &lt;property name="direction"&gt;none&lt;/property&gt;
          &lt;/object&gt;
        &lt;/child&gt;
      &lt;/object&gt;
    &lt;/child&gt;
    &lt;child&gt;
      &lt;object class="GtkBox" id="content_box"&gt;
        &lt;property name="orientation"&gt;vertical&lt;/property&gt;
        &lt;child&gt;
          &lt;object class="GtkSearchBar" id="searchbar"&gt;
            &lt;child&gt;
              &lt;object class="GtkSearchEntry" id="searchentry"&gt;
              &lt;/object&gt;
            &lt;/child&gt;
          &lt;/object&gt;
        &lt;/child&gt;
        &lt;child&gt;
          &lt;object class="GtkBox" id="hbox"&gt;
            &lt;child&gt;
              &lt;object class="GtkRevealer" id="sidebar"&gt;
                &lt;property name="transition-type"&gt;slide-right&lt;/property&gt;
                &lt;child&gt;
                  &lt;object class="GtkScrolledWindow" id="sidebar-sw"&gt;
                    &lt;property name="hscrollbar-policy"&gt;never&lt;/property&gt;
                    &lt;child&gt;
                      &lt;object class="GtkListBox" id="words"&gt;
                        &lt;property name="selection-mode"&gt;none&lt;/property&gt;
                      &lt;/object&gt;
                    &lt;/child&gt;
                  &lt;/object&gt;
                &lt;/child&gt;
              &lt;/object&gt;
            &lt;/child&gt;
            &lt;child&gt;
              &lt;object class="GtkStack" id="stack"&gt;
                &lt;property name="transition-duration"&gt;500&lt;/property&gt;
              &lt;/object&gt;
            &lt;/child&gt;
          &lt;/object&gt;
        &lt;/child&gt;
      &lt;/object&gt;
    &lt;/child&gt;
  &lt;/object&gt;
&lt;/interface&gt;
</pre></div>
</div>
</div>
<div class="division chapter">
<a name="chapter-contributing"><!--chapter-contributing--></a><div class="header"><h2 class="chapter title"><span class="title"><span class="label">30. </span>Contributing</span></h2></div>
<p class="para block block-first">
This document, like so much other great software out there, was
created for free by volunteers. If you are at all knowledgeable about
any aspect of <span class="application">gtkmm</span> that does not already have documentation, please
consider contributing to this document.
</p>
<p class="para block">
Ideally, we would like you to <a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/-/merge_requests" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/-/merge_requests">
provide a merge request</a> to the <span class="filename" dir="ltr">docs/tutorial/C/index-in.docbook</span> file.
This file is in the <span class="literal" dir="ltr">gtkmm-documentation</span> module in GNOME git.
</p>
<p class="para block">
If you do decide to contribute, please post your contribution to the
<span class="application">gtkmm</span> mailing list at <a class="ulink" href="mailto:gtkmm-list@gnome.org" title="Send email to ‘gtkmm-list@gnome.org’.">&lt;gtkmm-list@gnome.org&gt;</a>
or as an issue or merge request to <a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation">GitLab</a>.
Also, be aware that the entirety of this document is free, and any addition you provide
must also be free. That is, people must be able to use any portion of
your examples in their programs, and copies of this document
(including your contribution) may be distributed freely.
</p>
</div>
<div class="division appendix">
<a name="chapter-refptr"><!--chapter-refptr--></a><div class="header"><h2 class="appendix title"><span class="title"><span class="label">A. </span>The RefPtr smartpointer</span></h2></div>
<p class="para block block-first">
<span class="classname" dir="ltr">Glib::RefPtr</span> is a smartpointer. Specifically, it is a
reference-counting smartpointer. You might be familiar with
<span class="classname" dir="ltr">std::unique_ptr&lt;&gt;</span>
and <span class="classname" dir="ltr">std::shared_ptr&lt;&gt;</span>, which are also smartpointers.
In <span class="application">gtkmm</span>-4.0 <span class="classname" dir="ltr">Glib::RefPtr&lt;&gt;</span> is an alias for
<span class="classname" dir="ltr">std::shared_ptr&lt;&gt;</span>,
which is reference-counting. <span class="classname" dir="ltr">Glib::RefPtr&lt;&gt;</span> was introduced
long before there was a reference-counting smartpointer in the C++ Standard Library.
</p>
<p class="para block"><a class="ulink" href="http://developer.gnome.org/glibmm/unstable/classGlib_1_1RefPtr.html" title="http://developer.gnome.org/glibmm/unstable/classGlib_1_1RefPtr.html">Reference</a></p>
<p class="para block">A smartpointer acts much like a normal pointer. Here are a few examples.</p>
<div class="autotoc"><ul>
<li>
<span class="label">A.1. </span><a class="xref" href="#sec-refptr-copying" title="Copying">Copying</a>
</li>
<li>
<span class="label">A.2. </span><a class="xref" href="#sec-refptr-dereferencing" title="Dereferencing">Dereferencing</a>
</li>
<li>
<span class="label">A.3. </span><a class="xref" href="#sec-refptr-casting" title="Casting">Casting</a>
</li>
<li>
<span class="label">A.4. </span><a class="xref" href="#sec-refptr-checking-for-null" title="Checking for nullptr">Checking for nullptr</a>
</li>
<li>
<span class="label">A.5. </span><a class="xref" href="#sec-refptr-constness" title="Constness">Constness</a>
</li>
</ul></div>
<div class="division sect1">
<a name="sec-refptr-copying"><!--sec-refptr-copying--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">A.1. </span>Copying</span></h3></div>
<p class="para block block-first">
You can copy <span class="classname" dir="ltr">RefPtr</span>s, just like normal pointers. But
unlike normal pointers, you don't need to worry about deleting the underlying
instance.
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">auto refPixbuf = Gdk::Pixbuf::create_from_file(filename);
auto refPixbuf2 = refPixbuf;
</pre></div>
<p class="para block">
Of course this means that you can store <span class="classname" dir="ltr">RefPtr</span>s in
standard containers, such as <span class="classname" dir="ltr">std::vector</span> or
<span class="classname" dir="ltr">std::list</span>.</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">std::list&lt;Glib::RefPtr&lt;Gdk::Pixbuf&gt;&gt; listPixbufs;
auto refPixbuf = Gdk::Pixbuf::create_from_file(filename);
listPixbufs.push_back(refPixbuf);
</pre></div>
</div>
<div class="division sect1">
<a name="sec-refptr-dereferencing"><!--sec-refptr-dereferencing--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">A.2. </span>Dereferencing</span></h3></div>
<p class="para block block-first">You can dereference a smartpointer with the -&gt; operator, to
call the methods of the underlying instance, just like a normal pointer.
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">auto refPixbuf = Gdk::Pixbuf::create_from_file(filename);
auto width = refPixbuf-&gt;get_width();
</pre></div>
<p class="para block">You can also use the * operator and the <span class="methodname" dir="ltr">get()</span> method
to access the underlying instance, but it's usually a bad idea to do so. Unless
you are careful, you can end up with a pointer or a reference which is not included
in the reference count.
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">auto refPixbuf = Gdk::Pixbuf::create_from_file(filename);
auto&amp; underlying = *refPixbuf; // Possible, but not recommended
</pre></div>
</div>
<div class="division sect1">
<a name="sec-refptr-casting"><!--sec-refptr-casting--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">A.3. </span>Casting</span></h3></div>
<p class="para block block-first">
You can cast <span class="classname" dir="ltr">RefPtr</span>s to base types, just like normal
pointers.
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">auto refStore = Gtk::TreeStore::create(columns);
Glib::RefPtr&lt;Gtk::TreeModel&gt; refModel = refStore;
</pre></div>
<p class="para block">This means that any method which takes a <span class="type" dir="ltr">const
Glib::RefPtr&lt;BaseType&gt;&amp;</span> argument can also take a
<span class="type" dir="ltr">const Glib::RefPtr&lt;DerivedType&gt;&amp;</span>. The cast is
implicit, just as it would be for a normal pointer.</p>
<p class="para block">You can also cast to a derived type, but the syntax is
a little different than with a normal pointer.
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">auto refStore = std::dynamic_pointer_cast&lt;Gtk::TreeStore&gt;(refModel);
auto refStore2 = std::static_pointer_cast&lt;Gtk::TreeStore&gt;(refModel);
</pre></div>
</div>
<div class="division sect1">
<a name="sec-refptr-checking-for-null"><!--sec-refptr-checking-for-null--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">A.4. </span>Checking for nullptr</span></h3></div>
<p class="para block block-first">
Just like normal pointers, you can check whether a
<span class="classname" dir="ltr">RefPtr</span> points to anything.
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">auto refModel = m_TreeView.get_model();
if (refModel)
{
  auto cols_count = refModel-&gt;get_n_columns();
  ...
}
</pre></div>
<p class="para block">
But unlike normal pointers, <span class="classname" dir="ltr">RefPtr</span>s are automatically
initialized to <span class="literal" dir="ltr">nullptr</span> so you don't need to remember to do that yourself.
</p>
</div>
<div class="division sect1">
<a name="sec-refptr-constness"><!--sec-refptr-constness--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">A.5. </span>Constness</span></h3></div>
<p class="para block block-first">
The use of the <span class="literal" dir="ltr">const</span> keyword in C++ is not always clear. You
might not realise that <span class="type" dir="ltr">const Something*</span> declares a pointer to a
<span class="type" dir="ltr">const Something</span>. The pointer can be changed, but not the
<span class="type" dir="ltr">Something</span> that it points to.
</p>
<p class="para block">
Therefore, the <span class="classname" dir="ltr">RefPtr</span> equivalent of
<span class="type" dir="ltr">Something*</span> for a method parameter is <span class="type" dir="ltr">const
    Glib::RefPtr&lt;Something&gt;&amp;</span>, and the equivalent of
<span class="type" dir="ltr">const Something*</span> is <span class="type" dir="ltr">const Glib::RefPtr&lt;const
    Something&gt;&amp;</span>.
</p>
<p class="para block">
The <span class="literal" dir="ltr">const ... &amp;</span> around both is just for efficiency, like
using <span class="classname" dir="ltr">const std::string&amp;</span> instead of
<span class="classname" dir="ltr">std::string</span> for a method parameter to avoid unnecessary
copying.
</p>
</div>
</div>
<div class="division appendix">
<a name="chapter-signals"><!--chapter-signals--></a><div class="header"><h2 class="appendix title"><span class="title"><span class="label">B. </span>Signals</span></h2></div>
<div class="autotoc"><ul>
<li>
<span class="label">B.1. </span><a class="xref" href="#sec-connecting-signal-handlers" title="Connecting signal handlers">Connecting signal handlers</a>
</li>
<li>
<span class="label">B.2. </span><a class="xref" href="#sec-writing-signal-handlers" title="Writing signal handlers">Writing signal handlers</a>
</li>
<li>
<span class="label">B.3. </span><a class="xref" href="#sec-disconnecting-signal-handlers" title="Disconnecting signal handlers">Disconnecting signal handlers</a>
</li>
<li>
<span class="label">B.4. </span><a class="xref" href="#sec-overriding-default-signal-handlers" title="Overriding default signal handlers">Overriding default signal handlers</a>
</li>
<li>
<span class="label">B.5. </span><a class="xref" href="#sec-binding-extra-arguments" title="Binding extra arguments">Binding extra arguments</a>
</li>
<li>
<span class="label">B.6. </span><a class="xref" href="#sec-xeventsignals" title="X Event signals">X Event signals</a>
</li>
<li>
<span class="label">B.7. </span><a class="xref" href="#sec-exceptions-in-signal-handlers" title="Exceptions in signal handlers">Exceptions in signal handlers</a>
</li>
</ul></div>
<div class="division sect1">
<a name="sec-connecting-signal-handlers"><!--sec-connecting-signal-handlers--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">B.1. </span>Connecting signal handlers</span></h3></div>
<p class="para block block-first">
<span class="application">gtkmm</span> widget classes have signal accessor methods, such as
<span class="methodname" dir="ltr">Gtk::Button::signal_clicked()</span>, which allow you to connect
your signal handler. Thanks to the flexibility of
<span class="application">libsigc++</span>, the callback library used by <span class="application">gtkmm</span>, the
signal handler can be almost any kind of function, but you will probably want
to use a class method. Among <span class="application">GTK</span> C coders, these
signal handlers are often named callbacks.
</p>
<p class="para block">
Here's an example of a signal handler being connected to a signal:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include &lt;gtkmm/button.h&gt;

void on_button_clicked()
{
    std::cout &lt;&lt; "Hello World" &lt;&lt; std::endl;
}

int main()
{
    Gtk::Button button("Hello World");
    button.signal_clicked().connect(sigc::ptr_fun(&amp;on_button_clicked));
}
</pre></div>
<p class="para block">
There's rather a lot to think about in this (non-functional) code.
First let's identify the parties involved:
</p>
<div class="block list itemizedlist"><ul class="itemizedlist">
<li class="li-first">

<span class="para">
The signal handler is <span class="methodname" dir="ltr">on_button_clicked()</span>.
</span>
</li>
<li>

<span class="para">
We're hooking it up to the <span class="classname" dir="ltr">Gtk::Button</span> object called
<span class="varname" dir="ltr">button</span>.
</span>
</li>
<li>

<span class="para">
When the Button emits its <span class="literal" dir="ltr">clicked</span> signal,
<span class="methodname" dir="ltr">on_button_clicked()</span> will be called.
</span>
</li>
</ul></div>
<p class="para block">
Now let's look at the connection again:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">    ...
    button.signal_clicked().connect(sigc::ptr_fun(&amp;on_button_clicked));
    ...
</pre></div>
<p class="para block">
Note that we don't pass a pointer to <span class="methodname" dir="ltr">on_button_clicked()</span>
directly to the signal's <span class="methodname" dir="ltr">connect()</span> method. Instead, we
call <span class="function">sigc::ptr_fun()</span>, and pass the result to
<span class="methodname" dir="ltr">connect()</span>.
</p>
<p class="para block">
<span class="function">sigc::ptr_fun()</span>  generates a <span class="classname" dir="ltr">sigc::slot</span>.
A slot is an object which
looks and feels like a function, but is actually an object. These are also
known as function objects, or functors.
<span class="function">sigc::ptr_fun()</span> generates a slot for a standalone function or static method.
<span class="function">sigc::mem_fun()</span> generates a slot for a member method of a particular instance.
</p>
<p class="para block">
Here's a slightly larger example of slots in action:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">void on_button_clicked();

class some_class
{
    void on_button_clicked();
};

some_class some_object;

int main()
{
    Gtk::Button button;
    button.signal_clicked().connect( sigc::ptr_fun(&amp;on_button_clicked) );
    button.signal_clicked().connect( sigc::mem_fun(some_object, &amp;some_class::on_button_clicked) );
}
</pre></div>
<p class="para block">
The first call to <span class="methodname" dir="ltr">connect()</span> is just like the one we saw
last time; nothing new here.</p>
<p class="para block">The next is more interesting.
<span class="function">sigc::mem_fun()</span> is called with two arguments. The first
argument is <span class="parameter" dir="ltr">some_object</span>, which is the object that our
new slot will be pointing at. The second argument is a pointer to one of its
methods. This particular version of <span class="function">sigc::mem_fun()</span>
creates a slot which will, when "called", call the pointed-to method of the
specified object, in this case
<span class="methodname" dir="ltr">some_object.on_button_clicked()</span>.
</p>
<p class="para block">
Another thing to note about this example is that we made the call to
<span class="methodname" dir="ltr">connect()</span> twice for the same signal object. This is
perfectly fine - when the button is clicked, both signal handlers will be
called.
</p>
<p class="para block">
We just told you that the button's <span class="literal" dir="ltr">clicked</span> signal is expecting
to call a method with no arguments. All signals have
requirements like this - you can't hook a function with two arguments
to a signal expecting none (unless you use an adapter, such as
<span class="function">sigc::bind()</span>, of course). Therefore, it's important to
know what type of signal handler you'll be expected to connect to a given
signal.
</p>
</div>
<div class="division sect1">
<a name="sec-writing-signal-handlers"><!--sec-writing-signal-handlers--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">B.2. </span>Writing signal handlers</span></h3></div>
<p class="para block block-first">
To find out what type of signal handler you can connect to a signal, you can
look it up in the reference documentation or the header file. Here's an example of a signal declaration you
might see in the <span class="application">gtkmm</span> headers:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">Glib::SignalProxy&lt;bool(Gtk::DirectionType)&gt; signal_focus()
</pre></div>
<p class="para block">
Other than the signal's name (<span class="literal" dir="ltr">focus</span>), the template arguments are
important to note here. The first argument, <span class="type" dir="ltr">bool</span>, is the type that
the signal handler should return; and the type within parentheses,
<span class="type" dir="ltr">Gtk::DirectionType</span>, is the type of this signal's first, and only,
argument. By looking at the reference documentation, you can
see the names of the arguments too.
</p>
<p class="para block">
The same principles apply for signals which have more arguments. Here's one
with three (taken from <span class="filename" dir="ltr">&lt;gtkmm/textbuffer.h&gt;</span>):
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">Glib::SignalProxy&lt;void(TextBuffer::iterator&amp;, const Glib::ustrin&amp;, int)&gt; signal_insert();
</pre></div>
<p class="para block">
It follows the same form. The first type is <span class="type" dir="ltr">void</span>, so that should be
our signal handler's return type.
The following three types are the argument types, in order. Our signal
handler's prototype could look like this:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">void on_insert(TextBuffer::iterator&amp; pos, const Glib::ustring&amp; text, int bytes)
</pre></div>
</div>
<div class="division sect1">
<a name="sec-disconnecting-signal-handlers"><!--sec-disconnecting-signal-handlers--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">B.3. </span>Disconnecting signal handlers</span></h3></div>
<p class="para block block-first">
Let's take another look at a Signal's <span class="literal" dir="ltr">connect</span> method:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">sigc::connection signal&lt;void(int)&gt;::connect(const sigc::slot&lt;void(int)&gt;&amp;);
</pre></div>
<p class="para block">
The returned <span class="classname" dir="ltr">sigc::connection</span> can be used to control the
connection. By keeping a connection object you can disconnect its associated signal
handler using the <span class="methodname" dir="ltr">sigc::connection::disconnect()</span> method.
</p>
</div>
<div class="division sect1">
<a name="sec-overriding-default-signal-handlers"><!--sec-overriding-default-signal-handlers--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">B.4. </span>Overriding default signal handlers</span></h3></div>
<p class="para block block-first">
So far we've told you to perform actions in
response to button-presses and the like by handling signals.
That's certainly a good way to do things, but it's not the only
way.
</p>
<p class="para block">
Instead of laboriously connecting signal handlers to signals,
you can simply make a new class which inherits from a widget - say, a
Button - and then override the default signal handler, such as Button::on_clicked(). This can be a
lot simpler than hooking up signal handlers for everything.
</p>
<p class="para block">
Subclassing isn't always the best way to accomplish
things. It is only useful when you want the widget to handle its own signal by itself. If you want some other class to handle the signal then you'll need to connect a separate handler. This is even more true if you want several objects to handle the same signal, or if you want one signal handler to respond to the same signal from different objects.
</p>
<p class="para block">
<span class="application">gtkmm</span> classes are designed with overriding in mind; they contain
virtual member methods specifically intended to be overridden.
</p>
<p class="para block">
Let's look at an example of overriding:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include &lt;gtkmm/button.h&gt;

class OverriddenButton : public Gtk::Button
{
protected:
  void on_clicked() override;
}

void OverriddenButton::on_clicked()
{
  std::cout &lt;&lt; "Hello World" &lt;&lt; std::endl;

  // call the base class's version of the method:
  Gtk::Button::on_clicked();
}
</pre></div>
<p class="para block">
Here  we define a new class called <span class="classname" dir="ltr">OverriddenButton</span>,
which inherits from <span class="classname" dir="ltr">Gtk::Button</span>. The only thing we
change is the <span class="methodname" dir="ltr">on_clicked()</span> method, which is called
whenever <span class="classname" dir="ltr">Gtk::Button</span> emits the
<span class="literal" dir="ltr">clicked</span> signal. This method prints "Hello World" to
<span class="literal" dir="ltr">stdout</span>, and then calls the original, overridden method, to
let <span class="classname" dir="ltr">Gtk::Button</span> do what it would have done had we not
overridden.
</p>
<p class="para block">
You don't always need to call the parent's method; there are times
when you might not want to. Note that we called the parent method
<span class="emphasis">after</span> writing "Hello World", but we could have called it before.
In this simple example, it hardly matters much, but there are times
when it will. With connected signal handlers, it's not quite so easy to change details
like this, and you can do something here which you can't do at all
with connected signal handlers: you can call the parent method in the <span class="emphasis">middle</span> of
your custom code.
</p>
</div>
<div class="division sect1">
<a name="sec-binding-extra-arguments"><!--sec-binding-extra-arguments--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">B.5. </span>Binding extra arguments</span></h3></div>
<p class="para block block-first">
If you use one signal handler to catch the same signal from several widgets,
you might like that signal handler to receive some extra information. For
instance, you might want to know which button was clicked. You can do this with
<span class="function">sigc::bind()</span>. Here's some code from the <a class="link" href="#sec-helloworld2" title="An improved Hello World">helloworld2</a> example.
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">m_button1.signal_clicked().connect(sigc::bind(sigc::mem_fun(*this, &amp;HelloWorld::on_button_clicked), "button 1"));
</pre></div>
This says that we want the signal to send an extra
<span class="classname" dir="ltr">Glib::ustring</span> argument to the signal handler, and that
the value of that argument should be "button 1". Of course we will need to add
that extra argument to the declaration of our signal handler:
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">void on_button_clicked(const Glib::ustring&amp; data);
</pre></div>
Of course, a normal "clicked" signal handler would have no arguments.
</p>
<p class="para block">
<span class="function">sigc::bind()</span> is not commonly used, but you might find it
helpful sometimes. If you are familiar with <span class="application">GTK</span>
programming then you have probably noticed that this is similar to the extra
<span class="literal" dir="ltr">gpointer data</span> arguments which all GTK callbacks have. This
is generally overused in <span class="application">GTK</span> to pass information
that should be stored as member data in a derived widget, but widget derivation
is very difficult in C. We have far less need of this hack in <span class="application">gtkmm</span>.
</p>
</div>
<div class="division sect1">
<a name="sec-xeventsignals"><!--sec-xeventsignals--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">B.6. </span>X Event signals</span></h3></div>
<p class="para block block-first">
The <span class="classname" dir="ltr">Widget</span> class has some special signals which
correspond to the underlying X-Windows events. These are suffixed by
<span class="literal" dir="ltr">_event</span>; for instance,
<span class="methodname" dir="ltr">Widget::signal_button_press_event()</span>.
</p>
<p class="para block">
You might occasionally find it useful to handle X events when there's something
you can't accomplish with normal signals. <span class="classname" dir="ltr">Gtk::Button</span>,
for example, does not send mouse-pointer coordinates with its
<span class="literal" dir="ltr">clicked</span> signal, but you could handle
<span class="literal" dir="ltr">button_press_event</span> if you needed this
information. X events are also often used to handle key-presses.
</p>
<p class="para block">
These signals behave slightly differently. The value returned from the signal handler indicates whether it has fully "handled"
the event. If the value is <span class="literal" dir="ltr">false</span> then <span class="application">gtkmm</span> will pass the event on to the next signal handler. If the value is <span class="literal" dir="ltr">true</span> then no other signal handlers will need to be called.
</p>
<p class="para block">
Handling an X event doesn't affect the Widget's other signals. If you handle
<span class="literal" dir="ltr">button_press_event</span> for
<span class="classname" dir="ltr">Gtk::Button</span>, you'll still be able to get the
<span class="literal" dir="ltr">clicked</span> signal. They are emitted at (nearly) the same time.
</p>
<p class="para block">
Here's a simple example:</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">bool on_button_press(GdkEventButton* event);
Gtk::Button button("label");
button.signal_button_press_event().connect( sigc::ptr_fun(&amp;on_button_press) );
</pre></div>
<p class="para block">
When the mouse is over the button and a mouse button is pressed,
<span class="methodname" dir="ltr">on_button_press()</span> will be called.
</p>
<p class="para block">
<span class="type" dir="ltr">GdkEventButton</span> is a structure containing the event's parameters,
such as the coordinates of the mouse pointer at the time the button was
pressed. There are several different types of <span class="type" dir="ltr">GdkEvent</span> structures
for the various events.
</p>
<div class="autotoc"><ul><li>
<span class="label">B.6.1. </span><a class="xref" href="#signal-handler-sequence" title="Signal Handler sequence">Signal Handler sequence</a>
</li></ul></div>
<div class="division sect2">
<a name="signal-handler-sequence"><!--signal-handler-sequence--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">B.6.1. </span>Signal Handler sequence</span></h4></div>
<p class="para block block-first">By default, your signal handlers are called after any previously-connected
signal handlers. However, this can be a problem with the X Event signals. For instance,
the existing signal handlers, or the default signal handler, might return <span class="literal" dir="ltr">true</span>
to stop other signal handlers from being called. To specify that your signal handler
should be called before the other signal handlers, so that it will always be called,
you can specify <span class="literal" dir="ltr">false</span> for the optional <span class="literal" dir="ltr">after</span>
parameter. For instance,
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">button.signal_button_press_event().connect( sigc::ptr_fun(&amp;on_mywindow_button_press), false );
</pre></div>
<p class="para block">The event is delivered first to the widget the event occurred in. If all
signal handlers in that widget return <span class="literal" dir="ltr">false</span> (indicating that
the event has not been handled), then the signal will be propagated to the parent
widget and emitted there. This continues all the way up to the top-level widget
if no one handles the event. 
</p>
</div>
</div>
<div class="division sect1">
<a name="sec-exceptions-in-signal-handlers"><!--sec-exceptions-in-signal-handlers--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">B.7. </span>Exceptions in signal handlers</span></h3></div>
<p class="para block block-first">
When a program is aborted because of an unhandled C++ exception, it's sometimes
possible to use a debugger to find the location where the exception was thrown.
This is more difficult than usual if the exception was thrown from a signal handler.
</p>
<p class="para block">
This section describes primarily what you can expect on a Linux system, when you
use <a class="ulink" href="http://www.gnu.org/software/gdb/" title="http://www.gnu.org/software/gdb/">the gdb debugger</a>.
</p>
<p class="para block">
First, let's look at a simple example where an exception is thrown from a normal
function (no signal handler).
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">// without_signal.cc
#include &lt;gtkmm.h&gt;

bool throwSomething()
{
  throw "Something";
  return true;
}

int main(int argc, char** argv)
{
  throwSomething();
  auto app = Gtk::Application::create("org.gtkmm.without_signal");
  return app-&gt;run();
}
</pre></div>
<p class="para block">
Here is an excerpt from a <span class="application">gdb</span> session. Only the most
interesting parts of the output are shown.
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">&gt; gdb without_signal
(gdb) run
terminate called after throwing an instance of 'char const*'

Program received signal SIGABRT, Aborted.
(gdb) backtrace
#7  0x08048864 in throwSomething () at without_signal.cc:6
#8  0x0804887d in main (argc=1, argv=0xbfffecd4) at without_signal.cc:12
</pre></div>
You can see that the exception was thrown from <span class="filename" dir="ltr">without_signal.cc</span>,
line 6 (<span class="code" dir="ltr">throw "Something";</span>).
</p>
<p class="para block">
Now let's see what happens when an exception is thrown from a signal handler.
Here's the source code.
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">// with_signal.cc
#include &lt;gtkmm.h&gt;

bool throwSomething()
{
  throw "Something";
  return true;
}

int main(int argc, char** argv)
{
  Glib::signal_timeout().connect(sigc::ptr_fun(throwSomething), 500);
  auto app = Gtk::Application::create("org.gtkmm.with_signal");
  app-&gt;hold();
  return app-&gt;run();
}
</pre></div>
<p class="para block">
And here's an excerpt from a <span class="application">gdb</span> session.
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">&gt; gdb with_signal
(gdb) run
(with_signal:2703): glibmm-ERROR **:
unhandled exception (type unknown) in signal handler

Program received signal SIGTRAP, Trace/breakpoint trap.
(gdb) backtrace
#2  0x0063c6ab in glibmm_unexpected_exception () at exceptionhandler.cc:77
#3  Glib::exception_handlers_invoke () at exceptionhandler.cc:150
#4  0x0063d370 in glibmm_source_callback (data=0x804d620) at main.cc:212
#13 0x002e1b31 in Gtk::Application::run (this=0x804f300) at application.cc:178
#14 0x08048ccc in main (argc=1, argv=0xbfffecd4) at with_signal.cc:16
</pre></div>
The exception is caught in <span class="application">glibmm</span>, and the program
ends with a call to <span class="function">g_error()</span>. Other exceptions may result
in different behaviour, but in any case the exception from a signal handler is
caught in <span class="application">glibmm</span> or <span class="application">gtkmm</span>, and
<span class="application">gdb</span> can't see where it was thrown.
</p>
<p class="para block">
To see where the exception is thrown, you can use the <span class="application">gdb</span>
command <span class="userinput" dir="ltr">catch throw</span>.
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">&gt; gdb with_signal
(gdb) catch throw
Catchpoint 1 (throw)
(gdb) run
Catchpoint 1 (exception thrown), 0x00714ff0 in __cxa_throw ()
(gdb) backtrace
#0  0x00714ff0 in __cxa_throw () from /usr/lib/i386-linux-gnu/libstdc++.so.6
#1  0x08048bd4 in throwSomething () at with_signal.cc:6
(gdb) continue
Continuing.
(with_signal:2375): glibmm-ERROR **
unhandled exception (type unknown) in signal handler

Program received signal SIGTRAP, Trace/breakpoint trap.
</pre></div>
<p class="para block">
If there are many caught exceptions before the interesting uncaught one, this
method can be tedious. It can be automated with the following
<span class="application">gdb</span> commands.
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">(gdb) catch throw
(gdb) commands
(gdb)   backtrace
(gdb)   continue
(gdb)   end
(gdb) set pagination off
(gdb) run
</pre></div>
These commands will print a backtrace from each <span class="code" dir="ltr">throw</span> and continue.
The backtrace from the last (or possibly the last but one) <span class="code" dir="ltr">throw</span>
before the program stops, is the interesting one.
</p>
</div>
</div>
<div class="division appendix">
<a name="chapter-custom-signals"><!--chapter-custom-signals--></a><div class="header"><h2 class="appendix title"><span class="title"><span class="label">C. </span>Creating your own signals</span></h2></div>
<p class="para block block-first">
Now that you've seen signals and signal handlers in <span class="application">gtkmm</span>, you
might like to use the same technique to allow interaction between your
own classes. That's actually very simple by using the
<span class="application">libsigc++</span> library directly.
</p>
<p class="para block">
This isn't purely a <span class="application">gtkmm</span> or GUI issue. <span class="application">gtkmm</span> uses
<span class="application">libsigc++</span> to implement its proxy wrappers for the
<span class="application">GTK</span> signal system, but for new,
non-GTK signals, you can create pure C++ signals, using the
<span class="classname" dir="ltr">sigc::signal&lt;&gt;</span> template.
</p>
<p class="para block">
For instance, to create a signal that sends 2 parameters, a <span class="type" dir="ltr">bool</span>
and an <span class="type" dir="ltr">int</span>, just declare a <span class="classname" dir="ltr">sigc::signal</span>,
like so:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">sigc::signal&lt;void(bool, int)&gt; signal_something;
</pre></div>
<p class="para block">
You could just declare that signal as a public member variable, but
some people find that distasteful and prefer to make it available via
an accessor method, like so:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">class Server
{
public:
  //signal accessor:
  using type_signal_something = sigc::signal&lt;void(bool, int)&gt;;
  type_signal_something signal_something();

protected:
  type_signal_something m_signal_something;
};

Server::type_signal_something Server::signal_something()
{
  return m_signal_something;
}
</pre></div>
<p class="para block">
You can then connect to the signal using the same syntax used when
connecting to <span class="application">gtkmm</span> signals. For instance,
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">server.signal_something().connect(
  sigc::mem_fun(client, &amp;Client::on_server_something) );
</pre></div>
<div class="autotoc"><ul><li>
<span class="label">C.1. </span><a class="xref" href="#chapter-custom-signals-example" title="Example">Example</a>
</li></ul></div>
<div class="division sect1">
<a name="chapter-custom-signals-example"><!--chapter-custom-signals-example--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">C.1. </span>Example</span></h3></div>
<p class="para block block-first">
This is a full working example that defines and uses custom signals.
</p>
<p class="para block"><a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/signals/custom/" title="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/book/signals/custom/">Source Code</a></p>
<p class="para block">File: <span class="filename" dir="ltr">server.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLE_SERVER_H
#define GTKMM_EXAMPLE_SERVER_H

#include &lt;sigc++/sigc++.h&gt;

class Server
{
public:
  Server();
  virtual ~Server();

  void do_something();

  //signal accessor:
  using type_signal_something = sigc::signal&lt;void(bool, int)&gt;;
  type_signal_something signal_something();

protected:
  type_signal_something m_signal_something;
};

#endif //GTKMM_EXAMPLE_SERVER_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">client.h</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#ifndef GTKMM_EXAMPLE_CLIENT_H
#define GTKMM_EXAMPLE_CLIENT_H

#include &lt;sigc++/sigc++.h&gt;

//Client must inherit from sigc::trackable.
//because libsigc++ needs to keep track of the lifetime of signal handlers.
class Client : public sigc::trackable
{
public:
  Client();
  virtual ~Client();

  //Signal handler:
  void on_server_something(bool a, int b);
};

#endif //GTKMM_EXAMPLE_CLIENT_H
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">main.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "server.h"
#include "client.h"
#include &lt;iostream&gt;

int main(int, char**)
{
  Server server;
  Client client;

  //Connect a Server signal to the signal handler in Client.
  server.signal_something().connect(sigc::mem_fun(client,
              &amp;Client::on_server_something) );

  std::cout &lt;&lt; "Before Server::do_something()" &lt;&lt; std::endl;

  //Tell the server to do something that will eventually cause it to emit the
  //"something" signal.
  server.do_something();    // Client::on_server_something() will run before
                            // Server::do_something() has completed.

  std::cout &lt;&lt; "After Server::do_something()" &lt;&lt; std::endl;

  return 0;
}
</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">server.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "server.h"
#include &lt;iostream&gt;

Server::Server()
{
}

Server::~Server()
{
}

Server::type_signal_something Server::signal_something()
{
  return m_signal_something;
}

void Server::do_something()
{
  m_signal_something.emit(false, 5);
}

</pre></div>
<p class="para block">File: <span class="filename" dir="ltr">client.cc</span> (For use with gtkmm 4)</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include "client.h"
#include &lt;iostream&gt;

Client::Client()
{
}

Client::~Client()
{
}

void Client::on_server_something(bool a, int b)
{
  std::cout &lt;&lt; "Client::on_server_something() called with these parameters: "
      &lt;&lt; a &lt;&lt; ", " &lt;&lt; b &lt;&lt; std::endl;
}
</pre></div>
</div>
</div>
<div class="division appendix">
<a name="sec-signals-comparison"><!--sec-signals-comparison--></a><div class="header"><h2 class="appendix title"><span class="title"><span class="label">D. </span>Comparison with other signalling systems</span></h2></div>
<p class="para block block-first">

(An aside: <span class="application">GTK</span> calls this scheme "signalling"; the
sharp-eyed reader with GUI toolkit experience will note that this same design
is often
seen under the name of "broadcaster-listener" (e.g., in Metrowerks'
PowerPlant framework for the Macintosh). It works in much the same
way: one sets up <span class="literal" dir="ltr">broadcasters</span>, and then connects
<span class="literal" dir="ltr">listeners</span> to them; the broadcaster keeps a list of the
objects listening to it, and when someone gives the broadcaster a
message, it calls all of its objects in its list with the message. In
<span class="application">gtkmm</span>, signal objects play the role of broadcasters, and slots
play the role of listeners - sort of. More on this later.)
</p>
<p class="para block">
<span class="application">gtkmm</span> signal handlers are strongly-typed, whereas
<span class="application">GTK</span> C code allows you to connect a callback with
the wrong number and type of arguments, leading to a segfault at runtime. And,
unlike <span class="application">Qt</span>, <span class="application">gtkmm</span> achieves this without modifying
the C++ language.</p>
<p class="para block">
Re. Overriding signal handlers: You can do this in the straight-C world of GTK too; that's what GTK's
object system is for. But in GTK, you have to go through some
complicated procedures to get object-oriented features like
inheritance and overloading. In C++, it's simple, since those
features are supported in the language itself; you can let the
compiler do the dirty work.
</p>
<p class="para block">
This is one of the places where the beauty of C++ really comes out.
One wouldn't think of subclassing a GTK widget simply to override its
action method; it's just too much trouble. In GTK, you almost always
use signals to get things done, unless you're writing a new widget.
But because overriding methods is so easy in C++, it's entirely
practical - and sensible - to subclass a button for that purpose.
</p>
</div>
<div class="division appendix">
<a name="sec-windows-installation"><!--sec-windows-installation--></a><div class="header"><h2 class="appendix title"><span class="title"><span class="label">E. </span><span class="application">gtkmm</span> and Win32</span></h2></div>
<p class="para block block-first">
      One of the major advantages of <span class="application">gtkmm</span> is that it is crossplatform. <span class="application">gtkmm</span> programs written on other platforms such as
      GNU/Linux can generally be transferred to Windows (and vice
      versa) with few modifications to the source.
    </p>
<p class="para block">
      <span class="application">gtkmm</span> currently works with the
      <a class="ulink" href="http://mingw.org/" title="http://mingw.org/">MinGW/GCC compiler</a> with a compiler version
      that supports C++17, such as gcc 7 or 8. It also works with Microsoft
      Visual C++ 2017 15.7.x or later (including the freely available express/community
      editions) on the Windows platform. There is an
      <a class="ulink" href="ftp://ftp.gnome.org/pub/GNOME/binaries/win32/gtkmm" title="ftp://ftp.gnome.org/pub/GNOME/binaries/win32/gtkmm">installer</a>
      available for <span class="application">gtkmm</span> on Microsoft Windows, but as of this writing
      (October 2020) it has not been updated for a long time.
      Please be aware that although normally it is fine to mix builds done with
      Visual Studio 2017 and 2019, please do not do so when building
      <span class="application">gtkmm</span> with its -mm dependencies.
    </p>
<p class="para block">Refer to the <a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm/tree/master/README.win32" title="https://gitlab.gnome.org/GNOME/gtkmm/tree/master/README.win32">README.win32</a>,
    as well as the <a class="ulink" href="https://gitlab.gnome.org/GNOME/gtkmm/tree/master/MSVC_NMake/README" title="https://gitlab.gnome.org/GNOME/gtkmm/tree/master/MSVC_NMake/README">README</a>
    files in the <span class="application">gtkmm</span>, pangomm and glibmm for instructions on how to build <span class="application">gtkmm</span> on Windows.
    </p>
</div>
<div class="division appendix">
<a name="chapter-working-with-source"><!--chapter-working-with-source--></a><div class="header"><h2 class="appendix title"><span class="title"><span class="label">F. </span>Working with gtkmm's Source Code</span></h2></div>
<p class="para block block-first">
    If you are interested in helping out with the development of <span class="application">gtkmm</span>, or
    fixing a bug in <span class="application">gtkmm</span>, you'll probably need to build the development
    version of <span class="application">gtkmm</span>. However, you should not install a development version over
    your stable version. Instead, you should install it alongside your existing <span class="application">gtkmm</span>
    installation, in a separate path.
  </p>
<p class="para block">
    The easiest way to do this is using <a class="ulink" href="https://wiki.gnome.org/Projects/Jhbuild" title="https://wiki.gnome.org/Projects/Jhbuild">jhbuild</a>.
    <span class="application">jhbuild</span> is a program that makes building GNOME
    software much easier by calculating dependencies and building things in the
    correct order. This section will give a brief explanation of how to set up
    <span class="application">jhbuild</span> to build and install <span class="application">gtkmm</span> from the
    source repository (git). For up-to-date information
    on <span class="application">jhbuild</span>, please refer to the <a class="ulink" href="http://developer.gnome.org/jhbuild/unstable/" title="http://developer.gnome.org/jhbuild/unstable/">jhbuild manual</a>.
  </p>
<div class="admonition block note block-indent"><div class="note-inner">
    <p class="para block block-first">
    Note that to build <span class="application">gtkmm</span> from git, you'll often need to build many of its
    dependencies from git as well. <span class="application">jhbuild</span> makes
    this easier than it would normally be, but it will take quite a while to
    build and install them all. You will probably encounter build problems,
    though these will usually be corrected quickly if you report them.
    </p>
  </div></div>
<p class="para block">
    <span class="application">gnome-build-meta</span> is an alternative to
    <span class="application">jhbuild</span>. It is described at the
    <a class="ulink" href="https://wiki.gnome.org/Newcomers/BuildSystemComponent" title="https://wiki.gnome.org/Newcomers/BuildSystemComponent">Building system components</a>
    wiki page, but here we concentrate on <span class="application">jhbuild</span>.
  </p>
<div class="autotoc"><ul>
<li>
<span class="label">F.1. </span><a class="xref" href="#sec-setting-up-jhbuild" title="Setting up jhbuild">Setting up jhbuild</a>
</li>
<li>
<span class="label">F.2. </span><a class="xref" href="#sec-installing-jhbuild" title="Installing and Using the git version of gtkmm">Installing and Using the git version of <span class="application">gtkmm</span></a>
</li>
</ul></div>
<div class="division sect1">
<a name="sec-setting-up-jhbuild"><!--sec-setting-up-jhbuild--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">F.1. </span>Setting up jhbuild</span></h3></div>
<p class="para block block-first">
      To set up <span class="application">jhbuild</span>, follow the basic
      installation instructions from the <a class="ulink" href="http://developer.gnome.org/jhbuild/unstable/" title="http://developer.gnome.org/jhbuild/unstable/">jhbuild manual</a>.
      After you have installed <span class="application">jhbuild</span>, you
      should copy the sample <span class="application">jhbuild</span> configuration
      file into your home directory by executing the following command from the
      <span class="application">jhbuild</span> directory:
      <div dir="ltr" class=" block screen block-indent"><pre class="screen">$ cp examples/sample.jhbuildrc ~/.config/jhbuildrc</pre></div>
    </p>
<p class="para block">
      The <span class="application">gtkmm</span> module is defined in the
      <span class="filename" dir="ltr">gnome-suites-core-deps-latest.modules</span> moduleset. So edit your
      <span class="filename" dir="ltr">jhbuildrc</span> file and set your moduleset setting like so:
    </p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">moduleset = 'gnome-suites-core-deps-latest'</pre></div>
<p class="para block">
      After setting the correct moduleset, you need to tell
      <span class="application">jhbuild</span> which module or modules to build. To
      build <span class="application">gtkmm</span> and all of its dependencies, set <span class="varname" dir="ltr">modules</span>
      like so:
    </p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">modules = [ 'gtkmm' ]</pre></div>
<p class="para block">
      You can build several modules by setting the
      <span class="varname" dir="ltr">modules</span> variable to a meta-package, e.g.
      <span class="literal" dir="ltr">meta-gnome-core</span>, or listing more than one module name.
      The <span class="varname" dir="ltr">modules</span> variable specifies which modules will be
      built when you don't explicitly specify anything on the command line. You
      can always build a different moduleset later by specifying it on the
      commandline (e.g. <span class="command" dir="ltr">jhbuild build gtkmm</span>).
    </p>
<div class="admonition block important block-indent"><div class="important-inner">
      <div class="block block-first title title-formal"><span class="title"><span class="label"></span>Setting a prefix</span></div>
      <p class="para block block-first">
        By default, <span class="application">jhbuild</span>'s configuration is
        configured to install all software built with
        <span class="application">jhbuild</span> under the
        <span class="filename" dir="ltr">~/jhbuild/install</span> prefix. You can choose a different
        prefix, but it is recommended that you keep this prefix different from
        other software that you've installed (don't set it to
        <span class="filename" dir="ltr">/usr</span>!) If you've followed the jhbuild instructions
        then this prefix belongs to your user, so you don't need to run jhbuild
        as <span class="literal" dir="ltr">root</span>.
      </p>
    </div></div>
<p class="para block">
      When you downloaded <span class="application">jhbuild</span> from the git repository,
      you got a number of <span class="filename" dir="ltr">.modules</span> files, specifying
      dependencies between modules. By default <span class="application">jhbuild</span>
      does not use the downloaded versions of these files, but reads the
      latest versions in the git repository. This is usually what you want.
      If you don't want it, use the <span class="varname" dir="ltr">use_local_modulesets</span>
      variable in <span class="filename" dir="ltr">.jhbuildrc</span>.
    </p>
</div>
<div class="division sect1">
<a name="sec-installing-jhbuild"><!--sec-installing-jhbuild--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">F.2. </span>Installing and Using the git version of <span class="application">gtkmm</span></span></h3></div>
<p class="para block block-first">
      Once you've configured <span class="application">jhbuild</span> as described
      above, building <span class="application">gtkmm</span> should be relatively straightforward. The first
      time you run <span class="application">jhbuild</span>, you should run the
      following sequence of commands to ensure that
      <span class="application">jhbuild</span> has the required tools and verify that
      it is set up correctly:
      <div dir="ltr" class=" block screen block-indent"><pre class="screen">$ jhbuild bootstrap
$ jhbuild sanitycheck</pre></div>
    </p>
<div class="autotoc"><ul>
<li>
<span class="label">F.2.1. </span><a class="xref" href="#jhbuild-installing-gtkmm" title="Installing gtkmm with jhbuild">Installing <span class="application">gtkmm</span> with <span class="application">jhbuild</span></a>
</li>
<li>
<span class="label">F.2.2. </span><a class="xref" href="#jhbuild-using-gtkmm" title="Using the git version of gtkmm">Using the git version of <span class="application">gtkmm</span></a>
</li>
</ul></div>
<div class="division sect2">
<a name="jhbuild-installing-gtkmm"><!--jhbuild-installing-gtkmm--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">F.2.1. </span>Installing <span class="application">gtkmm</span> with <span class="application">jhbuild</span></span></h4></div>
<p class="para block block-first">
        If everything worked correctly, you should be able to build <span class="application">gtkmm</span> and
        all of its dependencies from git by executing <span class="command" dir="ltr">jhbuild
          build</span> (or, if you didn't specify <span class="application">gtkmm</span> in the
        <span class="varname" dir="ltr">modules</span> variable, with the command <span class="command" dir="ltr">jhbuild
          build gtkmm</span>).
      </p>
<p class="para block">
        This command will build and install a series of modules and will probably
        take quite a long time the first time through. After the first time,
        however, it should go quite a bit faster since it only needs to rebuild
        files that changed since the last build. Alternatively, after you've
        built and installed <span class="application">gtkmm</span> the first time, you can rebuild <span class="application">gtkmm</span> by
        itself (without rebuilding all of its dependencies) with the command
        <span class="command" dir="ltr">jhbuild buildone gtkmm</span>.
      </p>
</div>
<div class="division sect2">
<a name="jhbuild-using-gtkmm"><!--jhbuild-using-gtkmm--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">F.2.2. </span>Using the git version of <span class="application">gtkmm</span></span></h4></div>
<p class="para block block-first">
        After you've installed the git version of <span class="application">gtkmm</span>, you're ready to start
        using and experimenting with it. In order to use the new version of
        <span class="application">gtkmm</span> you've just installed, you need to set some environment
        variables so that your <span class="filename" dir="ltr">configure</span> or <span class="filename" dir="ltr">meson.build</span>
        script knows where to find the new libraries. Fortunately,
        <span class="application">jhbuild</span> offers an easy solution to this
        problem. Executing the command <span class="command" dir="ltr">jhbuild shell</span> will
        start a new shell with all of the correct environment variables set.
        Now if you re-configure and build your project just as you usually do,
        it should link against the newly installed libraries. To return to your
        previous environment, simply exit the <span class="application">jhbuild</span>
        shell.
      </p>
<p class="para block">
        Once you've built your software, you'll need to run your program within
        the jhbuild environment as well. To do this, you can again use the
        <span class="command" dir="ltr">jhbuild shell</span> command to start a new shell with the
        <span class="application">jhbuild</span> environment set up. Alternatively,
        you can execute a one-off command in the
        <span class="application">jhbuild</span> environment using the following
        command: <span class="command" dir="ltr">jhbuild run command-name</span>. In this case,
        the command will be run with the correct environment variables set, but
        will return to your previous environment after the program exits.
      </p>
</div>
</div>
</div>
<div class="division appendix">
<a name="chapter-wrapping-c-libraries"><!--chapter-wrapping-c-libraries--></a><div class="header"><h2 class="appendix title"><span class="title"><span class="label">G. </span>Wrapping C Libraries with gmmproc</span></h2></div>
<p class="para block block-first"><span class="application">gtkmm</span> uses the <span class="command" dir="ltr">gmmproc</span> tool to generate most of its
    source code, using .defs files that define the APIs of
    <span class="classname" dir="ltr">GObject</span>-based libraries. So it's quite easy to create
    additional gtkmm-style wrappers of other glib/GObject-based
    libraries.</p>
<p class="para block">This involves a variety of tools, some of them crufty, but at least
    they work, and has been used successfully by several
    projects.</p>
<div class="autotoc"><ul>
<li>
<span class="label">G.1. </span><a class="xref" href="#sec-wrapping-build-structure" title="The build structure">The build structure</a>
</li>
<li>
<span class="label">G.2. </span><a class="xref" href="#sec-wrapping-defs-files" title="Generating the .defs files.">Generating the .defs files.</a>
</li>
<li>
<span class="label">G.3. </span><a class="xref" href="#sec-wrapping-hg-files" title="The .hg and .ccg files">The .hg and .ccg files</a>
</li>
<li>
<span class="label">G.4. </span><a class="xref" href="#sec-wrapping-hand-coded-files" title="Hand-coded source files">Hand-coded source files</a>
</li>
<li>
<span class="label">G.5. </span><a class="xref" href="#sec-wrapping-initialization" title="Initialization">Initialization</a>
</li>
<li>
<span class="label">G.6. </span><a class="xref" href="#sec-wrapping-problems" title="Problems in the C API.">Problems in the C API.</a>
</li>
<li>
<span class="label">G.7. </span><a class="xref" href="#sec-wrapping-documentation" title="Documentation">Documentation</a>
</li>
</ul></div>
<div class="division sect1">
<a name="sec-wrapping-build-structure"><!--sec-wrapping-build-structure--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">G.1. </span>The build structure</span></h3></div>
<p class="para block block-first">Generation of the source code for a gtkmm-style wrapper API requires use
    of tools such as <span class="command" dir="ltr">gmmproc</span> and
    <span class="filename" dir="ltr">generate_wrap_init.pl</span>, which are included in
    <span class="application">glibmm</span>. In theory you could write your
    own build files to use these appropriately, but a much better option is to
    make use of the build infrastructure provided by the <span class="application">mm-common</span>
    module. To get started, it helps a lot to pick an existing binding module as an example
    to look at.</p>
<p class="para block">For instance, let's pretend that we are wrapping a C library called
    libsomething. It provides a <span class="classname" dir="ltr">GObject</span>-based API with
    types named, for instance, <span class="classname" dir="ltr">SomeWidget</span> and
    <span class="classname" dir="ltr">SomeStuff</span>.</p>
<div class="autotoc"><ul>
<li>
<span class="label">G.1.1. </span><a class="xref" href="#copying-skeleton-project" title="Copying the skeleton project">Copying the skeleton project</a>
</li>
<li>
<span class="label">G.1.2. </span><a class="xref" href="#modifying-build-files" title="Modifying build files">Modifying build files</a>
</li>
</ul></div>
<div class="division sect2">
<a name="copying-skeleton-project"><!--copying-skeleton-project--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">G.1.1. </span>Copying the skeleton project</span></h4></div>
<p class="para block block-first">Typically our wrapper library would be called libsomethingmm. We can start by
  copying the <a class="ulink" href="https://gitlab.gnome.org/GNOME/mm-common/tree/master/skeletonmm" title="https://gitlab.gnome.org/GNOME/mm-common/tree/master/skeletonmm">
  skeleton source tree</a> from the <span class="application">mm-common</span> module.
  Starting with <span class="application">mm-common</span> 1.0.0 this skeleton application
  is built with the <a class="ulink" href="https://mesonbuild.com/" title="https://mesonbuild.com/">Meson build system</a>.
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">  $ git clone https://gitlab.gnome.org/GNOME/mm-common.git
  $ cp -a mm-common/skeletonmm libsomethingmm
</pre></div>
<p class="para block">This provides a directory structure for the source .hg and .ccg files and the hand-written
  .h and .cc files, with <span class="filename" dir="ltr">meson.build</span> files that can specify the
  various files in use, in terms of Meson variables. The directory structure usually
  looks like this, after we have renamed the directories appropriately:
<div class="block list itemizedlist"><ul class="itemizedlist"><li class="li-first">
<p class="para block block-first"><span class="filename" dir="ltr">libsomethingmm</span>: The top-level directory.</p>
     <div class="block list itemizedlist"><ul class="itemizedlist"><li class="li-first">
<p class="para block block-first"><span class="filename" dir="ltr">libsomething</span>: Contains the main include file and the pkg-config .pc file.</p>
         <div class="block list itemizedlist"><ul class="itemizedlist">
<li class="li-first"><span class="para"><span class="filename" dir="ltr">src</span>: Contains .hg and .ccg source files.</span></li>
<li>
<span class="para"><span class="filename" dir="ltr">libsomethingmm</span>: Contains hand-written .h and .cc files.</span>
           </li>
</ul></div>
       </li></ul></div>
  </li></ul></div>
</p>
<p class="para block">As well as renaming the directories, we should rename some of the source
    files. For instance:
<div dir="ltr" class=" block programlisting block-indent block-first"><pre class="programlisting">$ for f in $(find libsomethingmm -depth -name '*skeleton*'); do \
    d="${f%/*}"; b="${f##*/}"; mv "$f" "$d/${b//skeleton/libsomething}"; \
  done
</pre></div>
A number of the skeleton files must still be filled in with project-specific content later.
</p>
<p class="para block">Note that files ending in <span class="filename" dir="ltr">.in</span> will be used to generate
    files with the same name but without the <span class="filename" dir="ltr">.in</span> suffix, by
    replacing some variables with actual values during the configure stage.</p>
<p class="para block">Generated files are saved in the build tree, which is separated from the
    source tree when <span class="command" dir="ltr">meson</span> and <span class="command" dir="ltr">ninja</span> are used.</p>
</div>
<div class="division sect2">
<a name="modifying-build-files"><!--modifying-build-files--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">G.1.2. </span>Modifying build files</span></h4></div>
<p class="para block block-first">Now we edit the files to adapt them to our needs. You might prefer to use a multiple-file
  search-replace utility for this, such as <span class="command" dir="ltr">regexxer</span>. Note that nearly all of the
  files provided with the skeleton source tree contain placeholder text. Thus, the substitutions
  should be performed globally, and not be limited to the Meson files.</p>
<p class="para block">All mentions of <span class="varname" dir="ltr">skeleton</span> should be replaced by the correct name of the C
  library you are wrapping, such as "something" or "libsomething". In the same manner, all
  instances of <span class="varname" dir="ltr">SKELETON</span> should be replaced by "SOMETHING" or "LIBSOMETHING", and
  all occurrences of <span class="varname" dir="ltr">Skeleton</span> changed to "Something".</p>
<p class="para block">Likewise, replace all instances of <span class="varname" dir="ltr">Joe Hacker</span> by the name of the intended
  copyright holder, which is probably you. Do the same for the <span class="varname" dir="ltr">joe@example.com</span>
  email address.</p>
<div class="autotoc"><ul>
<li>
<span class="label">G.1.2.1. </span><a class="xref" href="#modifying-top-meson.build" title="meson.build in the top-level directory">meson.build in the top-level directory</a>
</li>
<li>
<span class="label">G.1.2.2. </span><a class="xref" href="#modifying-other-meson.build" title="Other meson.build files">Other meson.build files</a>
</li>
<li>
<span class="label">G.1.2.3. </span><a class="xref" href="#creating-hg-ccg" title="Creating .hg and .ccg files">Creating .hg and .ccg files</a>
</li>
</ul></div>
<div class="division sect3">
<a name="modifying-top-meson.build"><!--modifying-top-meson.build--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">G.1.2.1. </span>meson.build in the top-level directory</span></h5></div>
<p class="para block block-first">
  <div class="block list itemizedlist"><ul class="itemizedlist">
<li class="li-first"><span class="para">It is common for binding modules to track the version number
        of the library they are wrapping. So, for instance, if the C library is
        at version 1.23.4, then the initial version of the binding module would
        be 1.23.0. However, avoid starting with an even minor version number as
        that usually indicates a stable release.</span></li>
<li><span class="para">In the <span class="function">project()</span> function, change the
    license and the C++ version, if necessary.</span></li>
<li><span class="para">You probably need to add more required modules than
    <span class="application">glibmm</span> and <span class="application">skeleton</span>
    (<span class="application">libsomething</span>).</span></li>
</ul></div>
</p>
</div>
<div class="division sect3">
<a name="modifying-other-meson.build"><!--modifying-other-meson.build--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">G.1.2.2. </span>Other meson.build files</span></h5></div>
<p class="para block block-first">Next we must adapt the other <span class="filename" dir="ltr">meson.build</span> files:
  <div class="block list itemizedlist"><ul class="itemizedlist">
<li class="li-first">
<p class="para block block-first"><span class="filename" dir="ltr">skeleton/meson.build</span>: Perhaps not much
    to change here more than the global name substitutions.</p>
    </li>
<li>
<p class="para block block-first"><span class="filename" dir="ltr">skeleton/skeletonmm/meson.build</span></p>
      <div class="block list variablelist"><dl class="variablelist">
<dt class="term dt-first"><span class="varname" dir="ltr">defs_basefiles</span></dt>
<dd><p class="para block block-first">If we have more .defs and docs.xml files,
          we add them here.</p></dd>
<dt class="term"><span class="varname" dir="ltr">hg_ccg_basenames</span></dt>
<dd><p class="para block block-first">We must mention all of our <span class="filename" dir="ltr">.hg</span> and
          <span class="filename" dir="ltr">.ccg</span> files here.</p></dd>
<dt class="term"><span class="varname" dir="ltr">extra_cc_files, extra_h_files</span></dt>
<dd><p class="para block block-first">Any additional hand-written <span class="filename" dir="ltr">.h</span> and
          <span class="filename" dir="ltr">.cc</span> source files go here.</p></dd>
</dl></div>
    </li>
</ul></div>
</p>
</div>
<div class="division sect3">
<a name="creating-hg-ccg"><!--creating-hg-ccg--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">G.1.2.3. </span>Creating .hg and .ccg files</span></h5></div>
<p class="para block block-first">We should now create our first <span class="filename" dir="ltr">.hg</span> and <span class="filename" dir="ltr">.ccg</span> files,
  to wrap one of the objects in the C library. One pair of example source files already exists:
  <span class="filename" dir="ltr">skeleton.ccg</span> and <span class="filename" dir="ltr">skeleton.hg</span>. Create copies of these
  files as necessary.</p>
<p class="para block">In the <a class="link" href="#sec-wrapping-hg-files" title="The .hg and .ccg files">.hg and .ccg files</a>
  section you can learn about the syntax used in these files.</p>
</div>
</div>
</div>
<div class="division sect1">
<a name="sec-wrapping-defs-files"><!--sec-wrapping-defs-files--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">G.2. </span>Generating the .defs files.</span></h3></div>
<p class="para block block-first">The <span class="filename" dir="ltr">.defs</span> files are text files, in a lisp format, that describe the API
  of a C library, including its
<div class="block list itemizedlist"><ul class="itemizedlist">
<li class="li-first"><span class="para">objects (GObjects, widgets, interfaces, boxed-types and plain structs)</span></li>
<li><span class="para">functions</span></li>
<li><span class="para">enums</span></li>
<li><span class="para">signals</span></li>
<li><span class="para">properties</span></li>
<li><span class="para">vfuncs</span></li>
</ul></div>
</p>
<p class="para block">At the moment, we have separate tools for generating different parts of
  these <span class="filename" dir="ltr">.defs</span>, so we split them up into separate files.
  For instance, in the <span class="filename" dir="ltr">gtk/src</span> directory of the <span class="application">gtkmm</span>
  sources, you will find these files:
    <div class="block list variablelist"><dl class="variablelist">
<dt class="term dt-first"><span class="filename" dir="ltr">gtk.defs</span></dt>
<dd><p class="para block block-first">Includes the other files.</p></dd>
<dt class="term"><span class="filename" dir="ltr">gtk_methods.defs</span></dt>
<dd><p class="para block block-first">Objects and functions.</p></dd>
<dt class="term"><span class="filename" dir="ltr">gtk_enums.defs</span></dt>
<dd><p class="para block block-first">Enumerations.</p></dd>
<dt class="term"><span class="filename" dir="ltr">gtk_signals.defs</span></dt>
<dd><p class="para block block-first">Signals and properties.</p></dd>
<dt class="term"><span class="filename" dir="ltr">gtk_vfuncs.defs</span></dt>
<dd><p class="para block block-first">vfuncs (function pointer member fields in structs), written by hand.</p></dd>
</dl></div>
</p>
<p class="para block">The <span class="filename" dir="ltr">skeletonmm/tools/generate_defs_and_docs.sh</span> script
generates all <span class="filename" dir="ltr">.defs</span> files and the <span class="filename" dir="ltr">*_docs.xml</span> file,
described in the <a class="link" href="#sec-wrapping-documentation" title="Documentation">Documentation</a> section.
</p>
<div class="autotoc"><ul>
<li>
<span class="label">G.2.1. </span><a class="xref" href="#generating-defs-methods" title="Generating the methods .defs">Generating the methods .defs</a>
</li>
<li>
<span class="label">G.2.2. </span><a class="xref" href="#generating-defs-enums" title="Generating the enums .defs">Generating the enums .defs</a>
</li>
<li>
<span class="label">G.2.3. </span><a class="xref" href="#generating-defs-signals-properties" title="Generating the signals and properties .defs">Generating the signals and properties .defs</a>
</li>
<li>
<span class="label">G.2.4. </span><a class="xref" href="#writing-defs-vfuncs" title="Writing the vfuncs .defs">Writing the vfuncs .defs</a>
</li>
</ul></div>
<div class="division sect2">
<a name="generating-defs-methods"><!--generating-defs-methods--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">G.2.1. </span>Generating the methods .defs</span></h4></div>
<p class="para block block-first">This <span class="filename" dir="ltr">.defs</span> file describes objects and their functions.
  It is generated by the <span class="command" dir="ltr">h2def.py</span> script which you can find in
  glibmm's <span class="filename" dir="ltr">tools/defs_gen</span> directory. For instance,
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">$ ./h2def.py /usr/include/gtk-4.0/gtk/*.h &gt; gtk_methods.defs
</pre></div>
</div>
<div class="division sect2">
<a name="generating-defs-enums"><!--generating-defs-enums--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">G.2.2. </span>Generating the enums .defs</span></h4></div>
<p class="para block block-first">This <span class="filename" dir="ltr">.defs</span> file describes enum types and their possible
  values. It is generated by the <span class="filename" dir="ltr">enum.pl</span> script which you can
  find in glibmm's <span class="filename" dir="ltr">tools</span> directory. For instance,
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">$ ./enum.pl /usr/include/gtk-4.0/gtk/*.h &gt; gtk_enums.defs
</pre></div>
</div>
<div class="division sect2">
<a name="generating-defs-signals-properties"><!--generating-defs-signals-properties--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">G.2.3. </span>Generating the signals and properties .defs</span></h4></div>
<p class="para block block-first">This <span class="filename" dir="ltr">.defs</span> file describes signals and properties. It is
  generated by the special <span class="filename" dir="ltr">generate_extra_defs</span> utility that is in every
  wrapping project, such as <span class="filename" dir="ltr">gtkmm/tools/extra_defs_gen/</span>.
  For instance
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">$ cd tools/extra_defs_gen
$ ./generate_extra_defs &gt; gtk_signals.defs
</pre></div>
<p class="para block">You must edit the source code of your own <span class="filename" dir="ltr">generate_extra_defs</span> tool
  in order to generate the <span class="filename" dir="ltr">.defs</span> for the GObject C types that you wish to
  wrap. In the skeleton source tree, the source file is named
  <span class="filename" dir="ltr">tools/extra_defs_gen/generate_defs_skeleton.cc</span>. If not done so
  already, the file should be renamed, with the basename of your new binding substituted
  for the <span class="varname" dir="ltr">skeleton</span> placeholder. The <span class="filename" dir="ltr">tools/extra_defs_gen/meson.build</span>
  file should also mention the new source filename.</p>
<p class="para block">Then edit the <span class="filename" dir="ltr">.cc</span> file to specify the correct types.
  For instance, your <span class="function">main()</span> function might look like this:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include &lt;glibmm_generate_extra_defs/generate_extra_defs.h&gt;
#include &lt;libsomething.h&gt;
#include &lt;iostream&gt;

int main(int, char**)
{
  something_init();

  std::cout &lt;&lt; get_defs(SOME_TYPE_WIDGET)
            &lt;&lt; get_defs(SOME_TYPE_STUFF);
  return 0;
}
</pre></div>
</div>
<div class="division sect2">
<a name="writing-defs-vfuncs"><!--writing-defs-vfuncs--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">G.2.4. </span>Writing the vfuncs .defs</span></h4></div>
<p class="para block block-first">
  This <span class="filename" dir="ltr">.defs</span> file describes virtual functions (vfuncs).
  It must be written by hand. There is the skeleton file
  <span class="filename" dir="ltr">skeleton/src/skeleton_vfunc.defs</span> to start from. You can also look
  at <span class="application">gtkmm</span>'s <span class="filename" dir="ltr">gtk/src/gtk_vfuncs.defs</span> file.
</p>
</div>
</div>
<div class="division sect1">
<a name="sec-wrapping-hg-files"><!--sec-wrapping-hg-files--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">G.3. </span>The .hg and .ccg files</span></h3></div>
<p class="para block block-first">The .hg and .ccg source files are very much like
        .h and .cc C++ source files, but they contain extra macros, such as
        <span class="function">_CLASS_GOBJECT()</span> and
        <span class="function">_WRAP_METHOD()</span>, from which
        <span class="command" dir="ltr">gmmproc</span> generates appropriate C++ source code,
        usually at the same position in the header. Any additional C++ source
        code will be copied verbatim into the corresponding
        .h or .cc file.</p>
<p class="para block">A .hg file will typically include some headers
        and then declare a class, using some macros to add API or behaviour to
        this class. For instance, <span class="application">gtkmm</span>'s <span class="filename" dir="ltr">button.hg</span> looks
        roughly like this:</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#include &lt;gtkmm/widget.h&gt;
#include &lt;gtkmm/actionable.h&gt;
_DEFS(gtkmm,gtk)
_PINCLUDE(gtkmm/private/widget_p.h)

namespace Gtk
{

class Button
  : public Widget,
    public Actionable
{
  _CLASS_GTKOBJECT(Button, GtkButton, GTK_BUTTON, Gtk::Widget, GtkWidget)
  _IMPLEMENTS_INTERFACE(Actionable)
public:

  _CTOR_DEFAULT
  explicit Button(const Glib::ustring&amp; label, bool mnemonic = false);

  _WRAP_METHOD(void set_label(const Glib::ustring&amp; label), gtk_button_set_label)

  ...

  _WRAP_SIGNAL(void clicked(), "clicked")

  ...

  _WRAP_PROPERTY("label", Glib::ustring)
};

} // namespace Gtk
</pre></div>
<p class="para block">The macros in this example do the following:
<div class="block list variablelist"><dl class="variablelist">
<dt class="term dt-first"><span class="function">_DEFS()</span></dt>
<dd><p class="para block block-first">Specifies the destination directory for generated sources, and the name of the main .defs file that <span class="command" dir="ltr">gmmproc</span> should parse.</p></dd>
<dt class="term"><span class="function">_PINCLUDE()</span></dt>
<dd><p class="para block block-first">Tells <span class="command" dir="ltr">gmmproc</span> to include a header in the generated <span class="filename" dir="ltr">private/button_p.h</span> file.</p></dd>
<dt class="term"><span class="function">_CLASS_GTKOBJECT()</span></dt>
<dd><p class="para block block-first">Tells <span class="command" dir="ltr">gmmproc</span> to add some typedefs, constructors, and standard methods to this class, as appropriate when wrapping a widget.</p></dd>
<dt class="term"><span class="function">_IMPLEMENTS_INTERFACE()</span></dt>
<dd><p class="para block block-first">Tells <span class="command" dir="ltr">gmmproc</span> to add initialization code for the interface.</p></dd>
<dt class="term"><span class="function">_CTOR_DEFAULT</span></dt>
<dd><p class="para block block-first">Adds a default constructor.</p></dd>
<dt class="term">
<span class="function">_WRAP_METHOD()</span>,
            <span class="function">_WRAP_SIGNAL()</span>, and
            <span class="function">_WRAP_PROPERTY()</span>
</dt>
<dd><p class="para block block-first">Add methods to wrap parts of the C API.</p></dd>
</dl></div>
</p>
<p class="para block">The .h and .cc files will be generated from the .hg and .ccg files by
    processing them with <span class="command" dir="ltr">gmmproc</span> like so, though this happens
    automatically when using the above build structure:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">$ cd gtk/src
$ /usr/lib/glibmm-2.68/proc/gmmproc -I ../../tools/m4 --defs . button . ./../gtkmm
</pre></div>
<p class="para block">Notice that we provided <span class="command" dir="ltr">gmmproc</span> with the path to the
    .m4 convert files, the path to the .defs file, the name of a .hg file, the
    source directory, and the destination directory.</p>
<p class="para block">You should avoid including the C header from your C++ header, to avoid
    polluting the global namespace, and to avoid exporting unnecessary public
    API. But you will need to include the necessary C headers from your
    .ccg file.</p>
<p class="para block">The macros are explained in more detail in the following sections.</p>
<div class="autotoc"><ul>
<li>
<span class="label">G.3.1. </span><a class="xref" href="#gmmproc-m4-conversions" title="m4 Conversions">m4 Conversions</a>
</li>
<li>
<span class="label">G.3.2. </span><a class="xref" href="#gmmproc-m4-initializations" title="m4 Initializations">m4 Initializations</a>
</li>
<li>
<span class="label">G.3.3. </span><a class="xref" href="#gmmproc-class-macros" title="Class macros">Class macros</a>
</li>
<li>
<span class="label">G.3.4. </span><a class="xref" href="#gmmproc-constructor-macros" title="Constructor macros">Constructor macros</a>
</li>
<li>
<span class="label">G.3.5. </span><a class="xref" href="#gmmproc-suppressing-macros" title="Macros that suppress generation of some code">Macros that suppress generation of some code</a>
</li>
<li>
<span class="label">G.3.6. </span><a class="xref" href="#gmmproc-method-macros" title="Method macros">Method macros</a>
</li>
<li>
<span class="label">G.3.7. </span><a class="xref" href="#gmmproc-other-macros" title="Other macros">Other macros</a>
</li>
<li>
<span class="label">G.3.8. </span><a class="xref" href="#gmmproc-parameter-processing" title="gmmproc Parameter Processing">gmmproc Parameter Processing</a>
</li>
<li>
<span class="label">G.3.9. </span><a class="xref" href="#gmmproc-basic-types" title="Basic Types">Basic Types</a>
</li>
</ul></div>
<div class="division sect2">
<a name="gmmproc-m4-conversions"><!--gmmproc-m4-conversions--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">G.3.1. </span>m4 Conversions</span></h4></div>
<p class="para block block-first">The macros that you use in the .hg and .ccg files often need to know how
to convert a C++ type to a C type, or vice-versa. <span class="command" dir="ltr">gmmproc</span> takes this information
from an .m4 file in your <span class="literal" dir="ltr">tools/m4/</span> or <span class="literal" dir="ltr">codegen/m4/</span> directory.
This allows it to call a C function in the implementation of your C++ method,
passing the appropriate parameters to that C functon. For instance, this
tells <span class="command" dir="ltr">gmmproc</span> how to convert a <span class="classname" dir="ltr">GtkTreeView</span>
pointer to a <span class="classname" dir="ltr">Gtk::TreeView</span> pointer:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">_CONVERSION(`GtkTreeView*',`TreeView*',`Glib::wrap($3)')
</pre></div>
<p class="para block"><span class="literal" dir="ltr">$3</span> will be replaced by the parameter name when this
conversion is used by <span class="command" dir="ltr">gmmproc</span>.
</p>
<p class="para block">
Some extra macros make this easier and consistent. Look in <span class="application">gtkmm</span>'s .m4 files
for examples. For instance:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">_CONVERSION(`PrintSettings&amp;',`GtkPrintSettings*',__FR2P)
_CONVERSION(`const PrintSettings&amp;',`GtkPrintSettings*',__FCR2P)
_CONVERSION(`const Glib::RefPtr&lt;Printer&gt;&amp;',`GtkPrinter*',__CONVERT_REFPTR_TO_P($3))
</pre></div>
</div>
<div class="division sect2">
<a name="gmmproc-m4-initializations"><!--gmmproc-m4-initializations--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">G.3.2. </span>m4 Initializations</span></h4></div>
<p class="para block block-first">
  Often when wrapping methods, it is desirable to store the return of the C
  function in what is called an output parameter.  In this case, the C++ method
  returns <span class="type" dir="ltr">void</span> but an output parameter in which to store the value
  of the C function is included in the argument list of the C++ method.
  <span class="command" dir="ltr">gmmproc</span> allows such functionality, but appropriate initialization macros must
  be included to tell <span class="command" dir="ltr">gmmproc</span> how to initialize the C++ parameter from the
  return of the C function.
</p>
<p class="para block">
  For example, if there was a C function that returned a
  <span class="type" dir="ltr">GtkWidget*</span> and for some reason, instead of having the C++ method
  also return the widget, it was desirable to have the C++ method place the
  widget in a specified output parameter, an initialization macro such as the
  following would be necessary:
</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">_INITIALIZATION(`Gtk::Widget&amp;',`GtkWidget*',`$3 = Glib::wrap($4)')
</pre></div>
<p class="para block">
  <span class="literal" dir="ltr">$3</span> will be replaced by the output parameter name of the
  C++ method and <span class="literal" dir="ltr">$4</span> will be replaced by the return of the C
  function when this initialization is used by <span class="command" dir="ltr">gmmproc</span>.  For convenience,
  <span class="literal" dir="ltr">$1</span> will also be replaced by the C++ type without the
  ampersand (&amp;) and <span class="literal" dir="ltr">$2</span> will be replaced by the C type.
</p>
</div>
<div class="division sect2">
<a name="gmmproc-class-macros"><!--gmmproc-class-macros--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">G.3.3. </span>Class macros</span></h4></div>
<p class="para block block-first">The class macro declares the class itself and its relationship with the
    underlying C type. It generates some internal constructors, the member
    <span class="varname" dir="ltr">gobject_</span>, typedefs, the <span class="function">gobj()</span>
    accessors, type registration, and the <span class="function">Glib::wrap()</span>
    method, among other things.</p>
<p class="para block">Other macros, such as <span class="function">_WRAP_METHOD()</span> and
    <span class="function">_WRAP_SIGNAL()</span> may only be used after a call to a
    <span class="function">_CLASS_*</span> macro.</p>
<div class="autotoc"><ul>
<li>
<span class="label">G.3.3.1. </span><a class="xref" href="#gmmproc-class-gobject" title="_CLASS_GOBJECT">_CLASS_GOBJECT</a>
</li>
<li>
<span class="label">G.3.3.2. </span><a class="xref" href="#gmmproc-class-gtkobject" title="_CLASS_GTKOBJECT">_CLASS_GTKOBJECT</a>
</li>
<li>
<span class="label">G.3.3.3. </span><a class="xref" href="#gmmproc-class-boxedtype" title="_CLASS_BOXEDTYPE">_CLASS_BOXEDTYPE</a>
</li>
<li>
<span class="label">G.3.3.4. </span><a class="xref" href="#gmmproc-class-boxedtype-static" title="_CLASS_BOXEDTYPE_STATIC">_CLASS_BOXEDTYPE_STATIC</a>
</li>
<li>
<span class="label">G.3.3.5. </span><a class="xref" href="#gmmproc-class-opaque-copyable" title="_CLASS_OPAQUE_COPYABLE">_CLASS_OPAQUE_COPYABLE</a>
</li>
<li>
<span class="label">G.3.3.6. </span><a class="xref" href="#gmmproc-class-opaque-refcounted" title="_CLASS_OPAQUE_REFCOUNTED">_CLASS_OPAQUE_REFCOUNTED</a>
</li>
<li>
<span class="label">G.3.3.7. </span><a class="xref" href="#gmmproc-class-generic" title="_CLASS_GENERIC">_CLASS_GENERIC</a>
</li>
<li>
<span class="label">G.3.3.8. </span><a class="xref" href="#gmmproc-class-interface" title="_CLASS_INTERFACE">_CLASS_INTERFACE</a>
</li>
</ul></div>
<div class="division sect3">
<a name="gmmproc-class-gobject"><!--gmmproc-class-gobject--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">G.3.3.1. </span>_CLASS_GOBJECT</span></h5></div>
<p class="para block block-first">This macro declares a wrapper for a type that is derived from
    <span class="classname" dir="ltr">GObject</span>, but whose wrapper is not derived from
    <span class="classname" dir="ltr">Gtk::Object</span>.</p>
<p class="para block"><span class="function">_CLASS_GOBJECT( C++ class, C class, C casting macro, C++ base class, C base class )</span></p>
<p class="para block">For instance, from <span class="filename" dir="ltr">adjustment.hg</span>:</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">_CLASS_GOBJECT(Adjustment, GtkAdjustment, GTK_ADJUSTMENT, Glib::Object, GObject)
</pre></div>
</div>
<div class="division sect3">
<a name="gmmproc-class-gtkobject"><!--gmmproc-class-gtkobject--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">G.3.3.2. </span>_CLASS_GTKOBJECT</span></h5></div>
<p class="para block block-first">This macro declares a wrapper for a type whose wrapper is derived from
    <span class="classname" dir="ltr">Gtk::Object</span>, such as a widget or dialog.</p>
<p class="para block"><span class="function">_CLASS_GTKOBJECT( C++ class, C class, C casting macro, C++ base class, C base class )</span></p>
<p class="para block">For instance, from <span class="filename" dir="ltr">button.hg</span>:</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">_CLASS_GTKOBJECT(Button, GtkButton, GTK_BUTTON, Gtk::Widget, GtkWidget)
</pre></div>
<p class="para block">You will typically use this macro when the class already derives from
    <span class="classname" dir="ltr">Gtk::Object</span>. For instance, you will use it when wrapping
    a GTK Widget, because <span class="classname" dir="ltr">Gtk::Widget</span> derives from
    <span class="classname" dir="ltr">Gtk::Object</span>.</p>
<p class="para block">You might also derive non-widget classes from
    <span class="classname" dir="ltr">Gtk::Object</span> so they can be used without
    <span class="classname" dir="ltr">Glib::RefPtr</span>. For instance, they could then be
    instantiated with <span class="function">Gtk::make_managed()</span> or on the stack
    as a member variable. This is convenient, but you should use this only when
    you are sure that true reference-counting is not needed. We consider it
    useful for widgets.</p>
</div>
<div class="division sect3">
<a name="gmmproc-class-boxedtype"><!--gmmproc-class-boxedtype--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">G.3.3.3. </span>_CLASS_BOXEDTYPE</span></h5></div>
<p class="para block block-first">This macro declares a wrapper for a non-<span class="classname" dir="ltr">GObject</span>
    struct, registered with
    <span class="function">g_boxed_type_register_static()</span>.</p>
<p class="para block"><span class="function">_CLASS_BOXEDTYPE( C++ class, C class, new function, copy function, free function )</span></p>
<p class="para block">For instance, from <span class="classname" dir="ltr">Gdk::RGBA</span>:</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">_CLASS_BOXEDTYPE(RGBA, GdkRGBA, NONE, gdk_rgba_copy, gdk_rgba_free)
</pre></div>
</div>
<div class="division sect3">
<a name="gmmproc-class-boxedtype-static"><!--gmmproc-class-boxedtype-static--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">G.3.3.4. </span>_CLASS_BOXEDTYPE_STATIC</span></h5></div>
<p class="para block block-first">This macro declares a wrapper for a simple assignable struct such as
    <span class="classname" dir="ltr">GdkRectangle</span>. It is similar to
    <span class="function">_CLASS_BOXEDTYPE</span>, but the C struct is not allocated
    dynamically.</p>
<p class="para block"><span class="function">_CLASS_BOXEDTYPE_STATIC( C++ class, C class )</span></p>
<p class="para block">For instance, for <span class="classname" dir="ltr">Gdk::Rectangle</span>:</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">_CLASS_BOXEDTYPE_STATIC(Rectangle, GdkRectangle)
</pre></div>
</div>
<div class="division sect3">
<a name="gmmproc-class-opaque-copyable"><!--gmmproc-class-opaque-copyable--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">G.3.3.5. </span>_CLASS_OPAQUE_COPYABLE</span></h5></div>
<p class="para block block-first">This macro declares a wrapper for an opaque struct that has copy and free
    functions. The new, copy and free functions will be used to instantiate the
    default constructor, copy constructor and destructor.</p>
<p class="para block"><span class="function">_CLASS_OPAQUE_COPYABLE( C++ class, C class, new function, copy function, free function )</span></p>
<p class="para block">For instance, from <span class="classname" dir="ltr">Glib::VariantType</span>:</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">_CLASS_OPAQUE_COPYABLE(VariantType, GVariantType, NONE, g_variant_type_copy, g_variant_type_free)
</pre></div>
</div>
<div class="division sect3">
<a name="gmmproc-class-opaque-refcounted"><!--gmmproc-class-opaque-refcounted--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">G.3.3.6. </span>_CLASS_OPAQUE_REFCOUNTED</span></h5></div>
<p class="para block block-first">This macro declares a wrapper for a reference-counted opaque struct. The
    C++ wrapper cannot be directly instantiated and can only be used with
    <span class="classname" dir="ltr">Glib::RefPtr</span>.</p>
<p class="para block"><span class="function">_CLASS_OPAQUE_REFCOUNTED( C++ class, C class, new function, ref function, unref function )</span></p>
<p class="para block">For instance, for <span class="classname" dir="ltr">Gtk::CssSection</span>:</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">_CLASS_OPAQUE_REFCOUNTED(CssSection, GtkCssSection, NONE, gtk_css_section_ref, gtk_css_section_unref)
</pre></div>
</div>
<div class="division sect3">
<a name="gmmproc-class-generic"><!--gmmproc-class-generic--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">G.3.3.7. </span>_CLASS_GENERIC</span></h5></div>
<p class="para block block-first">This macro can be used to wrap structs which don't fit into any
    specialized category.</p>
<p class="para block"><span class="function">_CLASS_GENERIC( C++ class, C class )</span></p>
<p class="para block">For instance, for <span class="classname" dir="ltr">Gdk::TimeCoord</span>:</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">_CLASS_GENERIC(TimeCoord, GdkTimeCoord)
</pre></div>
</div>
<div class="division sect3">
<a name="gmmproc-class-interface"><!--gmmproc-class-interface--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">G.3.3.8. </span>_CLASS_INTERFACE</span></h5></div>
<p class="para block block-first">This macro declares a wrapper for a type that is derived from
    <span class="classname" dir="ltr">GTypeInterface</span>.
</p>
<p class="para block"><span class="function">_CLASS_INTERFACE( C++ class, C class, C casting macro, C interface struct, Base C++ class (optional), Base C class (optional) )</span></p>
<p class="para block">
For instance, from <span class="filename" dir="ltr">celleditable.hg</span>:</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">_CLASS_INTERFACE(CellEditable, GtkCellEditable, GTK_CELL_EDITABLE, GtkCellEditableIface)
</pre></div>
<p class="para block">Two extra optional parameters were once added, for the case that the interface derives
from another interface, which was believed to be the case when the GInterface has another
GInterface as a prerequisite. This is a misunderstanding, though.
When GInterface A has GInterface B as a prerequisite, it means that every class
that implements A shall also implement B.
For instance, from <span class="filename" dir="ltr">loadableicon.hg</span> in glibmm-2.4:</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">_CLASS_INTERFACE(LoadableIcon, GLoadableIcon, G_LOADABLE_ICON, GLoadableIconIface, Icon, GIcon)
</pre></div>
</div>
</div>
<div class="division sect2">
<a name="gmmproc-constructor-macros"><!--gmmproc-constructor-macros--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">G.3.4. </span>Constructor macros</span></h4></div>
<p class="para block block-first">The <span class="function">_CTOR_DEFAULT()</span> and
    <span class="function">_WRAP_CTOR()</span> macros add constructors, wrapping the
    specified <span class="function">*_new()</span> C functions. These macros assume that
    the C object has properties with the same names as the function parameters,
    as is usually the case, so that it can supply the parameters directly to a
    <span class="function">g_object_new()</span> call. These constructors never actually
    call the <span class="function">*_new()</span> C functions,
    because <span class="application">gtkmm</span> must actually instantiate derived GTypes, and the
    <span class="function">*_new()</span> C functions are meant only as convenience
    functions for C programmers.</p>
<p class="para block">When using <span class="function">_CLASS_GOBJECT()</span>, the constructors should
    be protected (rather than public) and each constructor should have a
    corresponding <span class="function">_WRAP_CREATE()</span> in the public section.
    This prevents the class from being instantiated without using a
    <span class="classname" dir="ltr">RefPtr</span>. For instance:</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">class TextMark : public Glib::Object
{
  _CLASS_GOBJECT(TextMark, GtkTextMark, GTK_TEXT_MARK, Glib::Object, GObject)

protected:
  _WRAP_CTOR(TextMark(const Glib::ustring&amp; name, bool left_gravity = true), gtk_text_mark_new)

public:
  _WRAP_CREATE(const Glib::ustring&amp; name, bool left_gravity = true)
</pre></div>
<div class="autotoc"><ul>
<li>
<span class="label">G.3.4.1. </span><a class="xref" href="#gmmproc-ctor-default" title="_CTOR_DEFAULT">_CTOR_DEFAULT</a>
</li>
<li>
<span class="label">G.3.4.2. </span><a class="xref" href="#gmmproc-wrap-ctor" title="_WRAP_CTOR">_WRAP_CTOR</a>
</li>
<li>
<span class="label">G.3.4.3. </span><a class="xref" href="#gmmproc-ctor-manual" title="Hand-coding constructors">Hand-coding constructors</a>
</li>
</ul></div>
<div class="division sect3">
<a name="gmmproc-ctor-default"><!--gmmproc-ctor-default--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">G.3.4.1. </span>_CTOR_DEFAULT</span></h5></div>
<p class="para block block-first">This macro creates a default constructor with no arguments.
</p>
</div>
<div class="division sect3">
<a name="gmmproc-wrap-ctor"><!--gmmproc-wrap-ctor--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">G.3.4.2. </span>_WRAP_CTOR</span></h5></div>
<p class="para block block-first">This macro creates a constructor with arguments, equivalent to a
  <span class="function">*_new()</span> C function. It won't actually call the
  <span class="function">*_new()</span> function, but will simply create an equivalent
  constructor with the same argument types. It takes a C++ constructor
  signature, and a C function name.
</p>
<p class="para block">It also takes an optional extra argument:
  <div class="block list variablelist"><dl class="variablelist">
<dt class="term dt-first">errthrow</dt>
<dd>
          <p class="para block block-first">This tells <span class="command" dir="ltr">gmmproc</span> that the C <span class="function">*_new()</span> has
            a final <span class="type" dir="ltr">GError**</span> parameter which should be ignored.</p>
        </dd>
</dl></div>
</p>
</div>
<div class="division sect3">
<a name="gmmproc-ctor-manual"><!--gmmproc-ctor-manual--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">G.3.4.3. </span>Hand-coding constructors</span></h5></div>
<p class="para block block-first">When a constructor must be partly hand written because, for instance, the
    <span class="function">*_new()</span> C function's parameters do not correspond
    directly to object properties, or because the <span class="function">*_new()</span> C
    function does more than call <span class="function">g_object_new()</span>, the
    <span class="function">_CONSTRUCT()</span> macro may be used in the
    .ccg file to save some work. The <span class="function">_CONSTRUCT</span> macro takes
    a series of property names and values. For instance, from
    <span class="filename" dir="ltr">button.ccg</span>:</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">Button::Button(const Glib::ustring&amp; label, bool mnemonic)
:
  _CONSTRUCT("label", label.c_str(), "use_underline", gboolean(mnemonic))
{}
</pre></div>
</div>
</div>
<div class="division sect2">
<a name="gmmproc-suppressing-macros"><!--gmmproc-suppressing-macros--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">G.3.5. </span>Macros that suppress generation of some code</span></h4></div>
<p class="para block block-first">Some macros suppress the generation of some code when they are used after
a <span class="function">_CLASS_*</span> macro. Some suppress the definition in the
generated .cc file, others suppress both the declaration in the .h file and
the definition in the .cc file.
</p>
<div class="autotoc"><ul>
<li>
<span class="label">G.3.5.1. </span><a class="xref" href="#gmmproc-custom-default-ctor" title="_CUSTOM_DEFAULT_CTOR">_CUSTOM_DEFAULT_CTOR</a>
</li>
<li>
<span class="label">G.3.5.2. </span><a class="xref" href="#gmmproc-custom-ctor-cast" title="_CUSTOM_CTOR_CAST">_CUSTOM_CTOR_CAST</a>
</li>
<li>
<span class="label">G.3.5.3. </span><a class="xref" href="#gmmproc-custom-dtor" title="_CUSTOM_DTOR">_CUSTOM_DTOR</a>
</li>
<li>
<span class="label">G.3.5.4. </span><a class="xref" href="#gmmproc-custom-move-operations" title="_CUSTOM_MOVE_OPERATIONS">_CUSTOM_MOVE_OPERATIONS</a>
</li>
<li>
<span class="label">G.3.5.5. </span><a class="xref" href="#gmmproc-custom-wrap-new" title="_CUSTOM_WRAP_NEW">_CUSTOM_WRAP_NEW</a>
</li>
<li>
<span class="label">G.3.5.6. </span><a class="xref" href="#gmmproc-custom-wrap-function" title="_CUSTOM_WRAP_FUNCTION">_CUSTOM_WRAP_FUNCTION</a>
</li>
<li>
<span class="label">G.3.5.7. </span><a class="xref" href="#gmmproc-no-wrap-function" title="_NO_WRAP_FUNCTION">_NO_WRAP_FUNCTION</a>
</li>
</ul></div>
<div class="division sect3">
<a name="gmmproc-custom-default-ctor"><!--gmmproc-custom-default-ctor--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">G.3.5.1. </span>_CUSTOM_DEFAULT_CTOR</span></h5></div>
<p class="para block block-first">Suppresses declaration and definition of default constructor in
<span class="function">_CLASS_BOXEDTYPE</span>, <span class="function">_CLASS_BOXEDTYPE_STATIC</span>
and <span class="function">_CLASS_OPAQUE_COPYABLE</span>.
</p>
</div>
<div class="division sect3">
<a name="gmmproc-custom-ctor-cast"><!--gmmproc-custom-ctor-cast--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">G.3.5.2. </span>_CUSTOM_CTOR_CAST</span></h5></div>
<p class="para block block-first">Suppresses declaration and definition of the constructor that takes a pointer
to the wrapped C object in <span class="function">_CLASS_BOXEDTYPE</span> and
<span class="function">_CLASS_BOXEDTYPE_STATIC</span>.
</p>
<p class="para block">Suppresses definition of the constructor that takes a pointer to the
wrapped C object in <span class="function">_CLASS_INTERFACE</span> and
<span class="function">_CLASS_OPAQUE_COPYABLE</span>.
</p>
<p class="para block">Suppresses definition of the constructor that takes a pointer to the
wrapped C object and the constructor that takes construct_params in
<span class="function">_CLASS_GOBJECT</span> and <span class="function">_CLASS_GTKOBJECT</span>.
</p>
</div>
<div class="division sect3">
<a name="gmmproc-custom-dtor"><!--gmmproc-custom-dtor--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">G.3.5.3. </span>_CUSTOM_DTOR</span></h5></div>
<p class="para block block-first">Suppresses definition of destructor in
<span class="function">_CLASS_GOBJECT</span> and <span class="function">_CLASS_GTKOBJECT</span>.
</p>
</div>
<div class="division sect3">
<a name="gmmproc-custom-move-operations"><!--gmmproc-custom-move-operations--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">G.3.5.4. </span>_CUSTOM_MOVE_OPERATIONS</span></h5></div>
<p class="para block block-first">Suppresses declaration and definition of move constructor and move
assignment operator in <span class="function">_CLASS_GOBJECT</span> and
<span class="function">_CLASS_GTKOBJECT</span>.
</p>
<p class="para block">For example:</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">class Derived : public Glib::Object
{
  _CLASS_GOBJECT(Derived, GDerived, G_DERIVED, Glib::Object, GObject)

  _CUSTOM_MOVE_OPERATIONS

public:
  Derived(Derived&amp;&amp; src) noexcept;
  Derived&amp; operator=(Derived&amp;&amp; src) noexcept;
  // ...
};
</pre></div>
</div>
<div class="division sect3">
<a name="gmmproc-custom-wrap-new"><!--gmmproc-custom-wrap-new--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">G.3.5.5. </span>_CUSTOM_WRAP_NEW</span></h5></div>
<p class="para block block-first">Suppresses definition of <span class="function">Glib::wrap_new()</span> function in
<span class="function">_CLASS_GOBJECT</span>.
</p>
</div>
<div class="division sect3">
<a name="gmmproc-custom-wrap-function"><!--gmmproc-custom-wrap-function--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">G.3.5.6. </span>_CUSTOM_WRAP_FUNCTION</span></h5></div>
<p class="para block block-first">Suppresses definition of <span class="function">Glib::wrap()</span> function in
<span class="function">_CLASS_GOBJECT</span> and <span class="function">_CLASS_GTKOBJECT</span>.
</p>
</div>
<div class="division sect3">
<a name="gmmproc-no-wrap-function"><!--gmmproc-no-wrap-function--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">G.3.5.7. </span>_NO_WRAP_FUNCTION</span></h5></div>
<p class="para block block-first">Suppresses declaration and definition of <span class="function">Glib::wrap()</span>
function in <span class="function">_CLASS_GOBJECT</span>, <span class="function">_CLASS_BOXEDTYPE</span>,
<span class="function">_CLASS_BOXEDTYPE_STATIC</span>, <span class="function">_CLASS_OPAQUE_COPYABLE</span>,
<span class="function">_CLASS_INTERFACE</span> and <span class="function">_CLASS_GTKOBJECT</span>.
</p>
</div>
</div>
<div class="division sect2">
<a name="gmmproc-method-macros"><!--gmmproc-method-macros--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">G.3.6. </span>Method macros</span></h4></div>
<div class="autotoc"><ul>
<li>
<span class="label">G.3.6.1. </span><a class="xref" href="#gmmproc-wrap-method" title="_WRAP_METHOD">_WRAP_METHOD</a>
</li>
<li>
<span class="label">G.3.6.2. </span><a class="xref" href="#gmmproc-wrap-method-docs-only" title="_WRAP_METHOD_DOCS_ONLY">_WRAP_METHOD_DOCS_ONLY</a>
</li>
<li>
<span class="label">G.3.6.3. </span><a class="xref" href="#gmmproc-ignore" title="_IGNORE, _IGNORE_SIGNAL, _IGNORE_PROPERTY">_IGNORE, _IGNORE_SIGNAL, _IGNORE_PROPERTY</a>
</li>
<li>
<span class="label">G.3.6.4. </span><a class="xref" href="#gmmproc-wrap-signal" title="_WRAP_SIGNAL">_WRAP_SIGNAL</a>
</li>
<li>
<span class="label">G.3.6.5. </span><a class="xref" href="#gmmproc-wrap-property" title="_WRAP_PROPERTY">_WRAP_PROPERTY</a>
</li>
<li>
<span class="label">G.3.6.6. </span><a class="xref" href="#gmmproc-wrap-vfunc" title="_WRAP_VFUNC">_WRAP_VFUNC</a>
</li>
</ul></div>
<div class="division sect3">
<a name="gmmproc-wrap-method"><!--gmmproc-wrap-method--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">G.3.6.1. </span>_WRAP_METHOD</span></h5></div>
<p class="para block block-first">This macro generates the C++ method to wrap a C function.</p>
<p class="para block"><span class="function">_WRAP_METHOD( C++ method signature, C function name)</span></p>
<p class="para block">For instance, from <span class="filename" dir="ltr">entry.hg</span>:</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">_WRAP_METHOD(void set_text(const Glib::ustring&amp; text), gtk_entry_set_text)
</pre></div>
<p class="para block">The C function (e.g. <span class="function">gtk_entry_set_text</span>) is described
    more fully in the .defs file, and the <span class="filename" dir="ltr">convert*.m4</span> files
    contain the necessary conversion from the C++ parameter type to the C
    parameter type. This macro also generates doxygen documentation comments
    based on the <span class="filename" dir="ltr">*_docs.xml</span> and
    <span class="filename" dir="ltr">*_docs_override.xml</span> files.</p>
<p class="para block">There are some optional extra arguments:
<div class="block list variablelist"><dl class="variablelist">
<dt class="term dt-first">refreturn</dt>
<dd>
            <p class="para block block-first">Do an extra <span class="function">reference()</span> on the return value,
                in case the C function does not provide a reference.</p>
        </dd>
<dt class="term">errthrow ["&lt;exceptions&gt;"]</dt>
<dd>
            <p class="para block block-first">Use the last GError** parameter of the C function to
                throw an exception.
                The optional "&lt;exceptions&gt;" is a comma-separated list
                of exceptions that can be thrown. It determines which @throws
                Doxygen commands are added to the documentation. Default value
                is <span class="classname" dir="ltr">Glib::Error</span>. If you want a comma in
                the description of an exception, precede it by a backslash. Example:
                <span class="code" dir="ltr">errthrow "Glib::OptionError Hello\, world, Glib::ConvertError"</span></p>
        </dd>
<dt class="term">deprecated ["&lt;text&gt;"]</dt>
<dd>
            <p class="para block block-first">Puts the generated code in #ifdef blocks. Text about the
                deprecation can be specified as an optional
                parameter.</p>
        </dd>
<dt class="term">constversion</dt>
<dd>
            <p class="para block block-first">Just call the non-const version of the same function,
                instead of generating almost duplicate code.</p>
        </dd>
<dt class="term">newin "&lt;version&gt;"</dt>
<dd>
            <p class="para block block-first">Adds a @newin Doxygen command to the documentation, or replaces
                the @newin command generated from the C documentation.</p>
        </dd>
<dt class="term">ifdef &lt;identifier&gt;</dt>
<dd>
            <p class="para block block-first">Puts the generated code in #ifdef blocks.</p>
        </dd>
<dt class="term">slot_name &lt;parameter_name&gt;</dt>
<dd>
          <p class="para block block-first">Specifies the name of the slot parameter of the method, if it
            has one.  This enables <span class="command" dir="ltr">gmmproc</span> to generate code
            to copy the slot and pass the copy on to the C function in its
            final <span class="literal" dir="ltr">gpointer user_data</span> parameter.  The
            <span class="literal" dir="ltr">slot_callback</span> option must also be used to
            specify the name of the glue callback function to also pass on to
            the C function.</p>
        </dd>
<dt class="term">slot_callback &lt;function_name&gt;</dt>
<dd>
          <p class="para block block-first">Used in conjunction with the <span class="literal" dir="ltr">slot_name</span>
            option to specify the name of the glue callback function that
            handles extracting the slot and then calling it.  The address of
            this callback is also passed on to the C function that the method
            wraps.</p>
        </dd>
<dt class="term">no_slot_copy</dt>
<dd>
          <p class="para block block-first">Tells <span class="command" dir="ltr">gmmproc</span> not to pass a copy of the slot
            to the C function, if the method has one.  Instead the slot itself
            is passed.  The slot parameter name and the glue callback function
            must have been specified with the <span class="literal" dir="ltr">slot_name</span> and
            <span class="literal" dir="ltr">slot_callback</span> options respectively.</p>
        </dd>
</dl></div>
</p>
<p class="para block">Selecting which C++ types should be used is also important when wrapping
  C API.  Though it's usually obvious what C++ types should be used in the C++
  method, here are some hints:
<div class="block list itemizedlist"><ul class="itemizedlist">
<li class="li-first"><span class="para">Objects used via <span class="classname" dir="ltr">RefPtr</span>: Pass the
            <span class="classname" dir="ltr">RefPtr</span> as a const reference. For instance,
            <span class="code" dir="ltr">const Glib::RefPtr&lt;Gtk::FileFilter&gt;&amp;
                filter</span>.</span></li>
<li><span class="para">Const Objects used via <span class="classname" dir="ltr">RefPtr</span>: If the
            object should not be changed by the function, then make sure that
            the object is const, even if the <span class="classname" dir="ltr">RefPtr</span> is
            already const. For instance, <span class="code" dir="ltr">const Glib::RefPtr&lt;const
            Gtk::FileFilter&gt;&amp; filter</span>.</span></li>
<li><span class="para">Wrapping <span class="classname" dir="ltr">GList*</span> and
        <span class="classname" dir="ltr">GSList*</span> parameters: First, you need to discover
        what objects are contained in the list's data field for each item,
        usually by reading the documentation for the C function. The list can
        then be wrapped by a <span class="classname" dir="ltr">std::vector</span> type.
        For instance, <span class="code" dir="ltr">std::vector&lt;Glib::RefPtr&lt;Gdk::Pixbuf&gt;&gt;</span>.
        You may need to define a Traits type to specify how the C
        and C++ types should be converted.</span></li>
<li><span class="para">Wrapping <span class="classname" dir="ltr">GList*</span> and
        <span class="classname" dir="ltr">GSList*</span> return types: You must discover whether
        the caller should free the list and whether it should release the items
        in the list, again by reading the documentation of the C function. With
        this information you can choose the ownership (none, shallow or deep)
        for the m4 conversion rule, which you should probably put directly into
        the .hg file because the ownership depends on the
        function rather than the type. For instance:
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">#m4 _CONVERSION(`GSList*',`std::vector&lt;Widget*&gt;',`Glib::SListHandler&lt;Widget*&gt;::slist_to_vector($3, Glib::OWNERSHIP_SHALLOW)')</pre></div></span></li>
</ul></div>
</p>
</div>
<div class="division sect3">
<a name="gmmproc-wrap-method-docs-only"><!--gmmproc-wrap-method-docs-only--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">G.3.6.2. </span>_WRAP_METHOD_DOCS_ONLY</span></h5></div>
<p class="para block block-first">This macro is like <span class="function">_WRAP_METHOD()</span>, but it generates
    only the documentation for a  C++ method that wraps a C function. Use this
    when you must hand-code the method, but you want to use the documentation
    that would be generated if the method was generated.</p>
<p class="para block"><span class="function">_WRAP_METHOD_DOCS_ONLY(C function name)</span></p>
<p class="para block">For instance, from <span class="filename" dir="ltr">recentinfo.hg</span>:</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">_WRAP_METHOD_DOCS_ONLY(gtk_recent_info_get_applications)
</pre></div>
<p class="para block">There are some optional extra arguments:
<div class="block list variablelist"><dl class="variablelist">
<dt class="term dt-first">errthrow ["&lt;exceptions&gt;"]</dt>
<dd>
            <p class="para block block-first">Excludes documentation of the last GError** parameter of
                the C function.
                The optional "&lt;exceptions&gt;" is a comma-separated list
                of exceptions that can be thrown. It determines which @throws
                Doxygen commands are added to the documentation. Default value
                is <span class="classname" dir="ltr">Glib::Error</span>. If you want a comma in
                the description of an exception, precede it by a backslash. Example:
                <span class="code" dir="ltr">errthrow "Glib::OptionError Hello\, world, Glib::ConvertError"</span></p>
        </dd>
<dt class="term">newin "&lt;version&gt;"</dt>
<dd>
            <p class="para block block-first">Adds a @newin Doxygen command to the documentation, or replaces
                the @newin command generated from the C documentation.</p>
        </dd>
<dt class="term">voidreturn</dt>
<dd>
            <p class="para block block-first">Don't include a @return Doxygen command in the documentation.
                Useful if the wrapped C function returns a value, but the corresponding
                C++ method returns <span class="type" dir="ltr">void</span>.</p>
        </dd>
</dl></div>
</p>
</div>
<div class="division sect3">
<a name="gmmproc-ignore"><!--gmmproc-ignore--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">G.3.6.3. </span>_IGNORE, _IGNORE_SIGNAL, _IGNORE_PROPERTY</span></h5></div>
<p class="para block block-first"><span class="command" dir="ltr">gmmproc</span> will warn you on stdout about functions, signals,
    properties and child properties that you have forgotten to wrap, helping to
    ensure that you are wrapping the complete API. But if you don't want to wrap
    some functions, signals, properties or child properties, or if you chose
    to hand-code some methods then you can use the _IGNORE(), _IGNORE_SIGNAL()
    or _IGNORE_PROPERTY() macro to make <span class="command" dir="ltr">gmmproc</span> stop complaining.
</p>
<p class="para block">
<div class=" block literallayout block-first block-verbatim"><span class="function">_IGNORE(C function name 1, C function name 2, etc)
_IGNORE_SIGNAL(C signal name 1, C signal name 2, etc)
_IGNORE_PROPERTY(C property name 1, C property name 2, etc)</span></div>
</p>
<p class="para block">For instance, from <span class="filename" dir="ltr">flowbox.hg</span>:</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">_IGNORE(gtk_flow_box_set_filter_func, gtk_flow_box_set_sort_func)
_IGNORE_SIGNAL(activate-cursor-child, toggle-cursor-child, move-cursor)
</pre></div>
</div>
<div class="division sect3">
<a name="gmmproc-wrap-signal"><!--gmmproc-wrap-signal--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">G.3.6.4. </span>_WRAP_SIGNAL</span></h5></div>
<p class="para block block-first">This macro generates the C++ libsigc++-style signal to wrap a C GObject
    signal. It actually generates a public accessor method, such as
    <span class="function">signal_clicked()</span>, which returns a proxy object.
    <span class="command" dir="ltr">gmmproc</span> uses the .defs file to discover the C parameter
    types and the .m4 convert files to discover appropriate type
    conversions.</p>
<p class="para block"><span class="function">_WRAP_SIGNAL( C++ signal handler signature, C signal name)</span></p>
<p class="para block">For instance, from <span class="filename" dir="ltr">button.hg</span>:</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">_WRAP_SIGNAL(void clicked(),"clicked")
</pre></div>
<p class="para block">Signals usually have function pointers in the GTK struct, with a
    corresponding enum value and a <span class="function">g_signal_new()</span> in the
    .c file.</p>
<p class="para block">There are some optional extra arguments:
<div class="block list variablelist"><dl class="variablelist">
<dt class="term dt-first">no_default_handler</dt>
<dd>
            <p class="para block block-first">Do not generate an <span class="function">on_something()</span> virtual
                method to allow easy overriding of the default signal handler.
                Use this when adding a signal with a default signal handler
                would break the ABI by increasing the size of the class's
                virtual function table, and when adding a signal without a public
                C default handler.</p>
        </dd>
<dt class="term">custom_default_handler</dt>
<dd>
            <p class="para block block-first">Generate a declaration of the <span class="function">on_something()</span>
                virtual method in the <span class="filename" dir="ltr">.h</span> file, but do not
                generate a definition in the <span class="filename" dir="ltr">.cc</span> file.
                Use this when you must generate the definition by hand.</p>
        </dd>
<dt class="term">custom_c_callback</dt>
<dd>
            <p class="para block block-first">Do not generate a C callback function for the signal.
                Use this when you must generate the callback function by hand.</p>
        </dd>
<dt class="term">refreturn</dt>
<dd>
            <p class="para block block-first">Do an extra <span class="function">reference()</span> on the return value
                of the <span class="function">on_something()</span> virtual method, in
                case the C function does not provide a reference.</p>
        </dd>
<dt class="term">deprecated ["&lt;text&gt;"]</dt>
<dd>
            <p class="para block block-first">Puts the generated code in #ifdef blocks. Text about the
                deprecation can be specified as an optional parameter.</p>
        </dd>
<dt class="term">newin "&lt;version&gt;"</dt>
<dd>
            <p class="para block block-first">Adds a @newin Doxygen command to the documentation, or replaces
                the @newin command generated from the C documentation.</p>
        </dd>
<dt class="term">ifdef &lt;identifier&gt;</dt>
<dd>
            <p class="para block block-first">Puts the generated code in #ifdef blocks.</p>
        </dd>
<dt class="term">exception_handler &lt;method_name&gt;</dt>
<dd>
	        <p class="para block block-first">Allows to use custom exception handler instead of default one.
	            Exception might be rethrown by user-defined handler, and it will be
	            caught by default handler.</p>
	      </dd>
<dt class="term">detail_name &lt;parameter_name&gt;</dt>
<dd>
	        <p class="para block block-first">Adds a <span class="type" dir="ltr">const Glib::ustring&amp;</span> parameter to the
	            <span class="methodname" dir="ltr">signal_something()</span> method. Use it, if the signal
	            accepts a detailed signal name, i.e. if the underlying C code registers
	            the signal with the <span class="literal" dir="ltr">G_SIGNAL_DETAILED</span> flag.</p>
	      </dd>
<dt class="term">two_signal_methods</dt>
<dd>
	        <p class="para block block-first">Used in conjunction with the <span class="literal" dir="ltr">detail_name</span>
              option to generate two <span class="methodname" dir="ltr">signal_something()</span>
              methods, one without a parameter and one with a parameter without
              a default value. With only the <span class="literal" dir="ltr">detail_name</span> option
              one method is generated, with a parameter with default value.
              Use the <span class="literal" dir="ltr">two_signal_methods</span> option, if it's
              necessary in order to preserve ABI.</p>
	      </dd>
</dl></div>
</p>
</div>
<div class="division sect3">
<a name="gmmproc-wrap-property"><!--gmmproc-wrap-property--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">G.3.6.5. </span>_WRAP_PROPERTY</span></h5></div>
<p class="para block block-first">This macro generates the C++ method to wrap a C GObject property. You must
    specify the property name and the wanted C++ type for the property. <span class="command" dir="ltr">gmmproc</span>
    uses the .defs file to discover the C type and the .m4 convert files to
    discover appropriate type conversions.</p>
<p class="para block"><span class="function">_WRAP_PROPERTY(C property name, C++ type)</span></p>
<p class="para block">For instance, from <span class="filename" dir="ltr">button.hg</span>:</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">_WRAP_PROPERTY("label", Glib::ustring)
</pre></div>
<p class="para block">There are some optional extra arguments:
<div class="block list variablelist"><dl class="variablelist">
<dt class="term dt-first">deprecated ["&lt;text&gt;"]</dt>
<dd>
            <p class="para block block-first">Puts the generated code in #ifdef blocks. Text about the
                deprecation can be specified as an optional parameter.</p>
        </dd>
<dt class="term">newin "&lt;version&gt;"</dt>
<dd>
            <p class="para block block-first">Adds a @newin Doxygen command to the documentation, or replaces
                the @newin command generated from the C documentation.</p>
        </dd>
</dl></div>
</p>
</div>
<div class="division sect3">
<a name="gmmproc-wrap-vfunc"><!--gmmproc-wrap-vfunc--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">G.3.6.6. </span>_WRAP_VFUNC</span></h5></div>
<p class="para block block-first">This macro generates the C++ method to wrap a virtual C function.</p>
<p class="para block"><span class="function">_WRAP_VFUNC( C++ method signature, C function name)</span></p>
<p class="para block">For instance, from <span class="filename" dir="ltr">widget.hg</span>:</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">_WRAP_VFUNC(SizeRequestMode get_request_mode() const, get_request_mode)
</pre></div>
<p class="para block">The C function (e.g. <span class="function">get_request_mode</span>) is described
    more fully in the <span class="filename" dir="ltr">*_vfuncs.defs</span> file, and the
    <span class="filename" dir="ltr">convert*.m4</span> files contain the necessary conversion from
    the C++ parameter type to the C parameter type. Conversions can also be
    written in the .hg file. Virtual functions often require special conversions
    that are best kept local to the .hg file where they are used.</p>
<p class="para block">There are some optional extra arguments:
<div class="block list variablelist"><dl class="variablelist">
<dt class="term dt-first">refreturn</dt>
<dd>
            <p class="para block block-first">Do an extra <span class="function">reference()</span> on the return value
                of the <span class="function">something_vfunc()</span> function,
                in case the virtual C function does not provide a reference.</p>
        </dd>
<dt class="term">refreturn_ctype</dt>
<dd>
            <p class="para block block-first">Do an extra <span class="function">reference()</span> on the return value
                of an overridden <span class="function">something_vfunc()</span> function
                in the C callback function, in case the calling C function
                expects it to provide a reference.</p>
        </dd>
<dt class="term">keep_return</dt>
<dd>
            <p class="para block block-first">Keep a copy of the return value in the C callback function,
                in case the calling C function does not expect to get its own
                reference.</p>
        </dd>
<dt class="term">errthrow</dt>
<dd>
            <p class="para block block-first">Use the last GError** parameter of the C virtual function (if
              there is one) to throw an exception.</p>
        </dd>
<dt class="term">custom_vfunc</dt>
<dd>
            <p class="para block block-first">Do not generate a definition of the vfunc in the
               <span class="filename" dir="ltr">.cc</span> file. Use this when you must generate
               the vfunc by hand.</p>
        </dd>
<dt class="term">custom_vfunc_callback</dt>
<dd>
            <p class="para block block-first">Do not generate a C callback function for the vfunc.
                Use this when you must generate the callback function by hand.</p>
        </dd>
<dt class="term">ifdef &lt;identifier&gt;</dt>
<dd>
            <p class="para block block-first">Puts the generated code in #ifdef blocks.</p>
        </dd>
<dt class="term">slot_name &lt;parameter_name&gt;</dt>
<dd>
          <p class="para block block-first">Specifies the name of the slot parameter of the method, if it
            has one.  This enables <span class="command" dir="ltr">gmmproc</span> to generate code
            to copy the slot and pass the copy on to the C function in its
            final <span class="literal" dir="ltr">gpointer user_data</span> parameter.  The
            <span class="literal" dir="ltr">slot_callback</span> option must also be used to
            specify the name of the glue callback function to also pass on to
            the C function.</p>
        </dd>
<dt class="term">slot_callback &lt;function_name&gt;</dt>
<dd>
          <p class="para block block-first">Used in conjunction with the <span class="literal" dir="ltr">slot_name</span>
            option to specify the name of the glue callback function that
            handles extracting the slot and then calling it.  The address of
            this callback is also passed on to the C function that the method
            wraps.</p>
        </dd>
<dt class="term">no_slot_copy</dt>
<dd>
          <p class="para block block-first">Tells <span class="command" dir="ltr">gmmproc</span> not to pass a copy of the slot
            to the C function, if the method has one.  Instead the slot itself
            is passed.  The slot parameter name and the glue callback function
            must have been specified with the <span class="literal" dir="ltr">slot_name</span> and
            <span class="literal" dir="ltr">slot_callback</span> options respectively.</p>
        </dd>
<dt class="term">return_value &lt;value&gt;</dt>
<dd>
	        <p class="para block block-first">Defines a non-default return value.</p>
	      </dd>
<dt class="term">err_return_value &lt;value&gt;</dt>
<dd>
	        <p class="para block block-first">Defines a non-default return value, used only if the C++
	          <span class="function">something_vfunc()</span> function throws an exception
	          which is propagated to the C callback function. If return_value is
	          specified, but err_return_value is not, then return_value is used
	          also when an exception is propagated.</p>
	      </dd>
<dt class="term">exception_handler &lt;method_name&gt;</dt>
<dd>
	        <p class="para block block-first">Allows to use custom exception handler instead of default one.
	            Exception might be rethrown by user-defined handler, and it will be
	            caught by default handler.</p>
	      </dd>
</dl></div>
</p>
<p class="para block">A rule to which there may be exceptions: If the virtual C function returns
    a pointer to an object derived from <span class="classname" dir="ltr">GObject</span>, i.e. a
    reference-counted object, then the virtual C++ function shall return a
    <span class="classname" dir="ltr">Glib::RefPtr&lt;&gt;</span> object. One of the extra
    arguments <span class="parameter" dir="ltr">refreturn</span> or
    <span class="parameter" dir="ltr">refreturn_ctype</span> is required.</p>
</div>
</div>
<div class="division sect2">
<a name="gmmproc-other-macros"><!--gmmproc-other-macros--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">G.3.7. </span>Other macros</span></h4></div>
<div class="autotoc"><ul>
<li>
<span class="label">G.3.7.1. </span><a class="xref" href="#gmmproc-implements-interface" title="_IMPLEMENTS_INTERFACE">_IMPLEMENTS_INTERFACE</a>
</li>
<li>
<span class="label">G.3.7.2. </span><a class="xref" href="#gmmproc-wrap-enum" title="_WRAP_ENUM">_WRAP_ENUM</a>
</li>
<li>
<span class="label">G.3.7.3. </span><a class="xref" href="#gmmproc-wrap-enum-docs-only" title="_WRAP_ENUM_DOCS_ONLY">_WRAP_ENUM_DOCS_ONLY</a>
</li>
<li>
<span class="label">G.3.7.4. </span><a class="xref" href="#gmmproc-wrap-gerror" title="_WRAP_GERROR">_WRAP_GERROR</a>
</li>
<li>
<span class="label">G.3.7.5. </span><a class="xref" href="#gmmproc-member-set-get" title="_MEMBER_GET / _MEMBER_SET">_MEMBER_GET / _MEMBER_SET</a>
</li>
<li>
<span class="label">G.3.7.6. </span><a class="xref" href="#gmmproc-member-get-set-ptr" title="_MEMBER_GET_PTR / _MEMBER_SET_PTR">_MEMBER_GET_PTR / _MEMBER_SET_PTR</a>
</li>
<li>
<span class="label">G.3.7.7. </span><a class="xref" href="#gmmproc-member-get-set-gobject" title="_MEMBER_GET_GOBJECT / _MEMBER_SET_GOBJECT">_MEMBER_GET_GOBJECT / _MEMBER_SET_GOBJECT</a>
</li>
</ul></div>
<div class="division sect3">
<a name="gmmproc-implements-interface"><!--gmmproc-implements-interface--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">G.3.7.1. </span>_IMPLEMENTS_INTERFACE</span></h5></div>
<p class="para block block-first">This macro generates initialization code for the interface.</p>
<p class="para block"><span class="function">_IMPLEMENTS_INTERFACE(C++ interface name)</span></p>
<p class="para block">For instance, from <span class="filename" dir="ltr">grid.hg</span>:</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">_IMPLEMENTS_INTERFACE(Orientable)
</pre></div>
<p class="para block">There is one optional extra argument:
<div class="block list variablelist"><dl class="variablelist">
<dt class="term dt-first">ifdef &lt;identifier&gt;</dt>
<dd>
            <p class="para block block-first">Puts the generated code in #ifdef blocks.</p>
        </dd>
</dl></div>
</p>
</div>
<div class="division sect3">
<a name="gmmproc-wrap-enum"><!--gmmproc-wrap-enum--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">G.3.7.2. </span>_WRAP_ENUM</span></h5></div>
<p class="para block block-first">This macro generates a C++ enum to wrap a C enum. You must specify the desired C++ name and
    the name of the underlying C enum.</p>
<p class="para block">For instance, from <span class="filename" dir="ltr">enums.hg</span>:</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">_WRAP_ENUM(Orientation, GtkOrientation)
</pre></div>
<p class="para block">There are some optional extra arguments:
<div class="block list variablelist"><dl class="variablelist">
<dt class="term dt-first">NO_GTYPE</dt>
<dd>
      <p class="para block block-first">Use this option, if the enum is not a <span class="classname" dir="ltr">GType</span>.
        This is the case when there is no <span class="function">*_get_type()</span>
        function for the C enum, but be careful that you don't just need to
        include an extra header for that function. You should also file a bug
        against the C API, because all enums should be registered as GTypes.</p>
      <p class="para block">If you specify <span class="literal" dir="ltr">NO_GTYPE</span>, don't use that enum as the
        type in _WRAP_PROPERTY. It would cause a runtime error, when the generated
        <span class="methodname" dir="ltr">property_*()</span> method is called.</p>
      <p class="para block">For example, from <span class="filename" dir="ltr">icontheme.hg</span>:</p>
      <div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">_WRAP_ENUM(IconLookupFlags, GtkIconLookupFlags, NO_GTYPE)
      </pre></div>
    </dd>
<dt class="term">gtype_func &lt;function_name&gt;</dt>
<dd>
      <p class="para block block-first">Specifies the name of the <span class="function">*_get_type()</span> function
        for the C enum. Use this parameter if <span class="command" dir="ltr">gmmproc</span> can't
        deduce the correct function name from the name of the C enum type.</p>
      <p class="para block">For example, from <span class="filename" dir="ltr">dbusproxy.hg</span> in glibmm:</p>
      <div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">_WRAP_ENUM(ProxyFlags, GDBusProxyFlags, gtype_func g_dbus_proxy_flags_get_type)
      </pre></div>
    </dd>
<dt class="term">CONV_TO_INT</dt>
<dd>
      <p class="para block block-first">"Convertible to int." Generates a plain enum (not an enum class)
        within a class. Such an enum is scoped like an enum class, but unlike an
        enum class, it can be implicitly converted to <span class="type" dir="ltr">int</span>.</p>
      <p class="para block">For example, from <span class="filename" dir="ltr">dialog.hg</span>:</p>
      <div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">_WRAP_ENUM(ResponseType, GtkResponseType, CONV_TO_INT)
      </pre></div>
    </dd>
<dt class="term">s#&lt;from&gt;#&lt;to&gt;#</dt>
<dd>
      <p class="para block block-first">Substitutes (part of) the name of one or more enum constants.
        You can add any number of substitutions.</p>
      <p class="para block">For example, from <span class="filename" dir="ltr">iochannel.hg</span> in glibmm:</p>
      <div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">_WRAP_ENUM(SeekType, GSeekType, NO_GTYPE, s#^SEEK_#SEEK_TYPE_#)
      </pre></div>
    </dd>
<dt class="term">deprecated ["&lt;text&gt;"]</dt>
<dd>
      <p class="para block block-first">Puts the generated code in #ifdef blocks. Text about the
        deprecation can be specified as an optional parameter.</p>
    </dd>
<dt class="term">newin "&lt;version&gt;"</dt>
<dd>
      <p class="para block block-first">Adds a @newin Doxygen command to the documentation, or replaces
        the @newin command generated from the C documentation.</p>
    </dd>
</dl></div>
</p>
</div>
<div class="division sect3">
<a name="gmmproc-wrap-enum-docs-only"><!--gmmproc-wrap-enum-docs-only--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">G.3.7.3. </span>_WRAP_ENUM_DOCS_ONLY</span></h5></div>
<p class="para block block-first">This macro just generates a Doxygen documentationn block for the enum.
  This is useful for enums that can't be wrapped with
  <span class="function">_WRAP_ENUM()</span> because they are complexly defined (maybe
  using C macros) but including the generated enum documentation is still
  desired. It is used with the same syntax as
  <span class="function">_WRAP_ENUM()</span> and also processes the same options (though
  NO_GTYPE, gtype_func &lt;function_name&gt; and CONV_TO_INT are ignored because
  they make no difference when just generating the enum's documentation).
</p>
</div>
<div class="division sect3">
<a name="gmmproc-wrap-gerror"><!--gmmproc-wrap-gerror--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">G.3.7.4. </span>_WRAP_GERROR</span></h5></div>
<p class="para block block-first">This macro generates a C++ exception class, derived from <span class="classname" dir="ltr">Glib::Error</span>, with
a <span class="type" dir="ltr">Code</span> enum and a <span class="methodname" dir="ltr">code()</span> method. You must specify the desired C++ name, the name
of the corresponding C enum, and the prefix for the C enum values.</p>
<p class="para block">This exception can then be thrown by methods which are generated from
_WRAP_METHOD() with the errthrow option.</p>
<p class="para block">For instance, from <span class="filename" dir="ltr">pixbuf.hg</span>:</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">_WRAP_GERROR(PixbufError, GdkPixbufError, GDK_PIXBUF_ERROR)
</pre></div>
<p class="para block">_WRAP_GERROR() accepts the same optional arguments as _WRAP_ENUM() (though
CONV_TO_INT is ignored because all exception class enums are plain enums within a class).
</p>
</div>
<div class="division sect3">
<a name="gmmproc-member-set-get"><!--gmmproc-member-set-get--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">G.3.7.5. </span>_MEMBER_GET / _MEMBER_SET</span></h5></div>
<p class="para block block-first">
    Use these macros if you're wrapping a simple struct or boxed type that provides
    direct access to its data members, to create getters and setters for the data members.
  </p>
<p class="para block"><span class="function">_MEMBER_GET(C++ name, C name, C++ type, C type)</span></p>
<p class="para block"><span class="function">_MEMBER_SET(C++ name, C name, C++ type, C type)</span></p>
<p class="para block">
    For example, in <span class="filename" dir="ltr">rectangle.hg</span>:
  </p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">_MEMBER_GET(x, x, int, int)</pre></div>
</div>
<div class="division sect3">
<a name="gmmproc-member-get-set-ptr"><!--gmmproc-member-get-set-ptr--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">G.3.7.6. </span>_MEMBER_GET_PTR / _MEMBER_SET_PTR</span></h5></div>
<p class="para block block-first">
    Use these macros to automatically provide getters and setters for a data
    member that is a pointer type. For the getter function, it will
    create two methods, one const and one non-const.
  </p>
<p class="para block"><span class="function">_MEMBER_GET_PTR(C++ name, C name, C++ type, C type)</span></p>
<p class="para block"><span class="function">_MEMBER_SET_PTR(C++ name, C name, C++ type, C type)</span></p>
<p class="para block">For example, for <span class="classname" dir="ltr">Pango::Analysis</span> in <span class="filename" dir="ltr">item.hg</span>:
  </p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">// _MEMBER_GET_PTR(engine_lang, lang_engine, EngineLang*, PangoEngineLang*)
// It's just a comment. It's difficult to find a real-world example.
</pre></div>
</div>
<div class="division sect3">
<a name="gmmproc-member-get-set-gobject"><!--gmmproc-member-get-set-gobject--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">G.3.7.7. </span>_MEMBER_GET_GOBJECT / _MEMBER_SET_GOBJECT</span></h5></div>
<p class="para block block-first">
    Use these macros to provide getters and setters for a data member that is a
    <span class="classname" dir="ltr">GObject</span> type that must be referenced before being
    returned.
  </p>
<p class="para block"><span class="function">_MEMBER_GET_GOBJECT(C++ name, C name, C++ type, C type)</span></p>
<p class="para block"><span class="function">_MEMBER_SET_GOBJECT(C++ name, C name, C++ type, C type)</span></p>
<p class="para block">For example, in Pangomm, <span class="filename" dir="ltr">layoutline.hg</span>:</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">_MEMBER_GET_GOBJECT(layout, layout, Pango::Layout, PangoLayout*)
</pre></div>
</div>
</div>
<div class="division sect2">
<a name="gmmproc-parameter-processing"><!--gmmproc-parameter-processing--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">G.3.8. </span>gmmproc Parameter Processing</span></h4></div>
<p class="para block block-first"><span class="command" dir="ltr">gmmproc</span> allows processing the parameters in a method
    signature for the macros that process method signatures (like
    <span class="function">_WRAP_METHOD()</span>, <span class="function">_WRAP_CTOR()</span> and
    <span class="function">_WRAP_CREATE()</span>) in a variety of ways:
  </p>
<div class="autotoc"><ul>
<li>
<span class="label">G.3.8.1. </span><a class="xref" href="#gmmproc-parameter-reordering" title="Parameter Reordering">Parameter Reordering</a>
</li>
<li>
<span class="label">G.3.8.2. </span><a class="xref" href="#gmmproc-optional-parameter-processing" title="Optional Parameter Processing">Optional Parameter Processing</a>
</li>
<li>
<span class="label">G.3.8.3. </span><a class="xref" href="#gmmproc-output-parameter-processing" title="Output Parameter Processing">Output Parameter Processing</a>
</li>
<li>
<span class="label">G.3.8.4. </span><a class="xref" href="#gmmproc-string-parameter-processing" title="String Parameter Processing">String Parameter Processing</a>
</li>
</ul></div>
<div class="division sect3">
<a name="gmmproc-parameter-reordering"><!--gmmproc-parameter-reordering--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">G.3.8.1. </span>Parameter Reordering</span></h5></div>
<p class="para block block-first">
      For all the macros that process method signatures, it is possible to
      specify a different order for the C++ parameters than the existing order
      in the C function, virtual function or signal.  For example, say that the
      following C function were being wrapped as a C++ method for the
      <span class="classname" dir="ltr">Gtk::Widget</span> class:
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">void gtk_widget_set_device_events(GtkWidget* widget, GdkDevice* device,
  GdkEventMask events);
</pre></div>
      However, changing the order of the C++ method's two parameters is
      necessary.  Something like the following would wrap the function as a C++
      method with a different order for the two parameters:
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">_WRAP_METHOD(void set_device_events(Gdk::EventMask events{events},
  const Glib::RefPtr&lt;const Gdk::Device&gt;&amp; device{device}),
  gtk_widget_set_device_events)
</pre></div>
      The <span class="literal" dir="ltr">{c_param_name}</span> following the method parameter
      names tells <span class="command" dir="ltr">gmmproc</span> to map the C++ parameter to the
      specified C parameter within the <span class="literal" dir="ltr">{}</span>.  Since the C++
      parameter names correspond to the C ones, the above could be re-written
      as:
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">_WRAP_METHOD(void set_device_events(Gdk::EventMask events{.},
  const Glib::RefPtr&lt;const Gdk::Device&gt;&amp; device{.}),
  gtk_widget_set_device_events)
</pre></div>
    </p>
<div class="admonition block warning block-indent"><div class="warning-inner">
      <p class="para block block-first">
        Please note that when reordering parameters for a
        <span class="function">_WRAP_SIGNAL()</span> method signature, the C parameter
        names would always be <span class="literal" dir="ltr">p0</span>, <span class="literal" dir="ltr">p1</span>,
        etc. because the <span class="filename" dir="ltr">generate_extra_defs</span> utility uses those
        parameter names no matter what the C API's parameter names may be.
        It's how the utility is written presently.
      </p>
    </div></div>
</div>
<div class="division sect3">
<a name="gmmproc-optional-parameter-processing"><!--gmmproc-optional-parameter-processing--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">G.3.8.2. </span>Optional Parameter Processing</span></h5></div>
<p class="para block block-first">
      For all macros processing method signatures except
      <span class="function">_WRAP_SIGNAL()</span> and
      <span class="function">_WRAP_VFUNC()</span> it is also possible to make the
      parameters optional so that extra C++ methods are generated without the
      specified optional parameter.  For example, say that the following
      <span class="function">*_new()</span> function were being wrapped as a constructor
      in the <span class="classname" dir="ltr">Gtk::ToolButton</span> class:
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">GtkToolItem* gtk_tool_button_new(GtkWidget* icon_widget, const gchar* label);
</pre></div>
      Also, say that the C API allowed NULL for the function's
      <span class="parameter" dir="ltr">label</span> parameter so that that parameter is optional.
      It would be possible to have <span class="command" dir="ltr">gmmproc</span> generate the
      original constructor (with all the parameters) along with an additional
      constructor without that optional parameter by appending a
      <span class="literal" dir="ltr">{?}</span> to the parameter name like so:
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">_WRAP_CTOR(ToolButton(Widget&amp; icon_widget, const Glib::ustring&amp; label{?}),
  gtk_tool_button_new)
</pre></div>
      In this case, two constructors would be generated: One with the optional
      parameter and one without it.
    </p>
</div>
<div class="division sect3">
<a name="gmmproc-output-parameter-processing"><!--gmmproc-output-parameter-processing--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">G.3.8.3. </span>Output Parameter Processing</span></h5></div>
<p class="para block block-first">
      With <span class="function">_WRAP_METHOD()</span> it is also possible for the
      return of the wrapped C function (if it has one) to be placed in an
      output parameter of the C++ method instead of having the C++ method also
      return a value like the C function does.  To do that, simply include the
      output parameter in the C++ method parameter list appending a
      <span class="literal" dir="ltr">{OUT}</span> to the output parameter name.  For example, if
      <span class="function">gtk_widget_get_request_mode()</span> is declared as the
      following:
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">GtkSizeRequestMode gtk_widget_get_request_mode(GtkWidget* widget);
</pre></div>
      And having the C++ method set an output parameter is desired instead of
      returning a <span class="type" dir="ltr">SizeRequestMode</span>, something like the following
      could be used:
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">_WRAP_METHOD(void get_request_mode(SizeRequestMode&amp; mode{OUT}) const,
  gtk_widget_get_request_mode)
</pre></div>
      The <span class="literal" dir="ltr">{OUT}</span> appended to the name of the
      <span class="parameter" dir="ltr">mode</span> output parameter tells
      <span class="command" dir="ltr">gmmproc</span> to place the return of the C function in that
      output parameter.  In this case, however, a necessary initialization
      macro like the following would also have to be specified:
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">_INITIALIZATION(`SizeRequestMode&amp;',`GtkSizeRequestMode',`$3 = (SizeRequestMode)($4)')
</pre></div>
      Which could also be written as:
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">_INITIALIZATION(`SizeRequestMode&amp;',`GtkSizeRequestMode',`$3 = ($1)($4)')
</pre></div>
    </p>
<p class="para block">
      <span class="function">_WRAP_METHOD()</span> also supports setting C++ output
      parameters from C output parameters if the C function being wrapped has
      any.  Suppose, for example, that we want to wrap the following C function
      that returns a value in its C output parameter
      <span class="parameter" dir="ltr">rect</span>:
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">gboolean gtk_icon_view_get_cell_rect(GtkIconView* icon_view,
  GtkTreePath* path, GtkCellRenderer* cell, GdkRectangle* rect);
</pre></div>
      To have <span class="command" dir="ltr">gmmproc</span> place the value returned in the C++
      <span class="parameter" dir="ltr">rect</span> output parameter, something like the
      following <span class="function">_WRAP_METHOD()</span> macro could be used:
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">_WRAP_METHOD(bool get_cell_rect(const TreeModel::Path&amp; path,
  const CellRenderer&amp; cell, Gdk::Rectangle&amp; rect{&gt;&gt;}) const,
  gtk_icon_view_get_cell_rect)
</pre></div>
      The <span class="literal" dir="ltr">{&gt;&gt;}</span> following the <span class="parameter" dir="ltr">rect</span>
      parameter name indicates that the C++ output parameter should be set from
      the value returned in the C parameter from the C function.
      <span class="command" dir="ltr">gmmproc</span> will generate a declaration of a temporary
      variable in which to store the value of the C output parameter and a
      statement that sets the C++ output parameter from the temporary variable.
      In this case it may be necessary to have an
      <span class="function">_INITIALIZATION()</span> describing how to set a
      <span class="classname" dir="ltr">Gdk::Rectangle&amp;</span> from a
      <span class="classname" dir="ltr">GdkRectangle*</span> such as the following:
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">_INITIALIZATION(`Gdk::Rectangle&amp;',`GdkRectangle',`$3 = Glib::wrap(&amp;($4))')
</pre></div>
    </p>
</div>
<div class="division sect3">
<a name="gmmproc-string-parameter-processing"><!--gmmproc-string-parameter-processing--></a><div class="header"><h5 class="sect3 title"><span class="title"><span class="label">G.3.8.4. </span>String Parameter Processing</span></h5></div>
<p class="para block block-first">
      A string-valued input parameter in a C++ method is usually a
      <span class="type" dir="ltr">const Glib::ustring&amp;</span> or a <span class="type" dir="ltr">const std::string&amp;</span>.
      In C code it's a <span class="type" dir="ltr">const gchar*</span>. When an empty string is converted
      to <span class="type" dir="ltr">const gchar*</span>, it can be converted either to <span class="literal" dir="ltr">nullptr</span>
      or to a pointer to an empty string (with <span class="methodname" dir="ltr">c_str()</span>).
      Some parameters in some C functions accept a <span class="literal" dir="ltr">nullptr</span>, and
      interpret it in a special way. Other parameters must not be <span class="literal" dir="ltr">nullptr</span>.
    </p>
<p class="para block">
      The default conversion in <span class="function">_WRAP_METHOD()</span> and similar
      macros is
      <div class="block list itemizedlist"><ul class="itemizedlist">
<li class="li-first"><span class="para">for mandatory parameters (with or without default values):
          empty string to empty string,</span></li>
<li><span class="para">for optional parameters (with appended <span class="literal" dir="ltr">{?}</span>):
          empty string to <span class="literal" dir="ltr">nullptr</span>.</span></li>
</ul></div>
      If the default conversion is not the best conversion, append <span class="literal" dir="ltr">{NULL}</span>
      to a mandatory parameter or <span class="literal" dir="ltr">{?!NULL}</span> to an optional
      parameter (<span class="literal" dir="ltr">!NULL</span> = not <span class="literal" dir="ltr">NULL</span>). If you
      append both a C parameter name and <span class="literal" dir="ltr">NULL</span>, separate them
      with a space: <span class="literal" dir="ltr">{c_param_name NULL}</span>.
    </p>
</div>
</div>
<div class="division sect2">
<a name="gmmproc-basic-types"><!--gmmproc-basic-types--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">G.3.9. </span>Basic Types</span></h4></div>
<p class="para block block-first">Some of the basic types that are used in C APIs have better alternatives
    in C++. For example, there's no need for a <span class="type" dir="ltr">gboolean</span> type since
    C++ has <span class="type" dir="ltr">bool</span>. The following list shows some commonly-used
    types in C APIs and what you might convert them to in a C++ wrapper library.
  </p>
<div class="block list segmentedlist">
<div class="block block-first title title-formal"><span class="title"><span class="label"></span>Basic Type equivalents</span></div>
<div class="block seglistitem"><div class="odd">
<p class="segfirst"><b>C type: </b><span class="type" dir="ltr">gboolean</span></p>
<p class="block seg"><b>C++ type: </b><span class="type" dir="ltr">bool</span></p>
</div></div>
<div class="block seglistitem"><div class="even">
<p class="segfirst"><b>C type: </b><span class="type" dir="ltr">gint</span></p>
<p class="block seg"><b>C++ type: </b><span class="type" dir="ltr">int</span></p>
</div></div>
<div class="block seglistitem"><div class="odd">
<p class="segfirst"><b>C type: </b><span class="type" dir="ltr">guint</span></p>
<p class="block seg"><b>C++ type: </b><span class="type" dir="ltr">guint</span></p>
</div></div>
<div class="block seglistitem"><div class="even">
<p class="segfirst"><b>C type: </b><span class="type" dir="ltr">gdouble</span></p>
<p class="block seg"><b>C++ type: </b><span class="type" dir="ltr">double</span></p>
</div></div>
<div class="block seglistitem"><div class="odd">
<p class="segfirst"><b>C type: </b><span class="type" dir="ltr">gunichar</span></p>
<p class="block seg"><b>C++ type: </b><span class="type" dir="ltr">gunichar</span></p>
</div></div>
<div class="block seglistitem"><div class="even">
<p class="segfirst"><b>C type: </b><span class="type" dir="ltr">gchar*</span></p>
<p class="block seg"><b>C++ type: </b><span class="classname" dir="ltr">Glib::ustring</span> (or <span class="classname" dir="ltr">std::string</span> for filenames)</p>
</div></div>
</div>
</div>
</div>
<div class="division sect1">
<a name="sec-wrapping-hand-coded-files"><!--sec-wrapping-hand-coded-files--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">G.4. </span>Hand-coded source files</span></h3></div>
<p class="para block block-first">You might want to include additional source files that will not be
  generated by <span class="command" dir="ltr">gmmproc</span> from <span class="filename" dir="ltr">.hg</span> and
  <span class="filename" dir="ltr">.ccg</span> files. You can simply place these in your
  <span class="filename" dir="ltr">libsomething/libsomethingmm</span> directory and mention them
  in the <span class="filename" dir="ltr">meson.build</span> in the
  <span class="varname" dir="ltr">extra_h_files</span> and <span class="varname" dir="ltr">extra_cc_files</span>
  variables.</p>
</div>
<div class="division sect1">
<a name="sec-wrapping-initialization"><!--sec-wrapping-initialization--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">G.5. </span>Initialization</span></h3></div>
<p class="para block block-first">Your library must be initialized before it can be used, to register the
    new types that it makes available. Also, the C library that you are wrapping
    might have its own initialization function that you should call. You can do
    this in an <span class="function">init()</span> function that you can place in
    hand-coded <span class="filename" dir="ltr">init.h</span> and <span class="filename" dir="ltr">init.cc</span>
    files. This function should initialize your dependencies (such as the C
    function, and <span class="application">gtkmm</span>) and call your generated
    <span class="function">wrap_init()</span> function. For instance:</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">void init()
{
  Gtk::init_gtkmm_internals(); //Sets up the g type system and the Glib::wrap() table.
  wrap_init(); //Tells the Glib::wrap() table about the libsomethingmm classes.
}
</pre></div>
<p class="para block">The implementation of the <span class="function">wrap_init()</span> method in
    <span class="filename" dir="ltr">wrap_init.cc</span> is generated by
    <span class="filename" dir="ltr">generate_wrap_init.pl</span>, but the declaration in
    <span class="filename" dir="ltr">wrap_init.h</span> is hand-coded, so you will need to adjust
    <span class="filename" dir="ltr">wrap_init.h</span> so that the <span class="function">wrap_init()</span>
    function appears in the correct C++ namespace.</p>
</div>
<div class="division sect1">
<a name="sec-wrapping-problems"><!--sec-wrapping-problems--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">G.6. </span>Problems in the C API.</span></h3></div>
<p class="para block block-first">You are likely to encounter some problems in the library that you are wrapping, particularly if it is a new project. Here are some common problems, with solutions.</p>
<div class="autotoc"><ul>
<li>
<span class="label">G.6.1. </span><a class="xref" href="#wrapping-predeclare-structs" title="Unable to predeclare structs">Unable to predeclare structs</a>
</li>
<li>
<span class="label">G.6.2. </span><a class="xref" href="#wrapping-no-properties" title="Lack of properties">Lack of properties</a>
</li>
</ul></div>
<div class="division sect2">
<a name="wrapping-predeclare-structs"><!--wrapping-predeclare-structs--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">G.6.1. </span>Unable to predeclare structs</span></h4></div>
<p class="para block block-first">By convention, structs are declared in glib/GTK-style headers like so:</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">typedef struct _ExampleWidget ExampleWidget;

struct _ExampleWidget
{
  ...
};
</pre></div>
<p class="para block">The extra typedef allows the struct to be used in a header without including
  its full definition, simply by predeclaring it, by repeating that typedef.
  This means that you don't have to include the C library's header in your C++ header,
  thus keeping it out of your public API. <span class="command" dir="ltr">gmmproc</span> assumes that
  this technique was used, so you will see compiler errors if that is not the case.</p>
<p class="para block">
This compiler error might look like this:
<div dir="ltr" class=" block programlisting block-indent block-first"><pre class="programlisting">example-widget.h:56: error: using typedef-name 'ExampleWidget' after 'struct'
../../libexample/libexamplemm/example-widget.h:34: error: 'ExampleWidget' has a previous declaration here
make[4]: *** [example-widget.lo] Error 1
</pre></div>
or this:
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">example-widget.h:60: error: '_ExampleWidget ExampleWidget' redeclared as different kind of symbol
../../libexample/libexamplemm/example-widget.h:34: error: previous declaration of 'typedef struct _ExampleWidget ExampleWidget'
</pre></div>
</p>
<p class="para block">This is easy to correct in the C library, so do send a patch to the relevant maintainer.</p>
</div>
<div class="division sect2">
<a name="wrapping-no-properties"><!--wrapping-no-properties--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">G.6.2. </span>Lack of properties</span></h4></div>
<p class="para block block-first">By convention, glib/GTK-style objects have <span class="function">*_new()</span>
    functions, such as <span class="function">example_widget_new()</span> that do nothing
    more than call <span class="function">g_object_new()</span> and return the result.
    The input parameters are supplied to <span class="function">g_object_new()</span>
    along with the names of the properties for which they are values. For
    instance,</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">GtkWidget* example_widget_new(int something, const char* thing)
{
        return g_object_new (EXAMPLE_TYPE_WIDGET, "something", something, "thing", thing, NULL);
}
</pre></div>
<p class="para block">This allows language bindings to implement their own equivalents (such as
    C++ constructors), without using the <span class="function">*_new()</span> function.
    This is often necessary so that they can actually instantiate a derived
    GType, to add their own hooks for signal handlers and vfuncs.</p>
<p class="para block">At the least, the <span class="function">_new()</span> function should not use any
    private API (functions that are only in a .c file). Even when there are no
    functions, we can sometimes reimplement 2 or 3 lines of code in a
    <span class="function">_new()</span> function as long as those lines of code use API
    that is available to us.</p>
<p class="para block">Another workaround is to add a <span class="function">*_construct()</span> function
    that the C++ constructor can call after instantiating its own type. For
    instance,</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">GtkWidget* example_widget_new(int something, const char* thing)
{
        ExampleWidget* widget;
        widget = g_object_new (EXAMPLE_TYPE_WIDGET, NULL);
        example_widget_construct(widget, "something", something, "thing", thing);
}

void example_widget_construct(ExampleWidget* widget, int something, const char* thing)
{
        //Do stuff that uses private API:
        widget-&gt;priv-&gt;thing = thing;
        do_something(something);
}
</pre></div>
<p class="para block">Adding properties, and ensuring that they interact properly with each
    other, is relatively difficult to correct in the C library, but it is
    possible, so do file a bug and try to send a patch to the relevant
    maintainer.</p>
</div>
</div>
<div class="division sect1">
<a name="sec-wrapping-documentation"><!--sec-wrapping-documentation--></a><div class="header"><h3 class="sect1 title"><span class="title"><span class="label">G.7. </span>Documentation</span></h3></div>
<p class="para block block-first">In general, gtkmm-style projects use Doxygen, which reads specially formatted C++ comments and generates HTML documentation. You may write these doxygen comments directly in the header files.</p>
<div class="autotoc"><ul>
<li>
<span class="label">G.7.1. </span><a class="xref" href="#wrapping-reusing-c-documentation" title="Reusing C documentation">Reusing C documentation</a>
</li>
<li>
<span class="label">G.7.2. </span><a class="xref" href="#wrapping-documentation-build-structure" title="Documentation build structure">Documentation build structure</a>
</li>
</ul></div>
<div class="division sect2">
<a name="wrapping-reusing-c-documentation"><!--wrapping-reusing-c-documentation--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">G.7.1. </span>Reusing C documentation</span></h4></div>
<p class="para block block-first">You might wish to reuse documentation that exists for the C library that
  you are wrapping. GTK-style C libraries typically use gtk-doc and therefore
  have source code comments formatted for gtk-doc and some extra documentation
  in .sgml and .xml files. The docextract_to_xml.py script, from glibmm's
  <span class="filename" dir="ltr">tools/defs_gen</span> directory, can read these files and
  generate an .xml file that <span class="command" dir="ltr">gmmproc</span> can use to generate
  doxygen comments. <span class="command" dir="ltr">gmmproc</span> will even try to transform the
  documentation to make it more appropriate for a C++ API.</p>
<p class="para block">
For instance,</p>
<div dir="ltr" class=" block programlisting block-indent"><pre class="programlisting">./docextract_to_xml.py -s ~/checkout/gnome/gtk/gtk/ &gt; gtk_docs.xml
</pre></div>
<p class="para block">Because this automatic transformation is not always appropriate, you might
    want to provide hand-written text for a particular method. You can do this
    by copying the XML node for the function from your
    <span class="filename" dir="ltr">something_docs.xml</span> file to the
    <span class="filename" dir="ltr">something_docs_override.xml</span> file and changing the
    contents. Alternatively you can write your own documentation in the
    <span class="filename" dir="ltr">.hg</span> file.</p>
</div>
<div class="division sect2">
<a name="wrapping-documentation-build-structure"><!--wrapping-documentation-build-structure--></a><div class="header"><h4 class="sect2 title"><span class="title"><span class="label">G.7.2. </span>Documentation build structure</span></h4></div>
<p class="para block block-first">If you copied the skeleton source tree in <span class="application">mm-common</span> and substituted the
  placeholder text, then you will already have suitable <span class="filename" dir="ltr">meson.build</span>
  and <span class="filename" dir="ltr">Doxyfile.in</span> files in the <span class="filename" dir="ltr">doc/reference/</span>
  directory. You probably need to modify the <span class="varname" dir="ltr">tag_file_modules</span>
  variable in <span class="filename" dir="ltr">meson.build</span>, though.
  With the <span class="application">mm-common</span> build setup, the list
  of Doxygen input files is not defined in the Doxygen configuration file, but passed
  along from <span class="command" dir="ltr">meson/ninja</span> to the standard input of <span class="command" dir="ltr">doxygen</span>.
</p>
</div>
</div>
</div>
<div class="footnotes"><div class="footnote">
<a name="-note-idm140176212139568"></a><span class="footnote-number"><a class="footnote-ref" href="#-noteref-idm140176212139568">1</a></span>
<p class="para block block-first">
These interactions arise from the fact that, amongst other things, a
class inheriting from <span class="classname" dir="ltr">sigc::trackable</span> will, via
that inheritance, have a <span class="classname" dir="ltr">std::list</span> object
keeping track of slots created by calls to
<span class="function">sigc::mem_fun()</span> representing any of its
non-static methods (more particularly it keeps a list of callbacks
which will null the connected slots on its destruction). Each
<span class="classname" dir="ltr">sigc::slot</span> object also keeps, via
<span class="classname" dir="ltr">sigc::slot_rep</span>, its own
<span class="classname" dir="ltr">sigc::trackable</span> object to track any
<span class="classname" dir="ltr">sigc::connection</span> objects which it needs to
inform about its demise, and also has a function to deregister itself
from any <span class="classname" dir="ltr">sigc::trackable</span> on disconnection or
destruction. <span class="classname" dir="ltr">sigc::signal</span> objects also keep
lists of slots, which will be updated by a call to their
<span class="methodname" dir="ltr">connect()</span> method or calls to any
<span class="classname" dir="ltr">sigc::connection</span> object relating to such a
connection.
</p>
</div></div>
</div>
<div class="navbar navbar-bottom"><table class="navbar"><tr>
<td class="navbar-prev"></td>
<td class="navbar-next"></td>
</tr></table></div>
</div>
<div class="sidebar"><div class="sidenav"><div class="autotoc"><ul><li>Programming with <span class="application">gtkmm</span> 4</li></ul></div></div></div>
<div id="footer_art" class="default"> </div>
</div>
<div class="clearfix"></div>
<div id="footer_grass">   </div>
<div id="footer"><div class="container_12">
<div class="links grid_9">
<div class="menu-footer-1-container"><ul id="menu-footer-1" class="menu"><li id="menu-item-88" class="menu-item menu-item-type-custom menu-item-home menu-item-88">
<a href="https://www.gnome.org/">The GNOME Project</a><ul class="sub-menu">
<li id="menu-item-89" class="menu-item menu-item-type-post_type menu-item-89"><a href="https://www.gnome.org/about/">About Us</a></li>
<li id="menu-item-90" class="menu-item menu-item-type-custom menu-item-90"><a href="https://www.gnome.org/get-involved/">Get Involved</a></li>
<li id="menu-item-91" class="menu-item menu-item-type-custom menu-item-91"><a href="https://www.gnome.org/teams/">Teams</a></li>
<li id="menu-item-92" class="menu-item menu-item-type-custom menu-item-92"><a href="https://foundation.gnome.org">The GNOME Foundation</a></li>
<li><a href="https://www.gnome.org/support-gnome/">Support GNOME</a></li>
<li><a href="https://www.gnome.org/contact/">Contact</a></li>
</ul>
</li></ul></div>
<div class="menu-footer-2-container"><ul id="menu-footer-2" class="menu"><li id="menu-item-99" class="menu-item menu-item-type-post_type current-menu-item page_item page-item-20 current_page_item menu-item-99">
<a href="#">Resources</a><ul class="sub-menu">
<li><a href="https://help.gnome.org">Documentation</a></li>
<li><a href="https://wiki.gnome.org">Wiki</a></li>
<li><a href="https://mail.gnome.org/mailman/listinfo">Mailing Lists</a></li>
<li><a href="https://wiki.gnome.org/GnomeIrcChannels">IRC Channels</a></li>
<li><a href="https://gitlab.gnome.org/">Bug Tracker</a></li>
<li><a href="https://gitlab.gnome.org/">Development Code</a></li>
<li><a href="https://wiki.gnome.org/Jhbuild">Build Tool</a></li>
</ul>
</li></ul></div>
<div class="menu-footer-4-container"><ul id="menu-footer-4" class="menu"><li id="menu-item-104" class="menu-item menu-item-type-custom menu-item-104">
<a href="http://www.gnome.org/news/">News</a><ul class="sub-menu">
<li><a href="https://www.gnome.org/start/stable">Latest Release</a></li>
<li><a href="https://planet.gnome.org">Planet GNOME</a></li>
<li><a href="https://news.gnome.org">Development News</a></li>
<li><a href="https://twitter.com/gnome">Twitter</a></li>
</ul>
</li></ul></div>
</div>
<div class="links grid_3 right"><div>
<ul class="menu available_languages"><li>
<strong>This website is available in many languages</strong><ul class="sub-menu"><li><a href="/languages" title="Switching Language">Switch Language</a></li></ul>
</li></ul>
<script type="text/javascript" src="/js/language.js"></script>
</div></div>
<div id="footnotes" class="grid_9">
                Copyright © 2005‒2014 <strong class="gnome_logo">The GNOME Project</strong><br><small>Optimised for standards. Hosted by <a href="http://redhat.com">Red Hat</a>.</small>
</div>
<div class="clear"></div>
</div></div>
<script type="text/javascript">
$(document).ready(function() {
    // Get browser
    $.each($.browser, function(i) {
        $('body').addClass(i);
        return false;
    });

    // Get OS and add it as class to body tag, this then allows forcing some
    // customisation in the CSS rules.
    var match = navigator.userAgent.toLowerCase().match(/(win|mac|linux)/);
    if (match) {
        $('body').addClass(match[0]);
    }
});
</script><script type="text/javascript">
      var _paq = _paq || [];
      _paq.push(['disableCookies']);
      _paq.push(["trackPageView"]);
      _paq.push(["enableLinkTracking"]);

      (function() {
        var u=(("https:" == document.location.protocol) ? "https" : "http") + "://webstats.gnome.org/";
        _paq.push(["setTrackerUrl", u+"piwik.php"]);
        _paq.push(["setSiteId", "6"]);
        var d=document, g=d.createElement("script"), s=d.getElementsByTagName("script")[0]; g.type="text/javascript";
        g.defer=true; g.async=true; g.src=u+"piwik.js"; s.parentNode.insertBefore(g,s);
      })();
    </script>
</body>
</html>
